import{_ as s,o as n,c as a,a as t}from"./app-d9da1b6d.js";const o="/steven-blogs/assets/netcode35_1-8276a588.png",e="/steven-blogs/assets/netcode35_2-055883a3.png",p="/steven-blogs/assets/netcode35_3-47150269.png",c="/steven-blogs/assets/netcode35_4-4cdf0944.png",l="/steven-blogs/assets/netcode35_5-7c9fd156.png",i="/steven-blogs/assets/netcode35_6-fcd91456.png",r="/steven-blogs/assets/netcode35_7-4fa03923.png",u="/steven-blogs/assets/netcode35_8-0b625500.png",d="/steven-blogs/assets/netcode35_9-4be16ed1.png",k="/steven-blogs/assets/netcode35_10-d1e8e35c.png",h="/steven-blogs/assets/netcode35_11-583b81b1.png",m="/steven-blogs/assets/netcode35_12-e3c9bfc9.png",b={},g=t('<h1 id="在ie中托管-net-windows-forms" tabindex="-1"><a class="header-anchor" href="#在ie中托管-net-windows-forms" aria-hidden="true">#</a> 在IE中托管.NET Windows Forms</h1><p>如果曾经使用Java开发过Web应用程序，你一定会对Java applets比较熟悉，这是一种基本上在浏览器中运行的小型程序。当浏览器加载包含有Java applets标志的HTML代码时，Java applets就会执行，网页中的Windows Forms控件的运行方式与Java applets相似。我们可以使用由Windows Forms技术提供的丰富的类开发Windows Forms控件，然后在网页中部署这些控件，当浏览器加载这些网页时，就会执行包含在Windows Forms控件中的代码。</p><p>.NET的伟大之处之一是它提供的与IE的无缝集成能力。例如，我们甚至能够在用户不知道的情况下从IE中激活一个Windows Forms控件。尽管利用了由.NET CLR提供的Code Access Security的所有功能，但这是在无需进行注册的情况下完成的。</p><p>当开发Windows Forms控件时，我们就通过继承的方式拥有了Windows Forms类所提供的所有功能。例如，我们可以使用Windows Forms控件验证技术对用户输入的数据进行广泛的验证，同样地，我们可以从窗体控件中调用远程Web服务。通过使用所有这些技术，我们就能够使用.NET平台开发丰富、功能强大的应用程序。</p><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h2><p>在这一部分，我们将学习如何创建简单的Windows Forms控件并将它托管在IE中。下面是激活IE中Windows Forms控件的5个步骤：</p><ul><li>创建Windows Forms控件</li><li>创建包含标识Windows Forms控件的对象标志的HTML文档</li><li>配置正确激活控件所需要的虚拟目录</li><li>配置代码访问权限</li><li>运行该控件</li></ul><p>下面我们就来详细地学习上面的每一个步骤。</p><h3 id="创建windows-forms控件" tabindex="-1"><a class="header-anchor" href="#创建windows-forms控件" aria-hidden="true">#</a> 创建Windows Forms控件</h3><p>在这一步骤中，我们将创建一个简单的Windows Forms控件，它向用户显示“Hello World”信息。如政略所示，我们将首先创建一个名为HelloWorldControl的新Visual C# Windows Control Library项目。</p><p><img src="'+o+`" alt="35_1"></p><p>一旦创建项目后，我们将把缺省的用户控件更名为HelloWorldCtl。我们将在用户控件上添加一个名为lblMessage的标签控件和一个名为btnClick的按钮。当用户点击点击按钮时，程序就会执行下面的代码，向用户显示一个简单的信息：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">btnClick_Click</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">System<span class="token punctuation">.</span>EventArgs</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    lblDisplayMessage<span class="token punctuation">.</span>Text <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>既然已经创建了控件，下面我们来编译该项目，并创建可执行代码。</p><h3 id="创建html网页" tabindex="-1"><a class="header-anchor" href="#创建html网页" aria-hidden="true">#</a> 创建HTML网页</h3><p>在这一步骤中，我们将创建一个HTML文档，并在其中插入用来激活Windows Forms控件的对象标志。HTML网页如下：</p><div class="language-html" data-ext="html"><pre class="language-html"><code>＜html＞
＜body＞
＜p＞Hello World Control＜br＞ ＜br＞＜/body＞
＜object id=&quot;HelloWorldControl1&quot;
classid=&quot;http:HelloWorldControl.dll#HelloWorldControl.HelloWorldCtl&quot;
height=&quot;500&quot; width=&quot;500&quot; VIEWASTEXT＞
＜/object＞
＜br＞＜br＞
＜/html＞
</code></pre></div><p>在对象标志的classid属性中，我们将路径指定为控件库组合体和控件的全名，控件的全名包括名字空间和控件类名字。从上面的代码中可以看到，组合体和控件全名之间用#号隔开，这二个参数构成了识别该控件的唯一控件标识符。由于是唯一地由名字HelloWorldControl1标识的，我们还可以针对该控件编写客户端脚本代码。</p><h3 id="配置虚拟目录" tabindex="-1"><a class="header-anchor" href="#配置虚拟目录" aria-hidden="true">#</a> 配置虚拟目录</h3><p>创建HTML代码后，我们就可以创建一个名为HelloWorldControlHost的新虚拟目录，并在其中添加控件（HelloWorldControl.dll）和HTML文档（HelloWorld.htm）。除了配置虚拟目录外，将虚拟目录的执行权限设置为Scripts也是非常重要的。如果将其执行权限设置为Scripts &amp; Executables，控件就不会被正确地激活。通过打开虚拟目录的Properties窗口（下图），我们可以验证虚拟目录的权限。</p><p><img src="`+e+'" alt="35_2"></p><h3 id="配置代码访问权限" tabindex="-1"><a class="header-anchor" href="#配置代码访问权限" aria-hidden="true">#</a> 配置代码访问权限</h3><p>如果控件在企业内部网上，它公正确地执行，但如果要运行来自互联网网站上的控件，就需要对IE进行配置或修改安全策略，使它能够运行。通过将托管网页看成是受信任区段的一部分，就能够做到这一点。为了将你的站点设置为受信任区段的一部分，我们可以在IE中通过选择“工具”-＞“选项”-＞“安全”-＞“受信任的站点”，然后将你的站点添加到列表中，再点击“OK”按钮。这样下次再浏览到该网页时，控件就会得到正确的执行，因为已经设置了互联网许可。</p><h3 id="运行控件" tabindex="-1"><a class="header-anchor" href="#运行控件" aria-hidden="true">#</a> 运行控件</h3><p>要运行控件，只要在浏览器中浏览托管该控件的HTML网页即可。在显示的HTML网页中，如果点击“Click Here”命令按钮，控件就会如下图所示显示“Hello World”的消息。</p><p><img src="'+p+'" alt="35_3"></p><p><strong>在这个例子中，我们主要演习了如何创建简单的Windows Forms控件，并在IE中托管它。在下一部分，我们将学习如何使用Windows Forms控件从客户机中直接访问Web服务。</strong></p><h2 id="从windows-forms控件中访问web服务" tabindex="-1"><a class="header-anchor" href="#从windows-forms控件中访问web服务" aria-hidden="true">#</a> 从Windows Forms控件中访问Web服务</h2><p>Windows Forms控件的主要优点是它能够使我们在客户机上实现丰富的用户体验。例如，我们能够直接从客户机上访问Web服务，然后甚至在无需刷新网页的情况下向用户显示结果。为了演示这一点，我们将首先创建一个Web服务，然后从Windows Forms控件中调用该Web服务。</p><h3 id="创建web服务" tabindex="-1"><a class="header-anchor" href="#创建web服务" aria-hidden="true">#</a> 创建Web服务</h3><p>首先，如图所示，我们将创建一个名为AuthorsWebService的Visual C# ASP.NET Web服务。</p><p><img src="'+c+`" alt="35_4"></p><p>Web服务创建后，我们就能够将Web服务类的名字修改为AuthorsService，然后在AuthorsService类中添加一个名为GetAuthors的新方法。GetAuthors方法如下所示：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">WebMethod</span></span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token return-type class-name">DataSet</span> <span class="token function">GetAuthors</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//从配置文件中获得连接串</span>
    <span class="token class-name"><span class="token keyword">string</span></span> connString <span class="token operator">=</span> System<span class="token punctuation">.</span>Configuration<span class="token punctuation">.</span>ConfigurationSettings<span class="token punctuation">.</span>AppSettings<span class="token punctuation">[</span><span class="token string">&quot;connectionString&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">SqlConnection</span> sqlConn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SqlConnection</span><span class="token punctuation">(</span>connString<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">DataSet</span> dstAuthors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DataSet</span><span class="token punctuation">(</span><span class="token string">&quot;Authors&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">SqlDataAdapter</span> adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SqlDataAdapter</span><span class="token punctuation">(</span><span class="token string">&quot;Select * from Authors&quot;</span><span class="token punctuation">,</span>sqlConn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//用查询结果填写Dataset</span>
    adapter<span class="token punctuation">.</span><span class="token function">Fill</span><span class="token punctuation">(</span>dstAuthors<span class="token punctuation">,</span><span class="token string">&quot;Author&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//关闭和处理被打开的数据库连接</span>
    sqlConn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sqlConn<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//向调用者返回Authors Dataset</span>
    <span class="token keyword">return</span> dstAuthors<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>GetAuthors方法的代码非常简单，我们首先从web.config文件中获得连接字符串，它被存储在web.config文件的appSettings小节中。</p><div class="language-xml" data-ext="xml"><pre class="language-xml"><code>＜appSettings＞
＜add key=&quot;connectionString&quot; value=&quot;server=localhost;uid=sa;pwd=thiru;database=Pubs&quot;＞
＜/add＞
＜/appSettings＞
</code></pre></div><p>然后我们使用连接字符串作为一个参数创建SqlConnection对象的一个实例，再以执行的查询和SqlConnection对象为参数创建一个SqlDataAdapter对象的实例，然后，我们调用SqlDataAdapter对象的Fill方法执行查询，并用查询的填写DataSet。最后我们释放所有资源，并将DataSet返回给Web服务的调用者。在创建Web服务后，我们就可以着手开始创建Web服务的客户端应用程序了。</p><h3 id="为web服务客户端的windows-forms控件的创建" tabindex="-1"><a class="header-anchor" href="#为web服务客户端的windows-forms控件的创建" aria-hidden="true">#</a> 为Web服务客户端的Windows Forms控件的创建</h3><p>由于希望从Windows Forms控件中调用Web服务，我们将创建一个名为AuthorsWebServiceClientControl的新Visual C# Control Library项目。</p><p><img src="`+l+'" alt="35_5"></p><p>创建项目后，我们可以将缺省的用户控件改名为AuthorsControl。我们可以在用户的控件中添加名为gridAuthors的DataGrid和名为btnClick的命令按钮。在命令按钮的Click事件中，我们将编写调用Web服务的代码。在此之前，我们可以在Visual Studio .NET中使用“Add Web Reference”选项添加该Web服务的地址。在“Add Web Reference”对话框中，我们可以输入Web服务的位置并按回车键，然后点击“Add Reference”按钮添加Web服务的地址。这样，我们就为Authors Web服务创建了一个代理。</p><p><img src="'+i+`" alt="35_6"></p><p>创建代理后，我们就可以开始添加调用Web服务的代码了，这部分代码添加在此前添加的命令按钮中的click事件中。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">btnClick_Click</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">System<span class="token punctuation">.</span>EventArgs</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>Cursor <span class="token operator">=</span> Cursors<span class="token punctuation">.</span>WaitCursor<span class="token punctuation">;</span>
    <span class="token class-name">AuthorsWebServiceProxy<span class="token punctuation">.</span>AuthorsService</span> authorsSvc <span class="token operator">=</span> <span class="token keyword">new</span> 
            <span class="token constructor-invocation class-name">AuthorsWebServiceProxy<span class="token punctuation">.</span>AuthorsService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    gridAuthors<span class="token punctuation">.</span>DataSource <span class="token operator">=</span> authorsSvc<span class="token punctuation">.</span><span class="token function">GetAuthors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>Cursor <span class="token operator">=</span> Cursors<span class="token punctuation">.</span>Default<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的几行代码中，我们创建了Web服务代理类的一个实例，然后调用了GetAuthors方法，将从Web服务返回的DataSet赋予DataGrid控件的DataSource属性。现在，就可以对项目进行编译，创建组合体了。</p><h3 id="html网页和虚拟目录的创建" tabindex="-1"><a class="header-anchor" href="#html网页和虚拟目录的创建" aria-hidden="true">#</a> HTML网页和虚拟目录的创建</h3><p>在这一步骤中，我们将创建托管AuthorsWebServiceClientControl控件的HTML网页，HTML网页的代码如下所示：</p><div class="language-html" data-ext="html"><pre class="language-html"><code>＜html＞
＜body＞
＜p＞Authors Display Control＜br＞ ＜br＞＜/body＞
＜object id=&quot;AuthorsControl1&quot;
classid=&quot;http:AuthorsWebServiceClientControl.dll#AuthorsWebServiceClientControl.AuthorsControl&quot;
height=&quot;500&quot; width=&quot;500&quot; VIEWASTEXT＞
＜/object＞
＜br＞＜br＞
＜/html＞
</code></pre></div><p>在创建HTML网页后，我们还需要创建一个用来托管HTML网页和控件的虚拟目录。创建虚拟目录后，我们就可以将HTML网页和控件拷贝到被映射到虚拟目录的物理目录中。现在，我们就可以通过浏览HTML网页对控件进行测试了，在HTML网页中，我们会看到是窗体控件一部分的命令控件。如果点击命令按钮，它就会从客户机上的浏览器调用Web服务，并在DataGrid中显示Web服务的结果。HTML网页的输出如下所示：</p><p><img src="`+r+'" alt="35_7"></p><h3 id="调试windows-forms控件" tabindex="-1"><a class="header-anchor" href="#调试windows-forms控件" aria-hidden="true">#</a> 调试Windows Forms控件</h3><p>为了调试该控件，我们需要完成下面的步骤：</p><ul><li><p>打开浏览器，请求浏览上面创建的HTML网页。</p></li><li><p>打开Visual Studio.NET，从菜单中选择“工具”-＞“调试进程”，显示下面的对话框：</p><p><img src="'+u+'" alt="35_8"></p></li><li><p>在进程对话框，选择IEXPLORE.EXE，点击“附加”按钮。点击“附加”按钮时，会出现下图所示的对话框，它会提醒你选择要调试的程序类型。在该对话框中，确保选择了清单中的“公共语言运行库”选项。</p><p><img src="'+d+'" alt="35_9"></p></li><li><p>点击上面对话框中的“OK”按钮将使我们重新返回到进程对话框，这次，我们只需点击“关闭”按钮即可。</p><p><img src="'+k+'" alt="35_10"></p></li><li><p>从“文件”-＞“打开”-＞“文件”菜单中打开用户控件文件AuthorsWebServiceClientControl.cs，并在命令按钮的Click事件中设置断点。</p></li><li><p>返回到浏览器并点击命令按钮，程序会自动运行到刚才在控件中设置的断点处，我们就可以使用Visual Studio .NET的所有功能调试代码。</p><p><img src="'+h+`" alt="35_11"></p></li></ul><h3 id="代码访问权限和windows-forms控件" tabindex="-1"><a class="header-anchor" href="#代码访问权限和windows-forms控件" aria-hidden="true">#</a> 代码访问权限和Windows Forms控件</h3><p>象我们在上面讨论的那样，当控件在IE中执行时，它会利用了.NET运行时间库提供的代码访问权限。为了理解在IE中运行的Windows Forms控件是如何与由.NET运行时间库提供的代码访问安全机制协调运行的，我们在Authors窗体控件中添加几行代码，并创建新的事件日志源。经过修改后，控件的load事件如下所示：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AuthorsControl_Load</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">System<span class="token punctuation">.</span>EventArgs</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>EventLog<span class="token punctuation">.</span><span class="token function">SourceExists</span><span class="token punctuation">(</span><span class="token string">&quot;TestSource&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        EventLog<span class="token punctuation">.</span><span class="token function">CreateEventSource</span><span class="token punctuation">(</span><span class="token string">&quot;TestSource&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TestLog&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        EventLog<span class="token punctuation">.</span><span class="token function">DeleteEventSource</span><span class="token punctuation">(</span><span class="token string">&quot;TestSource&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        EventLog<span class="token punctuation">.</span><span class="token function">CreateEventSource</span><span class="token punctuation">(</span><span class="token string">&quot;TestSource&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TestLog&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的几行代码中，我们检查名为TestSource的EventLog源是否存在，如果不存在，则创建一个，否则我们删除现有的事件源，再创建一个新的事件源。也许你已经想到，执行这样的操作需要更高的权限，从互联网上下载的控件不应当具有执行这种操作的权限。为了确保这一点，我们将控件的输出拷贝到虚拟目录中。在完成这一操作后，如果用浏览器浏览托管有控件的HTML网页，我们会看到下面的对话框：</p><p><img src="`+m+'" alt="35_12"></p><p>上面的对话框清楚地表明，控件中的代码受到了.NET时间运行库中代码访问安全机制的限制。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>在在IE中使用Windows Forms前，我们需要注意它的优点和限制。它的主要优点有：</p><ul><li>通过Web实现动态丰富用户体验的能力。</li><li>客户端编译代码的自动缓冲。</li><li>与.NET代码访问安全机制的无缝集成，使我们能够从客户端利用.NET安全模型</li><li>胜过Java applets的性能。</li></ul><p>限制包括：</p><ul><li>要求客户端安装有Windows操作系统。</li><li>只有IE 6.0提供对这类托管方式的支持</li><li>要求客户机上安装.NET运行时间库</li><li>要求服务器端至少安装Windows 2000、IIS 5.0或者以上版本软件。</li></ul><p>由于会受到上面的种种限制，检测客户机是否具有这种能力是必要的。例如，由于在IE中托管窗体控件需要在客户机上安装有.NET运行时间库，我们就可以编写检查客户机是否安装有.NET运行时间库的代码。我们可以通过检查Request.Browser.ClrVersion属性的值来完成这一操作，如果安装了，则会返回版本号，否则会返回0.0。</p><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论" aria-hidden="true">#</a> 结论</h2><p>在本篇文章中，我们学习了如何在IE中托管Windows Forms控件以及如何调试控件，我们还学习了如何利用.NET代码访问安全机制配置在浏览器中运行时控件能够执行的操作。 尽管这一技术要求特定的平台，但它仍然不失为一种有前途的技术，尤其是考虑到.NET Framework将成为未来版本的Windows的有机组成部分。</p>',67),w=[g];function W(v,_){return n(),a("div",null,w)}const f=s(b,[["render",W],["__file","netcode35.html.vue"]]);export{f as default};
