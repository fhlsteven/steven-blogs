import{_ as a,o as s,c as n,a as e}from"./app-a2b6e588.js";const t={},c=e(`<h1 id="c-学习笔记-1" tabindex="-1"><a class="header-anchor" href="#c-学习笔记-1" aria-hidden="true">#</a> c#学习笔记(1)</h1><blockquote><p>作者:michaelhaw CSDN 2002-04-26</p></blockquote><h2 id="_1-结构-struct-与-类-class" tabindex="-1"><a class="header-anchor" href="#_1-结构-struct-与-类-class" aria-hidden="true">#</a> 1, 结构(struct) 与 类(class)</h2><p><code>[attributes] [modifiers] struct identifier [:interfaces] body [;]</code></p><p>结构与类很相似，都表示可以包含数据成员和函数成员的数据结构。与类不同的是，结构是值类型并且不需要堆分配。结构类型的变量直接包含结构的数据，而类类型的变量包含对数据的引用（该变量称为对象）。 struct 类型适合表示如点、矩形和颜色这样的轻量对象。尽管可能将一个点表示为类，但结构在某些方案中更有效。在一些情况下，结构的成本较低。例如，如果声明一个含有 1000 个点对象的数组，则将为引用每个对象分配附加的内存。结构可以声明构造函数，但它们必须带参数。声明结构的默认（无参数）构造函数是错误的。总是提供默认构造函数以将结构成员初始化为它们的默认值。在结构中初始化实例字段是错误的。在类中,必须初始化实例对象. 使用 new 运算符创建结构对象时，将创建该结构对象，并且调用适当的构造函数。与类不同的是，结构的实例化可以不使用 new 运算符。如果不使用 new，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用。对于结构，不像类那样存在继承。一个结构不能从另一个结构或类继承，而且不能作为一个类的基。但是，结构从基类 Object 继承。结构可实现接口，其方式同类完全一样。</p><p>[c++] 与 C++ 不同，无法使用 struct 关键字声明类。在 C# 中，类与结构在语义上是不同的。结构是值类型，而类是引用类型。</p><h2 id="_2-装箱和拆箱-取消装箱" tabindex="-1"><a class="header-anchor" href="#_2-装箱和拆箱-取消装箱" aria-hidden="true">#</a> 2, 装箱和拆箱(取消装箱)</h2><p>装箱是值类型到 object 类型或到该值类型所实现的任何接口类型的隐式转换。将一个值的值装箱会分配一个对象实例并将该值复制到新的对象中。关键字 object. 取消装箱是从 object 类型到值类型或从接口类型到实现该接口的值类型的显式转换。取消装箱操作包括：检查对象实例，确保它是给定值类型的一个装箱值。将该值从实例复制到值类型变量中。</p><p>例:</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// A value type</span>
<span class="token class-name"><span class="token keyword">object</span></span> box <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// Boxing</span>
<span class="token class-name"><span class="token keyword">int</span></span> j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>box<span class="token punctuation">;</span> <span class="token comment">// Unboxing</span>
</code></pre></div><p>装箱转换<br> 取消装箱</p><h2 id="_3-隐式和显式" tabindex="-1"><a class="header-anchor" href="#_3-隐式和显式" aria-hidden="true">#</a> 3 , 隐式和显式</h2><p>下列转换属于隐式转换：例:<code>object o=i;</code><br> 标识转换。<br> 隐式数值转换。<br> 隐式枚举转换。<br> 隐式引用转换。<br> 装箱转换。<br> 隐式常数表达式转换。<br> 用户定义的隐式转换。<br> 下列转换属于显式转换： <code>object 0=(object)i;</code><br> 所有隐式转换。<br> 显式数值转换。<br> 显式枚举转换。<br> 显式引用转换。<br> 显式接口转换。<br> 取消装箱转换。<br> 用户定义的显式转</p><h2 id="_4-delegate-委托" tabindex="-1"><a class="header-anchor" href="#_4-delegate-委托" aria-hidden="true">#</a> 4, delegate(委托)</h2><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">D</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M1</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M2</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token keyword">class</span><span class="token punctuation">{</span>……<span class="token punctuation">.</span><span class="token class-name">D</span> cd1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">D</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span>M1<span class="token punctuation">)</span><span class="token punctuation">;</span>…………<span class="token punctuation">.</span><span class="token punctuation">}</span>
</code></pre></div><p>委托是一个数据结构，该数据结构引用一个静态方法，或引用一个对象实例和该对象的实例方法。在 C 或 C++ 中与委托最接近的是函数指针，但函数指针只能引用静态函数，而委托可以同时引用静态方法和实例方法。在后一种情况中，委托不仅存储对方法入口点的引用，还存储对调用其方法的对象的引用。与 C++ 函数指针不同，委托是完全面对对象的；与指向成员函数的 C++ 指针不同，委托同时封装对象实例和方法。委托声明定义从类 System.Delegate 派生的类。委托实例封装一个或多个方法，每个方法都被称为可调用实体。对于实例方法，可调用实体由一个实例和该实例上的方法组成。对于静态方法，可调用实体仅由一个方法组成。给定委托实例和适当的参数集，便可以用该参数集调用此委托实例的所有方法。委托实例的一个有趣和有用的属性是它不了解或不关心它所封装的方法的类；真正重要的只是方法要与委托的类型兼容, 这使委托非常适合“匿名”调用。可选的形参表指定委托的参数，而返回类型则指示委托的返回类型。如果下面两个条件都为真，则方法和委托类型是兼容的：(兼容的概念就是可以用此声明的委托对方法进行委托).</p><p>1它们具有相同的参数数目，并且类型相同，顺序相同，参数修饰符也相同。<br> 2它们的返回类型相同。</p><p>C# 中的委托类型是名称等效的，而不是结构等效的。（但是请注意：两个不同但结构上等效的委托类型的实例可能会比较为相等）,准确地说，两个具有相同参数列表、签名和返回类型的不同的委托类型被认为是不同的委托类型。委托实例所封装的方法集合称为调用列表。</p><h2 id="_5-interface-接口" tabindex="-1"><a class="header-anchor" href="#_5-interface-接口" aria-hidden="true">#</a> 5, interface(接口)</h2><p><code>[attributes] [modifiers] interface identifier [:base-list] {interface-body}[;]</code></p><p>一个接口定义一个协定。实现接口的类或结构必须遵守其协定。接口可以从多个基接口继承，而类或结构可以实现多个接口。接口可以包含方法、属性、事件和索引器。接口本身不提供它所定义的成员的实现。接口只指定实现该接口的类或接口必须提供的成员。接口可以是命名空间或类的成员，并且可以包含下列成员的签名：方法属性 索引器.</p><p>一个接口可从一个或多个基接口继承。接口可由类实现。实现的接口的标识符出现在类的基列表中。被继承的接口称为该接口的显式基接口。当接口具有一个或多个显式基接口时，在该接口声明中，接口标识符后跟一个冒号以及由逗号分隔的基接口标识符列表。接口的基接口是显式基接口及其基接口。换言之，基接口集是显式基接口、它们的显式基接口（依此类推）的完全可传递的闭包。接口继承其基接口的所有成员。接口成员是通过 I.M 和 I[A] 形式的成员访问和索引访问表达式访问的，其中 I 是接口类型的实例，M 是该接口类型的方法、属性或事件，A 是索引器参数列表。接口可以由类和结构实现。为了指示类或结构实现接口，在该类或结构的基类列表中包含了接口标识符。在实现类或结构中定位接口成员的实现的过程称为接口映射。</p><h2 id="_6-object" tabindex="-1"><a class="header-anchor" href="#_6-object" aria-hidden="true">#</a> 6,object</h2><p>object 类类型是所有其他类型的最终基类。C# 中的每种类型都是直接或间接从 object 类类型派生的。可以把任何类型的数值给object类型.</p><h2 id="_7-string类型" tabindex="-1"><a class="header-anchor" href="#_7-string类型" aria-hidden="true">#</a> 7,string类型</h2><p>string 类的实例表示 Unicode 字符串。尽管 string 是引用类型，但相等运算符（== 和 !=）被定义为比较 string 对象（而不是引用）的“值”（7.9.7 字符串相等运算符）。这使得对字符串相等性的测试更为直观。字符串为 string 类型并可写成两种形式，即用引号引起来和用 <code>@</code> 引起来。用引号引起来的字符串括在双引号 (&quot;) 内, 并且可以包含包括换码序列在内的任何字符用 <code>@</code> 引起来的字符串以 <code>@</code> 开头，并用双引号引起来。用 <code>@</code> 引起来的字符串以 <code>@</code> 开头，并用双引号引起来。若要在一个用 <code>@</code> 引起来的字符串中包括一个双引号，请使用两对双引号：<code>@</code> 符号的另一种用法是使用碰巧成为 C# 关键字的被引用的 (/reference) 标识符。</p><h2 id="_8-修饰符" tabindex="-1"><a class="header-anchor" href="#_8-修饰符" aria-hidden="true">#</a> 8, 修饰符</h2><p>修饰符作用<br> 访问修饰符<br><code>public</code><br><code>private</code><br><code>internal</code><br><code>protected</code><br> 指定声明的类型和类型成员的可访问性。</p><p>访问不受限制<br> 只有包含该类的成员的类可以访问<br> 只有当前工程可以访问<br> 只有包含该成员的类和继承的类可以访问<br> abstract指示某个类只能是其他类的基类。<br> const指定无法修改字段或局部变量的值。<br> event声明一个事件。<br> extern指示外部实现此方法。<br> override提供从基类继承的虚拟成员的新实现。<br> readonly声明一个字段，该字段只能赋值为该声明的一部分或者在同一类的构造函数中。<br> sealed指定类不能被继承。<br> static声明属于类型本身而不是属于特定对象的成员。<br> unsafe声明不安全的上下文。<br> virtual在派生类中声明其实现可由重写成员更改的方法或访问器。<br> volatile指示字段可由操作系统、硬件或并发执行的线程等在程序中进行修改。</p><h2 id="_9-语句" tabindex="-1"><a class="header-anchor" href="#_9-语句" aria-hidden="true">#</a> 9,语句</h2><p>语句是程序指令。除非特别说明，语句都按顺序执行。C# 具有下列类别的语句。<br> 类别C# 关键字<br> 选择语句<code>if, else, switch, case</code><br> 迭代语句<code>do, for, foreach, in, while</code><br> 跳转语句<code>break, continue, default, goto, return</code><br> 异常处理语句<code>throw, try-catch, try-finally</code><br><code>Checked</code> 和 <code>Uncheckedchecked, unchecked</code><br><code>fixed</code> 语句<code>Fixed</code><br><code>lock</code> 语句<code>Lock</code></p><p>(1) foreach 语句为数组或对象集合中的每个元素重复一个嵌入语句组。foreach 语句用于循环访问集合以获取所需信息，但不应用于更改集合内容以避免产生不可预知的副作用。此语句的形式如下：</p><p><code>foreach (type identifier in expression) statement</code></p><p>若要循环访问集合，集合必须满足特定的要求。集合类型：<br> 必须是 interface、class 或 struct。<br> 必须包括返回类型的名为 GetEnumerator 的实例方法，例如 Enumerator（详见下文）。</p><p>Enumerator 类型（类或结构）必须包含：<br> 一个名为 Current 的属性，它返回 ItemType 或者可以转换为此类型的类型。属性访问器返回集合的当前元素。<br> · 一个名为 MoveNext 的 bool 方法，它递增项计数器并在集合中存在更多项时返回 true。</p><p>有三种使用集合的方法：<br> 使用上述指导创建一个集合。此集合只能用于 C# 程序。<br></p><ol><li>使用上述指导创建一个一般集合，另外实现 IEnumerable 接口。此集合可用于其他语言（如 Visual Basic）。 <br></li><li>在集合类中使用一个预定义的集合。<br></li></ol><p>(2) throw 语句用于发出在程序执行期间出现反常情况（异常）的信号。throw 语句的形式为：</p><p><code>throw [expression];</code><br> expression :异常对象。当在 catch 子句中再次引发当前异常对象时，它被省略。</p><p>(3)try –catch语句</p><p>try-catch 语句由一个 try 块和其后所跟的一个或多个 catch 子句（为不同的异常指定处理程序）构成。try-catch 语句采用下列形式之一：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">try</span> <span class="token keyword">try</span><span class="token operator">-</span>block
<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">exception</span><span class="token operator">-</span>declaration<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">catch</span><span class="token operator">-</span>block<span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">exception</span><span class="token operator">-</span>declaration<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">catch</span><span class="token operator">-</span>block<span class="token operator">-</span><span class="token number">2</span>
<span class="token range operator">..</span><span class="token punctuation">.</span>
<span class="token keyword">try</span> <span class="token keyword">try</span><span class="token operator">-</span>block <span class="token keyword">catch</span> <span class="token keyword">catch</span><span class="token operator">-</span>block
</code></pre></div><p>(4) fixed</p><p>防止变量被垃圾回收器重定位。</p><p>(5) lock</p><p>lock 关键字将某个语句块标记为临界区。</p><h2 id="_6-方法参数" tabindex="-1"><a class="header-anchor" href="#_6-方法参数" aria-hidden="true">#</a> 6. 方法参数</h2><p>如果为没有 ref 或 out 的方法声明一个参数，则此参数可以具有关联的值。可以在方法中更改该值，但当控制传递回调用过程时，不会保留更改的值。通过使用方法参数关键字，可以更改这种行为。如果没有ref,out则默认为值传递,虽然可以在方法中修改这个参数的值,但是修改后的值不会还会到调用该方法的程序中.</p><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>params :params 关键字可以指定在参数数目可变处采用参数的方法参数
ref :引用传递
out :
</code></pre></div><h2 id="_7-namespace-名字空间" tabindex="-1"><a class="header-anchor" href="#_7-namespace-名字空间" aria-hidden="true">#</a> 7, namespace(名字空间)</h2>`,50),o=[c];function p(r,l){return s(),n("div",null,o)}const i=a(t,[["render",p],["__file","summary2.html.vue"]]);export{i as default};
