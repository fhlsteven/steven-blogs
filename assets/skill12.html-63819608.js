import{_ as i,o as l,c as e,a as p}from"./app-d9da1b6d.js";const t={},o=p(`<h1 id="c-编码应注意的事项清单" tabindex="-1"><a class="header-anchor" href="#c-编码应注意的事项清单" aria-hidden="true">#</a> C#编码应注意的事项清单</h1><p>转贴：Andy.m 日期：2004-03-04 人气：10</p><p>这是从<code>WebBlog@Asp.Net</code>上摘下来的一片文章，原文在那我已经记不清了，大概是最近十来天的文章吧，读了以后，感觉不错，不过其中有些地方，我读了以后，糊里糊涂的就过去了，自己也搞不清其中的含义，不过，我倒是把文章翻译出来了，现在这儿放着，以后有机会再该。内容如下:</p><p>我现在的客户端广泛的使用PSP（注：程序段前缀），所以我回顾了用在我们项目中的c#代码，并归纳出一个清单。非常感激你能对此做出评论</p><ol><li><p>是否使用异常来显示错误而不是返回状态或错误代码？</p></li><li><p>所有的类和公共方法是否使用.NET样式的注释？注意，<code>&lt;summary&gt;</code>注释应该论述公共方法是什么。对于怎么使用则应该放在<code>&lt;remarks&gt;</code>块中或是内嵌于正被讨论的代码中</p></li><li><p>如果方法的参数不正确，是否使用一个异常来进行确认和拒绝？</p></li><li><p>Debug.Asserts是否被用来验证关于代码功能的假定？注释例如：&quot;j will be positive&quot;应该被作为断言（Asserts）重写</p></li><li><p>那些不应该被初始化的类是否有一个私有的构造函数？</p></li><li><p>那些被声明为值类型并极少使用为方法参数的类是否从方法中返回或是存放在集合（Collections）中？</p></li><li><p>那些被只应用在一个程序集中的类是否被标记为internal？</p></li><li><p>那些能被多线程访问的单态类（Singletons）是否能够被正确地初始化？参考 the Enterprise Solution Patterns book, p. 263.</p></li><li><p>必须被继承类重载的方法是否被标记为abstract？</p></li><li><p>不应该被重载的类是否标记为sealed？</p></li><li><p>“as” 是否可能被不正确的使用？</p></li><li><p>是否类重载 ToString 而不是定义另外一个方法来输出对象的状态？</p></li><li><p>是否一个长的信息被发送到日志组件而不是控制台？</p></li><li><p>一个finally程序块是否紧随一个try构造以用作必须执行的代码？</p></li><li><p>相对于for（int i…..）构造,是否更倾向于使用foreach？</p></li><li><p>是否使用属性而不是实现getter和setter方法？</p></li><li><p>相对于没有赋值器的属性，是否更倾向于使用只读变量？</p></li><li><p>被继承类重载的所有方法是否使用了override关键字？</p></li><li><p>是否倾向于使用接口类而不是抽象类？</p></li><li><p>是否写代码基于接口而不是一个实现类？</p></li><li><p>那些资源消耗大的对象是否实现了IDisposable接口？</p></li><li><p>那些实现了IDisposable的对象是否在使用的时候才初始化？</p></li><li><p>相对于Monitor Enter 构造，是否更倾向于使用lock关键字？</p></li><li><p>是否线程被事件或Pulse构造从等待状态激活，而不是调用Sleep（）等方式“积极”的等待？</p></li><li><p>如果重载equals,是否正确地实现了这一方法？重载equals的规则是复杂的，细节请参见Richter p153-160</p></li><li><p>如果== 和！=被重载，由此他们重定向到了Equals？</p></li><li><p>是否提供了Equals的那些对象也提供了GetHashCode的重载版本？GetHashCode提供了和Equals相同的语义。注意：GetHashCode的重载应该利用对象的成员变量并且必须返回一个不再更改的哈希码。</p></li><li><p>是否所有的异常类有一个构造函数带有一个字符参数，另外一个构造函数带有一个字符参数和一个异常参数？</p></li><li><p>是否所有的异常类继承与基本的Matrix异常并正确地适合异常的层次？</p></li><li><p>是否那些将要被封送或远程调用的类使用了Serializable属性？</p></li><li><p>是否那些使用了Serializable属性的类，包括Exception和EventArgsl类型的类，有一个默认的构造函数？</p></li><li><p>那些实现了ISerializable的类是否即提供了必须的GetObjectData重载也提供了带有一个SerializeInfo和一个StreamingContext参数的构造函数？</p></li><li><p>在作浮点值运算的时候，是否所有的常量加倍而不是整数？</p></li><li><p>是否所有的代理有一个void返回类型并且避免使用out或ref参数？</p></li><li><p>是否继承于EventArgs的类中的所有成员都是只读？这将阻止一个预订者更改这个EventArgs以免影响另一个预订者。</p></li><li><p>代理是否被发布为事件？这将阻止预订者引发事件。详细请参见Lowy, p. 102</p></li><li><p>通常的安装和卸载nUnit代码是否孤立于那些标记了合适属性的安装和卸载方法？</p></li><li><p>消极的单元测试是否使用ExpectedExceptin属性去显示一定会抛出某一个异常</p></li></ol><p><strong>参考</strong>：</p><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>Juval Lowy, &quot;Programming .NET Components&quot;
Jeffrey Richter, &quot;Applied Microsoft .NET Framework Programming&quot;
&quot;Enterprise Solution Patterns using Microsoft .NET&quot; - available in published form or as a free pdf
</code></pre></div>`,7),a=[o];function r(s,n){return l(),e("div",null,a)}const d=i(t,[["render",r],["__file","skill12.html.vue"]]);export{d as default};
