import{_ as s,r as t,o,c as p,b as n,d as a,e as c,a as r}from"./app-477de5b2.js";const i={},l={id:"垃圾回收笔记-4-——托管和非托管资源",tabindex:"-1"},u=n("a",{class:"header-anchor",href:"#垃圾回收笔记-4-——托管和非托管资源","aria-hidden":"true"},"#",-1),k={href:"https://cnblogs.com/koffer/archive/2004/06/05/13593.html",target:"_blank",rel:"noopener noreferrer"},d=r(`<p>Posted on 2004-06-05 14:00 柚子Nan 阅读(2904) 评论(4)</p><p>研究了5天的垃圾回收器，看了王咏刚的文章，code project上的2篇文章和MSDN,终于明白了那么一点点。在.net 编程环境中，系统的资源分为托管资源和非托管资源。</p><p>对于托管的资源的回收工作，是不需要人工干预回收的，而且你也无法干预他们的回收，所能够做的只是了解.net CLR如何做这些操作。也就是说对于您的应用程序创建的大多数对象，可以依靠 .NET Framework 的垃圾回收器隐式地执行所有必要的内存管理任务。</p><p>对于非托管资源，您在应用程序中使用完这些非托管资源之后，必须显示的释放他们，例如System.IO.StreamReader的一个文件对象，必须显示的调用对象的Close()方法关闭它，否则会占用系统的内存和资源，而且可能会出现意想不到的错误。</p><p><strong>我想说到这里，一定要清楚什么是托管资源，什么是非托管资源了？</strong></p><p>最常见的一类非托管资源就是包装操作系统资源的对象，例如文件，窗口或网络连接，对于这类资源虽然垃圾回收器可以跟踪封装非托管资源的对象的生存期，但它不了解具体如何清理这些资源。还好.net Framework提供了Finalize()方法，它允许在垃圾回收器回收该类资源时，适当的清理非托管资源。如果在MSDN Library 中搜索Finalize将会发现很多类似的主题，这里列举几种常见的非托管资源：<code>ApplicationContext，Brush,Component,ComponentDesigner,Container,Context,Cursor，FileStream,Font,Icon,Image,Matrix,Object,OdbcDataReader,OleDBDataReader,Pen,Regex,Socket,StreamWriter,Timer,Tooltip</code>等等资源。可能在使用的时候很多都没有注意到！</p><p>关于托管资源，就不用说了撒，像简单的int,string,float,DateTime等等，.net中超过80%的资源都是托管资源。</p><p>非托管资源如何释放，.NET Framework 提供 Object.Finalize 方法，它允许对象在垃圾回收器回收该对象使用的内存时适当清理其非托管资源。默认情况下，Finalize 方法不执行任何操作。默认情况下，Finalize 方法不执行任何操作。如果您要让垃圾回收器在回收对象的内存之前对对象执行清理操作，您必须在类中重写 Finalize 方法。然而大家都可以发现在实际的编程中根本无法override方法Finalize(),在C#中，可以通过<strong>析构函数</strong>自动生成 Finalize 方法和对基类的 Finalize 方法的调用。</p><p>例如：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token operator">~</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token comment">// Perform some cleanup operations here.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该代码隐式翻译为下面的代码。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Perform some cleanup operations here.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">finally</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，在编程中，并不建议进行override方法Finalize()，因为，实现 Finalize 方法或析构函数对性能可能会有负面影响。一个简单的理由如下：用 Finalize 方法回收对象使用的内存需要<strong>至少两次</strong>垃圾回收，当垃圾回收器回收时，它只回收没有终结器(Finalize方法)的不可访问的内存，这时他不能回收具有终结器(Finalize方法)的不可以访问的内存。它改为将这些对象的项从终止队列中移除并将他们放置在标记为“准备终止”的对象列表中，该列表中的项指向<strong>托管堆</strong>中准备被调用其终止代码的对象，下次垃圾回收器进行回收时，就回收并释放了这些内存。</p><p>当然还有其它的影响不使用Finalize()的理由，参考后续的文章！</p><hr><hr><p>1楼 2004-06-05 17:33 by 仪表</p><blockquote><p>恩，理解了一下道理，不过我看一般C#写的程序占用内存都比较大，如果我将程序最小化，那么就会减少很多，有没有这样的库来实现这点呢？</p></blockquote><p>2楼 2004-06-07 10:48 by juqiang</p><blockquote><p>to 仪表，程序最小化，会少用很多内存，这是很正常的。不过，你应该监视每个process的虚拟内存，而不是taskmgr中默认的物理内存。<br> 每个form程序，都会占用很多gdi资源，这都是需要内存的。</p></blockquote><p>3楼 2004-06-07 11:21 by Koffer</p><blockquote><p>.net程序占用内存应该是很大的。<br> 我估计是因为在托管堆中运行，OS对这些了如指掌！</p></blockquote><p>4楼 2009-02-17 12:05 by 阿水</p><blockquote><p>楼主说的不对吧 我觉得支用时使用CLR 就不需要考虑 自己释放资源<br> 应为CLR都是托管代码 当然相应的资源 就是托管除非你使用 wIN32API<br> 或者 COM 什么的 如果都是使用CLR 的就不需要考虑这个问题</p></blockquote>`,24);function m(b,g){const e=t("ExternalLinkIcon");return o(),p("div",null,[n("h1",l,[u,a(),n("a",k,[a("垃圾回收笔记(4)——托管和非托管资源"),c(e)])]),d])}const f=s(i,[["render",m],["__file","netfw7.html.vue"]]);export{f as default};
