import{_ as a,o as l,c as i,a as r}from"./app-f0851ed3.js";const e={},p=r(`<h1 id="有效的开发方式" tabindex="-1"><a class="header-anchor" href="#有效的开发方式" aria-hidden="true">#</a> 有效的开发方式</h1><h2 id="序言" tabindex="-1"><a class="header-anchor" href="#序言" aria-hidden="true">#</a> 序言</h2><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>   需求—&gt;分析设计（建模阶段）—&gt;编码实现—&gt;运行时
                                  /   \\
                                / /   \\ \\
|  第一次迭代  |  第二次迭代  |  第三次迭代  | … |  第N次迭代  |  项目结束
         团队：项目经理，需求经理，架构师，美工，编码工程师，测试工程师等
</code></pre></div><p>在项目开发的过程中，我们就像一只漫长的行军队伍行走在崇山峻岭中，在翻过的每一个山头后，我们总结来时的路，向往未来的路，然后又毅然向下一个目标挺进。</p><p>当我们最终到达目的时，我们在想是否我们选择的路过于崎岖，是不是走了很多冤枉路？而如果我们我们的部队不幸夭折在半路，那么我们的英灵是否也在抱怨，谁在半路夺去我的“美好前程”？</p><p>在管理项目时，有ISO9001，有CMMI 4，有质量管理方法（PDCA），有公司的规章制度，那么多的圈把我们套向正确的轨道，可是为什么有时候我们的效率和想法往往没有达到预期的目标了？总结我们的开发方式也许会让我们看清楚，我们到底是在哪做的不够，在哪我们忽略了。</p><h2 id="一-我们的开发方式" tabindex="-1"><a class="header-anchor" href="#一-我们的开发方式" aria-hidden="true">#</a> 一，我们的开发方式</h2><p>我先暂时不考虑开发过程中一些细小的过程结点，仅根据<strong>需求—&gt;分析设计—&gt;编码实现—&gt;运行时</strong>以及以往的经验，总结了我们现在采用的开发方式（或者称为开发模式）。</p><h3 id="第一步-需求-需求和界面原型相互完善" tabindex="-1"><a class="header-anchor" href="#第一步-需求-需求和界面原型相互完善" aria-hidden="true">#</a> 第一步： 需求：需求和界面原型相互完善</h3><ul><li>主要工作</li></ul><p>完成界面的工作以配合需求人员去客户处进行系统讲解。需求设计师完成《需求设计说明书》。</p><ul><li>需要人员</li></ul><p>需求设计师，美工，项目经理。</p><ul><li>对应完成框架中的部分</li></ul><ol><li>界面原型的生成。</li><li>界面权限系统的生成。</li><li>界面菜单的生成。</li></ol><ul><li>需完成的文档</li></ul><p>《需求设计说明书》、《需求跟踪表》、</p><ul><li>效果</li></ul><p>需求人员可以使用我们制作出的界面与用户进行沟通，并进一步的明确用户的需要。并可以提前去实现与客户的交流。</p><h3 id="第二步-分析设计-根据需求制定计划-同时完成数据库设计-pdm" tabindex="-1"><a class="header-anchor" href="#第二步-分析设计-根据需求制定计划-同时完成数据库设计-pdm" aria-hidden="true">#</a> 第二步： 分析设计：根据需求制定计划，同时完成数据库设计（PDM）</h3><ul><li>主要工作</li></ul><p>根据需求合理制定工作计划，架构师根据需求完成《概要设计说明书》和数据库设计。</p><ul><li>需要人员</li></ul><p>架构师，项目经理。</p><ul><li>对应完成框架中的部分</li></ul><ol><li>估计工作量，合理安排工作时间。</li><li>开发环境配置：开发语言，开发工具，配置库目录等。</li><li>数据库表的生成，部分数据库存储过程的生成。</li></ol><ul><li>需完成的文档</li></ul><p>《XXX进度计划.mpp》、《项目估算表》、《项目风险管理表》、《项目估算表》、《 XXX数据库设计.pdm》、《 概要设计说明书》、</p><ul><li>效果</li></ul><p>根据工作量安排好计划，搭建好环境。</p><h3 id="第三步-编码实现-完成界面逻辑和业务逻辑" tabindex="-1"><a class="header-anchor" href="#第三步-编码实现-完成界面逻辑和业务逻辑" aria-hidden="true">#</a> 第三步： 编码实现：完成界面逻辑和业务逻辑</h3><ul><li>主要工作</li></ul><p>通过前面两个步骤，我们已经实现了将除去业务的部分完成。剩下的就是完成基本代码。这部分的工作包括:界面展现逻辑，数据库增删改查和其它业务逻辑（比如删除一个商品的时候要去判断是不是这条商品已经被使用过等这些的业务流程。）</p><ul><li>对应完成框架中的部分</li></ul><ol><li>开发界面逻辑和业务逻辑。</li><li>单元测试。</li><li>数据库表的生成，数据库存储过程的生成。</li></ol><ul><li>需完成的文档</li></ul><p>《XX模块设计说明》、《readme》、</p><ul><li>效果</li></ul><p>在每次的迭代过程中保证可以跑的程序。</p><h3 id="第四步-运行时-维护升级" tabindex="-1"><a class="header-anchor" href="#第四步-运行时-维护升级" aria-hidden="true">#</a> 第四步： 运行时：维护升级</h3><ul><li>主要工作</li></ul><p>主要是修改测试库中的问题和升级。</p><ul><li>操作框架中的部分</li></ul><ol><li>根据测试库中记录的问题进行修改和确认。</li><li>将一些小型的变更记录到《小型变更跟踪表》。</li></ol><ul><li>需完成的文档</li></ul><p>《用户手册》、《小型变更跟踪表》、</p><ul><li>效果</li></ul><p>最终完成。</p><h2 id="二-分析问题-优化开发方式" tabindex="-1"><a class="header-anchor" href="#二-分析问题-优化开发方式" aria-hidden="true">#</a> 二，分析问题，优化开发方式</h2><p>我们的现在的开发方式先进的地方是采用了迭代开发，能够将变化控制在有效范围内，但这种开发方式也有很多欠考虑的地方：比如在分析设计，编码实现和运行时的分离和弱连接，使得在编码工程师在编码前缺少有效的沟通和计划，在面对变化的能力减弱。</p><h3 id="_1-分析设计和编码实现的分离-编码前缺少有效的沟通和计划" tabindex="-1"><a class="header-anchor" href="#_1-分析设计和编码实现的分离-编码前缺少有效的沟通和计划" aria-hidden="true">#</a> 1，分析设计和编码实现的分离，编码前缺少有效的沟通和计划</h3><p>目前的基本上所有设计都是弱的设计（只是程度不同），就是说设计不能直接的或不能完全直接的产生代码实现，一旦管理不严，代码实现就会脱离设计，尤其在一个项目测试后期或运行期，并且需求变化比较大的时候；甚至一个被长期维护的系统，设计往往早已消失，只有维护的人员知道系统目前的样子。至于从实现反向的产生设计的反向工程，那更是一个高难的动作。这种弱的设计直接导致的就是实现缺乏控制，最后导致软件的失败或缩短软件生命期。目前解决这个问题从技术和人两个角度来考虑，一方面使用UML这样的语言来强化设计，另一方面用CMMI这样的规范来强化人的管理。要指出的是UML对设计的强化是有限度的，CMMI的管理也会大幅度提高成本。</p><h4 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法" aria-hidden="true">#</a> 解决方法</h4><p>在编码开始前，加强开发组长和编码工程师的沟通和交流，使编码工程师有分析问题的能力。在项目管理中，项目经理需要指出项目中高级程序员必须指导他们所属的程序员。（可以使用结对开发的方式）</p><p>①.程序员必须了解清楚自己所做部分的需求。<br> ②.程序员必须了解清楚自己与其他人所做模块的衔接点,及其应该注意的地方。<br> ③.程序员在开发前最好编写一个开发的步骤文档</p><h4 id="解决步骤" tabindex="-1"><a class="header-anchor" href="#解决步骤" aria-hidden="true">#</a> 解决步骤</h4><p>(1) 弄清表间的关系(例如：A表与B表的关系究竟是1：N 还是 1对1 还是 N：M)<br> (2) 看自己工作所需是视图还是表，如果是视图，先编写好视图的sql语句，这里亦可以当做一个数据备份<br> (3) 写出业务逻辑运行步骤，例如先计算A，后计算B，再计算C。这样写代码的时候，就可以一步一步根据文档有序的往下编写程序。<br> (4) 构思出对页面的布局及做法并写进文档。<br> (5) 让你的上级对文档进行评审以便他对的你的错误地方在编写程序前已可以当面指出。<br> (6) 编写2点中与他人模块间的衔接点及注意的地方，以及以什么方式衔接（例如是采用接口，还是某个对象）<br> 4.正式编写代码。（为了可以提高自己的写代码的效率，可以利用代码生成器生成基本代码，根据文档增加进所需的逻辑业务。）<br> 5.代码编写完成后，要进行测试。 测试既要自己测试，也要提供大量的模拟数据给测试人员方便进行测试。因此，应该编写一个模拟数据的存储过程。</p><h3 id="_2-编码实现和运行时的分离-面对变化的能力弱" tabindex="-1"><a class="header-anchor" href="#_2-编码实现和运行时的分离-面对变化的能力弱" aria-hidden="true">#</a> 2，编码实现和运行时的分离，面对变化的能力弱</h3><p>这种分离导致了开发者在编写代码的需要想象系统运行时的状况，这时候开发者可以用很多实现的方法，使用哪一种取决于开发者的素质和经验，这也就是说编程是艺术的原因。消除这种随意性和不一致，就要通过反复的测试来验证运行时的结果，就是这样也无法保证代码的不作出意料之外的事情。上述因素导致了软件质量低下和漫长的测试周期。解决上述问题，一般是通过提供粒度更大的功能模块， 4GL界面，加强开发规范等方法，流行的XP(极限编程)就是一个比较好的方法，主要也是通过挖掘人的潜能。</p><p>我们仔细看：</p><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>需求—&gt;分析设计（建模阶段）—&gt;编码实现—&gt;运行时
                                  /   \\
                                / /   \\ \\
|  第一次迭代  |  第二次迭代  |  第三次迭代  | … |  第N次迭代  |  项目结束
         团队：项目经理，需求设计师，架构师，美工，编码工程师，测试工程师等
</code></pre></div><p>这个图就像一个松散的链条，一个漫长的行军队伍，问题的复杂度在人为因素的逐级参与下变得更加复杂。</p><p>每一次的迭代分离导致从需求到设计到代码实现到产生运行结果，我们想的和我们做出来的往往不一样。于是，为了达到目的：将最终结果约束到最开始的需求上，就需要增加人力成本和技术成本来完成，如购买各种开发辅助工具和增强项目管理和人员的培训，总之是通过增加各类成本来努力消除来软件的质量问题和保证进度。</p><h4 id="解决方法-敏捷性开发" tabindex="-1"><a class="header-anchor" href="#解决方法-敏捷性开发" aria-hidden="true">#</a> 解决方法：敏捷性开发</h4><p>在使用敏捷开发前，我们首先思考3个问题：</p><p><strong>问题一</strong>:</p><p>是否在第一次迭代之前就已经确定了第N次迭代的内容?如果是,那么这个内容是粗的还是细的?</p><p><strong>问题二</strong>:</p><p>第N次迭代的结果影响到第N+1次迭代,怎么办?是修改,还忽略掉;</p><p><strong>问题三</strong>:</p><p>第N次迭代过程中发现第N-1次迭代有问题,怎么办？停下本次迭代,去修复第N-1次迭代,还是忽略它,如果忽略它,又在什么时候处理？</p><p>如果什么都明确了，那就是增量而非迭代<br> 至于修改还是删除或者停止，这个处理还是要看迭代的结果，以及项目的整体状况</p><p><strong>问题一</strong>:</p><p>可以是也可以不是，如果需求很清楚，是；如果不太清楚，为赶工期边做已经清楚的需求边继续分析需求是可以的。如果是,那么这个内容是粗的还是细的？根据需求清晰的程度决定。一般来说，如果工作做得细，是可以一开始就做细节设计的，特别是各迭代的内容不太相关的情况下。但是要注意，开始做了细节设计具体实施时也往往有变动的。</p><p><strong>问题二</strong>:</p><p>当然要进行修改啊。还没有实施的计划有问题怎么能不修改？这种变动一般来说是必须的</p><p><strong>问题三</strong>:</p><p>一般说来每次迭代结束都必须有严格的测试，大BUG在本次迭代内结束。如果发生你提到的情况，如果BUG严重影响当前开发，当然必须修改；情况不严重且工期紧则可以暂时忽略，留待以后处理。</p><p>知道了以上三个问题后，引入敏捷性开发加入到迭代开发中：</p><p>对于多变的需求，我们的解决之道是：引入灵活多变的架构（支持七种CRUD开发方式），快速的应对开发。<br> 对于复杂的需求，我们的解决之道是：委派专门的建模专家跟踪理解需求，在需求和需求实现之间搭建桥梁，项目方法上采取多次迭代的敏捷软件开发方式，逐步了解学习掌握需求。<br> 经过我们的优化，我们的开发方式应该变成：</p><p>最后用《敏捷软件开发》这本书的一句话总结一下：</p><p><strong>个体和交互 胜过 过程和工具</strong><br><strong>可以工作的软件 胜过 面面俱到的文档</strong><br><strong>客户合作 胜过 合同谈判</strong><br><strong>响应变化 胜过 遵循计划</strong><br><strong>虽然右项也有价值，但是我们认为左项具有更大的价值。</strong></p>`,82),t=[p];function n(d,h){return l(),i("div",null,t)}const o=a(e,[["render",n],["__file","devfuc7.html.vue"]]);export{o as default};
