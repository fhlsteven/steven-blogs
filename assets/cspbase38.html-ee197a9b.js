import{_ as t,r as e,o as p,c as o,b as n,d as a,e as c,a as l}from"./app-477de5b2.js";const r={},u=n("h1",{id:"不知道是惊喜还是郁闷",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#不知道是惊喜还是郁闷","aria-hidden":"true"},"#"),a(" 不知道是惊喜还是郁闷")],-1),k=n("p",null,"Posted on 2004-08-12 08:13 浪淘沙 阅读(1749) 评论(9)",-1),i=n("p",null,"9月份就要辞职和MM一起读研究生了，重新过上清贫的生活，工作三年的确感触颇深，一定要用这三年的时间把自己的英语和基础知识补上，不虚此行。",-1),d={href:"https://www.cnblogs.com/xspin/articles/30788.html",target:"_blank",rel:"noopener noreferrer"},b=l(`<p>现在对Blog得出一个结论，这是一个共同分享和抒发自己内心所想之事（人、物、Code等），就好好用吧！</p><p>昨天晚上看了一小会儿《C#类库设计手册》发现自己真的缺乏很多基础性的知识。</p><p>这次理解了浅表副本和深层副本的区别，的确有些代码看似没错，但是稍加改动就能提高一些性能了，如：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code>
<span class="token comment">//获取一个浅表副本</span>
<span class="token keyword">public</span> <span class="token function">GetDataSet1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">DataSet</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//填充一个DataSet，省略</span>
    <span class="token keyword">return</span> ds<span class="token punctuation">.</span><span class="token function">Clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//获取一个深层副本</span>
<span class="token keyword">public</span> <span class="token function">GetDataSet2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">DataSet</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//填充一个DataSet，省略</span>
    <span class="token keyword">return</span> ds<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>假如<code>ds</code>是一本书，<code>GetDataSet()</code>是借书的操作，那么看看这两个区别：<br> 获取浅表副本就是把这本书直接接给读者（<code>GetDataSet1()</code>）<br> 获取深层副本就是把这本书留着（或者销毁），抄写一份给读者(<code>GetDataSet2()</code>)<br> 我想直接把书借给读者总比抄给读者性能要高吧。系统再快也有这些细微的性能上的差异，以后要注意了</p><p>中国女足0:8输给德国，真是哭笑不得.</p><hr><p>评论</p><p>1楼</p><blockquote><p>2004-08-12 09:20 by 飞刀<br> 楼主不会就是CSDN上那个买了房，又考上研究生的那个兄弟吧，哈哈。</p></blockquote><p>2楼</p><blockquote><p>2004-08-12 09:30 by cyc<br> 读书就有时间blog,研究东西了,虽然清贫,我也想blog,已经在csdn上申请了一个,等完了发布系统,就开动吧.想写些ORM和模式的东西,因为这段时间都在看这方面的书.还有就是想要用NHibernate做一个项目试试.</p></blockquote><p>3楼</p><blockquote><p>2004-08-12 09:53 by Xpoint</p></blockquote><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token function">GetDataSet2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">DataSet</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//填充一个DataSet，省略</span>
    <span class="token keyword">return</span> ds<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//--------------------------------------</span>
<span class="token keyword">public</span> <span class="token return-type class-name">DataSet</span> <span class="token function">GetDataSet2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">DataSet</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//填充一个DataSet，省略</span>
    <span class="token keyword">return</span> ds
<span class="token punctuation">}</span>
</code></pre></div><p>4楼</p><blockquote><p>2004-08-12 10:47 by janssen<br> ？？</p></blockquote><p>5楼</p><blockquote><p>2004-08-12 13:40 by =I.D=Michael<br> 就是说 return ds.Clone(); 快点?</p></blockquote><p>6楼</p><blockquote><p>2004-08-12 22:38 by 寒枫天伤<br> 有误!<br> 请参看：<br> http://www.cnblogs.com/William_Fire/archive/2004/08/12/32880.aspx</p></blockquote><p>7楼</p><blockquote><p>2004-08-13 11:27 by 浪淘沙.xp<br> 有MM陪着读研还&quot;清贫&quot;阿：），年把以后，出来搞搞兼职，前途无限阿！<br></p></blockquote><p>8楼</p><blockquote><p>2004-08-13 13:17 by janssen<br> 它的C<code>lone()</code>实际上是使用内部的 <code>MemberwiseClone()</code>，所以我认为克隆得到的新对象实际上和原对象引用相同的地址，也就是浅表副本。而<code>return ds</code> 是重新实例化了一个<code>ds</code> 所以是深表副本。</p></blockquote><p>9楼</p><blockquote><p>2004-08-28 15:22 by 浪淘沙<br> http://www.cnblogs.com/william_fire/archive/2004/08/12/32880.aspx<br> 看了这片文章对我这篇小随的讨论，觉得好像和我本来的想法不同了。<br> 呵呵，我的本意是考虑一本书的传阅的问题，没想到代码使用上可能出现的问题看起来好像走茬了</p><p>一本书我借来了，经过一番审查（GetDataSet方法），经过一番过滤和审查，认为达到我的下一级阅读者（调用GetDataSet方法的对象）阅读要求，决定放行。</p><p>这时候我是直接把这本书重新抄写一份给下一级阅读者然后将“原著”销毁掉方便呢？还是抄写一份目录给下一级阅读者让他直接照着目录来看我这本“原著”好？</p><p>我认为是抄写目录好，而不是整书抄写一份给下一个阅读者。<br> 在有人阅读我的“原著”时，GC发现有相应的引用则暂缓销毁；<br> 所有人阅读完毕我的“原著”后，GC发现没有相应的引用了，便开始进行销毁操作；</p><p>当然这种直接引用的方法在“阅读”时倒是没什么，但是在“批注”时就要多考虑一些问题了，当有人打算修改我的“原著”的话是让他自己抄写一份去修改还是直接修改“原著”，然后然所有人都看到修改后的原著？</p></blockquote><hr><h4 id="re-不知道是惊喜还是郁闷" tabindex="-1"><a class="header-anchor" href="#re-不知道是惊喜还是郁闷" aria-hidden="true">#</a> re: 不知道是惊喜还是郁闷</h4><p>读书就有时间blog,研究东西了,虽然清贫,我也想blog,已经在csdn上申请了一个,等完了发布系统,就开动吧.想写些ORM和模式的东西,因为这段时间都在看这方面的书.还有就是想要用NHibernate做一个项目试试.</p><p>不知道是惊喜还是郁闷 一文中，指出： ........ 获取浅表副本就是把这本书直接接给读者（GetDataSet1()） 获取深层副本就是把这本书留着（或者销毁），抄写一份给读者(GetDataSet2())</p><p>我觉得有些不同的看法，而且这段代码似乎有两个问题： 1、新建的实例ds是在方法GetDataSet1及GetDataSet2中的，它们的生命周期应该就在两个方法中，让它们返回本身的引用给外部，而且还是public的，允许其它类来使用，这样似乎不但会影响封装性，而且本该直接回收的对象，却产生了引用，那么它是不是会对.net的垃圾回收造成影响?个人愚见。</p><p>2、直接return ds时，给外部获取的是这个ds对象的一个引用，实际上还是同一个实例，只有使用ds.Copy()时，才会完全复制一个新的实例。ds.Clone()，但clone()不同的是真正的建立了另一个实例，并复制了外壳和静态的数据，然后其它的内部数据(包括内部实例)，都不会被复制。在逻辑上，你操作时可以当作它们是两个对象来操作，但任何一个对象内部的非静态数据(注意：内部的“非静态”数据，外壳变化不发生影响)发生改变时，也会影响另一个。</p><p>真实情况是这样的：DataSet 提供了Clone 和 Copy 两种方法，以提供两种克隆级别。Clone 只复制 DataSet 的结构，即表、关系和约束；而 Copy 则同时克隆架构和数据，对 DataSet 的内容进行真正的深复制。所以，在理论上Clone应该会比直接return更消耗时间。</p><p>注：第1点，有异议性，那是我个人理解，并没有真正的验证过。</p><p><strong>Feedback</strong></p><h4 id="re-有个小问题-大家一起研究。" tabindex="-1"><a class="header-anchor" href="#re-有个小问题-大家一起研究。" aria-hidden="true">#</a> re: 有个小问题，大家一起研究。</h4><p>2004-08-13 08:20 by 不至于<br> 偶也认为 你说的是对的</p><h4 id="re-有个小问题-大家一起研究。-1" tabindex="-1"><a class="header-anchor" href="#re-有个小问题-大家一起研究。-1" aria-hidden="true">#</a> re: 有个小问题，大家一起研究。</h4><p>2004-08-13 08:41 by Ninputer<br> 我觉得浅表副本就是将这本书的目录抄写一遍交给对方<br> 深层副本就是将这本书完全抄写一本，再把这本书引用的所有文献也全都抄写一遍然后一起给对方。</p>`,40);function h(m,D){const s=e("ExternalLinkIcon");return p(),o("div",null,[u,k,i,n("p",null,[a("2月份考完试顺势翻译的关于"),n("a",d,[a("URL Rewriting"),c(s)]),a("的资料，一直都不敢贴上来，看得太多翻译糟糕和被骂的口水话，不过还是硬着头皮和xPilot申请一个公用Blog，壮壮胆贴了出来，居然被收藏了N多，感觉颇有成就感！:)hoho，好像有点自大了？还是应该谦虚一下吧......")]),b])}const w=t(r,[["render",h],["__file","cspbase38.html.vue"]]);export{w as default};
