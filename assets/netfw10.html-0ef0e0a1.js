import{_ as e,o as i,c as n,a as o}from"./app-8e5157a8.js";const t={},r=o('<h1 id="net编译时都做了一些什么" tabindex="-1"><a class="header-anchor" href="#net编译时都做了一些什么" aria-hidden="true">#</a> NET编译时都做了一些什么</h1><blockquote><p>www.chinacs.net 2001-5-25 8:38:00 中文C#技术站</p></blockquote><hr><hr><p>FAQ - 一个.NET程序在编译和运行时都做了些什么？</p><hr><hr><p>在新闻组和邮件列表里有大量关于一个.Net程序的设计编译(design-time or run-time)和运行原理 (CPU-specific binary or pseudo-code)的疑问。</p><p>这里是一个简单的回答：当你编译一个C#应用程序或任何一种CLS(Commmon Language Specification)兼容的语言时，它将首先被编译成一种称为IL(Intermediate Language)的伪代码(pseudo-code)。在这个应用程序第一次被运行的时候，这种IL代码将被编译成机器代码，用于执行。也就是说从源代码到得到运行结果，进行了两次编译。事实上，只有那些被真正使用的函数代码才会被进行第二次编译。下面揭示开发过程中被隐藏起来的细节：</p><ol><li>你用C#开发一些程序</li><li>用C#编译器或CLS兼容的编译器编译成EXE</li><li>编译器将生成的IL代码和附加信息(manifest)放入拥有一个标准PE头的Win32可执行文件的只读部分。</li><li>编译器在创建这个可执行文件时导入(import)一个名为_CorExeMain的函数。这个函数是.NET EE(execution engine)--.NET运行期引擎的入口函数。</li><li>当执行这个Win32可执行文件时，因为其主要是依赖于DLL的PE文件，操作系统将会调用位于MSCorEE.DLL中的_CorExeMain函数。</li><li>操作系统通过PE文件里的进入点，调用MSCorEE.DLL。并能保证在Windows里可以有很多程序同时运行。</li><li>因为操作系统不能执行.NET IL代码，EXE里的进入点只是简单的中介，它将指示操作系统调用_CorExeMain函数。</li><li>随后_CorExeMain函数开始解释位于PE文件中的IL代码。</li><li>因为IL是不能被直接执行的, .NET EE使用称为JITter (Just In Time compiler)的即时编译器将IL代码编译成本地CPU机器代码用于执行。这一即时编译过程只在第一次执行的时候进行。</li></ol>',10),a=[r];function l(c,E){return i(),n("div",null,a)}const _=e(t,[["render",l],["__file","netfw10.html.vue"]]);export{_ as default};
