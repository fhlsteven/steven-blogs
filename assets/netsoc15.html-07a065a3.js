import{_ as e,o as a,c as t,a as c}from"./app-d9da1b6d.js";const r={},n=c('<h1 id="浅析c-中的套接字编程-1" tabindex="-1"><a class="header-anchor" href="#浅析c-中的套接字编程-1" aria-hidden="true">#</a> 浅析C#中的套接字编程(1)</h1><blockquote><p>王凯明 aspcool.com 2002-04-28</p></blockquote><p>C#是微软随着VS.net新推出的一门语言。它作为一门新兴的语言，有着C++的强健，又有着VB等的RAD特性。而且，微软推出C#主要的目的是为了对抗Sun公司的Java。大家都知道Java语言的强大功能，尤其在网络编程方面。于是，C#在网络编程方面也自然不甘落后于人。本文就向大家介绍一下C#下实现套接字（Sockets）编程的一些基本知识，以期能使大家对此有个大致了解。首先，我向大家介绍一下套接字的概念。</p><h2 id="套接字基本概念" tabindex="-1"><a class="header-anchor" href="#套接字基本概念" aria-hidden="true">#</a> 套接字基本概念</h2><p>套接字是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。可以将套接字看作不同主机间的进程进行双向通信的端点，它构成了单个主机内及整个网络间的编程界面。套接字存在于通信域中，通信域是为了处理一般的线程通过套接字通信而引进的一种抽象概念。套接字通常和同一个域中的套接字交换数据（数据交换也可能穿越域的界限，但这时一定要执行某种解释程序）。各种进程使用这个相同的域互相之间用Internet协议簇来进行通信。</p><p>套接字可以根据通信性质分类，这种性质对于用户是可见的。应用程序一般仅在同一类的套接字间进行通信。不过只要底层的通信协议允许，不同类型的套接字间也照样可以通信。套接字有两种不同的类型：流套接字和数据报套接字。</p><h2 id="套接字工作原理" tabindex="-1"><a class="header-anchor" href="#套接字工作原理" aria-hidden="true">#</a> 套接字工作原理</h2><p>要通过互联网进行通信，你至少需要一对套接字，其中一个运行于客户机端，我们称之为ClientSocket，另一个运行于服务器端，我们称之为ServerSocket。</p><p>根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。</p><p>所谓服务器监听，是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。</p><p>所谓客户端请求，是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p><p>所谓连接确认，是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p><h2 id="c-中的套接字编程实例" tabindex="-1"><a class="header-anchor" href="#c-中的套接字编程实例" aria-hidden="true">#</a> C#中的套接字编程实例</h2><p>通过向大家简单的介绍套接字的基本概念和实现套接字编程的基本原理，我想大家对套接字编程已有了初步的了解。不过，上面介绍的仅仅是基本概念和原理，要真正运用还是需要一定的工作的。对基本概念和原理的真正理解的最好方法莫过于自己动手做一个实例，下面我就向大家介绍一个很好的用C#实现套接字编程的实例――聊天室程序。</p><p>本程序是基于C/S（服务器/客户端）构架的，程序包含一个服务器端的应用程序和一个客户端的应用程序。首先，在服务器上运行服务器端的应用程序，该程序一运行就开始服务器监听。然后，在客户机上就可以打开客户端的应用程序。程序打开后可以与服务器端应用程序进行连接，即进行客户端请求。在连接确认后，客户端用户可以和其他的客户端用户进行聊天。客户端人数没有限制，同时还支持“悄悄话”聊天模式，支持聊天记录。所以这是一个学习套接字编程的相当不错的例子。而且，程序中为了处理每个客户端的信息还用到了多线程机制。在每个客户端与服务器端连接成功后，它们之间就建立一个线程。这样运用了多线程之后，客户端之间就不会相互影响，即使其中一个出了错误也不会影响到另一个。</p>',15),o=[n];function h(d,p){return a(),t("div",null,o)}const i=e(r,[["render",h],["__file","netsoc15.html.vue"]]);export{i as default};
