import{_ as o,r as p,o as t,c as e,b as n,d as s,e as c,a as r}from"./app-f0851ed3.js";const l={},u={id:"窗体间传值和窗体间互操作",tabindex:"-1"},i=n("a",{class:"header-anchor",href:"#窗体间传值和窗体间互操作","aria-hidden":"true"},"#",-1),k={href:"http://www.cnblogs.com/sgsoft/archive/2004/08/16/33871.html",target:"_blank",rel:"noopener noreferrer"},d=r(`<p>今天遇到一个非常棘手的问题：子窗体在关闭时传递一个对象给父窗体。窗体关闭时会发生数据验证，当数据不正确时，窗体不可关闭。</p><p>由于编写之初总在思考一个完美的办法，导致代码总无法通过，最后，不得不使用最笨拙但有效的办法：公共静态变量。</p><p>这个静态变量不论是子窗体还是父窗体持有，都没有关系。一般而言，父窗体持有它。</p><p>现在，在子窗体中可以修改公共数据了。</p><p>但是，修改时，还必须修改父窗体的状态，我采用的一个委托，将委托作为参数传递个子窗体，在子窗体中，要更改父窗体的地方，调用这个委托。</p><p>对这种普遍的问题，有什么通用的比较好的解决方案呢？</p><p>http://tech.ccidnet.com/pub/article/c294_a34599_p1.html</p><p>这篇文章提供了一种方案，但仍然笨拙，不太好。</p><p>比如：当子窗体不一定有时，一定有时，据条件存在时，情况并不一样。</p><p>期待好的办法……</p><p>posted on 2004-08-16 17:11 海天一鸥 阅读(888) 评论(9)</p><hr><hr><p>2004-08-16 17:22 Threading</p><blockquote><p>用委托和事件机制应该是最好的解决方法了吧，或许父窗体可以用 Singleton 模式，不过没试过。</p></blockquote><p>2004-08-16 18:33 浪漫十一狼</p><blockquote><p>用静态变量不好<br> 在子窗体中定义一个public的变量，在关闭子窗体前给它赋值，然后父窗体调用<br> 例如：<br> 子窗体：<br><code>public string str;</code><br><code>str=&quot;aaa&quot;;</code><br><br> 父窗体：<br><code>childWin win=new childWin();</code><br><code>win.ShowModel();</code><br><code>MessageBox.Show(win.str);</code></p></blockquote><p>2004-08-16 18:42 Threading</p><blockquote><p>公开一个变量的方法非常不好，实在没办法了再用的。</p></blockquote><p>2004-08-16 20:09 jason</p><blockquote><p>我也遇到过，可后来想不出好的办法。折腾了一下，最后我选择如下方法：</p></blockquote><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token class-name">Form</span> _frmChangePassword<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ShowUI_ModifyPWD</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">System<span class="token punctuation">.</span>EventArgs</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_frmChangePassword <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        _frmChangePassword<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//初始化窗体 </span>
    _frmChangePassword <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">frmChangePassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _frmChangePassword<span class="token punctuation">.</span>MdiParent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    _frmChangePassword<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2004-08-17 09:02 海天一鸥</p><blockquote><p>to:jason<br> 你的办法是把子窗体作为父窗体成员。<br><br> to:浪漫十一狼<br> 子窗体关闭时，子窗体持有的变量已经消失了。<br> 除非你使用公共静态变量。</p></blockquote><p>2004-08-17 09:13 吕震宇</p><blockquote><p>如果数据简单，我使用Form.Tag，比较简单。<br><br> 以前在VFP中看到过一种对象回传复杂数据的方法：<br><br> 首先定义一个类，比如叫：cResult，用来存放子窗体返回值。然后在子窗体中添加一个带cResult类型参数的构造函数，在父窗体中编写代码：<br></p></blockquote><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name">cResult</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">cResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ChildForm</span> cf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ChildForm</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
cf<span class="token punctuation">.</span><span class="token function">ShowModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>这样，父窗体与子窗体都有cResult的一个存根，实现相互的数据传递。<br><br> 如果需要修改父窗体状态的话，可以增加cResult复杂度，加入事件功能，父窗体订阅这些事件，而子窗体负责触发事件。于是父窗体与子窗体便不会出现相互依赖的问题，它们共同依赖于cResult。这种模型相对稳定（因为cResult一旦确定下来便不容易发生变化）。<br><br> 这就是所谓的“依赖倒置”原则。</p></blockquote><p>2004-08-17 10:57 吕震宇</p><blockquote><p>写了篇文章《窗体间传递复杂数据（附源码）》，欢迎访问。</p></blockquote><p>2004-08-17 18:05 浪漫十一狼</p><blockquote><p>to 海天一鸥 :<br> 子窗体关闭就消失了吗？看来一定你一定没做过<br> to 吕震宇 ：<br> 你的方法也是定义一个公共事件，和定义一个公共变量本质上一样的</p></blockquote><p>2004-08-18 00:37 海天一鸥</p><blockquote><p>to: 浪漫十一狼 :<br> 例如：<br> 子窗体：<br><code>public string str;</code><br><code>str=&quot;aaa&quot;;</code><br><br> 父窗体：<br><code>childWin win=new childWin();</code><br><code>win.ShowModel();</code><br><code>MessageBox.Show(win.str);</code><br><br> 我查看了MSDN文档，没有看到ShowModel方法啊。 是自定义方法吗？<br><br> 窗体调用Dispose()释放后，再访问窗体变量，这是不允许的。<br><br> 吕震宇 的方法是一种解决办法。 委托是解偶合的一种手段。</p></blockquote><p>2007-03-27 10:00 ┅☆伈隨風飛</p><blockquote><p>你的哪个传值 不可以啊!<br> 我试了 不知道怎么了<br> 可能是我 方法不对,怎么的<br> 写详细点 OK</p></blockquote><p>2007-03-27 10:01 ┅☆伈隨風飛</p><blockquote><p>呵呵 哈哈</p></blockquote><p>2008-11-01 16:58 C#狂人</p><blockquote><p>我测试过了，“浪漫十一狼”的方法是正确的，不过<br><code>win.ShowModel();</code>的确是不对的，应该是<code>win.ShowDialog();</code>这样就没有问题了。</p></blockquote>`,40);function b(h,w){const a=p("ExternalLinkIcon");return t(),e("div",null,[n("h1",u,[i,s(),n("a",k,[s("窗体间传值和窗体间互操作"),c(a)])]),d])}const _=o(l,[["render",b],["__file","win13.html.vue"]]);export{_ as default};
