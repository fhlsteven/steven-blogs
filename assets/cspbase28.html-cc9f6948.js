import{_ as n,o as s,c as a,a as e}from"./app-477de5b2.js";const c={},o=e(`<h1 id="关于-net异步调用的初步总结" tabindex="-1"><a class="header-anchor" href="#关于-net异步调用的初步总结" aria-hidden="true">#</a> 关于.NET异步调用的初步总结</h1><p>最近看了看.NET异步调用方面的资料，现择重点总结，若有纰漏敬请指正。</p><h2 id="异步调用的实质" tabindex="-1"><a class="header-anchor" href="#异步调用的实质" aria-hidden="true">#</a> 异步调用的实质</h2><p>异步调用通过委托将所需调用的方法置于一个新线程上运行，从而能够使一个可能需要较长时间的任务在后台执行而不影响调用方的其他行为。</p><h2 id="异步调用的实现" tabindex="-1"><a class="header-anchor" href="#异步调用的实现" aria-hidden="true">#</a> 异步调用的实现</h2><p>前面已经讲道，异步调用通过委托实现。委托支持同步和异步调用。在同步调用中，一个委托的实例可记录多个目标方法；在异步调用中，一个委托实例中有且只能包含一个目标方法。异步调用使用委托实例的<code>BeginInvoke</code>方法和<code>EndInvoke</code>方法分别开始调用和检索返回值，这两个方法在编译期生成。调用<code>BeginInvoke</code>后委托立即返回；调用<code>EndInvoke</code>时倘若委托方法未执行完毕，则阻塞当前线程至调用完毕。</p><p>假设有一个委托</p><p><code>public delegate int ASyncHandler(int a,string b,ref string c);</code></p><p>那么，其BeginInvoke与EndInvoke的形式如下：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token return-type class-name">IAsyncResult</span> <span class="token function">BeginInvoke</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">string</span></span> b<span class="token punctuation">,</span><span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">string</span></span> c<span class="token punctuation">,</span><span class="token class-name">AsyncCallback</span> callback<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">object</span></span> asyncState<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">EndInvoke</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">string</span></span> c<span class="token punctuation">,</span><span class="token class-name">IAsyncResult</span> asyncResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>也就是说，<code>BeginInvoke</code>与<code>EndInvoke</code>的参数列表与当前委托签名有关，可以总结为：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token return-type class-name">IAsyncResult</span> <span class="token function">BeginInvoke</span><span class="token punctuation">(</span>委托所具有的全部参数，<span class="token class-name">AsyncCallback</span> callback<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">object</span></span> asyncState<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> 委托返回值 <span class="token function">EndInvoke</span><span class="token punctuation">(</span>委托参数中<span class="token keyword">ref</span><span class="token operator">/</span><span class="token keyword">out</span>部分<span class="token punctuation">,</span><span class="token class-name">IAsyncResult</span> asyncResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>BeginInvoke</code>返回一个<code>IAsyncResult</code>，其实质是实现<code>IAsyncResult</code>的<code>System.Runtime.Remoting.Messaging.AsyncResult</code>类。该对象相当于一个“凭证”，在调用<code>EndInvoke</code>时用于确认应等待返回的方法（猜测如此）。就像去银行，存钱时拿到一份存折（凭证），取款时依据存折（凭证）取款。</p><p><code>EndInvoke</code>检索委托返回值，并返回标有<code>ref/out</code>的参数值。</p><p><code>IAsyncResult</code>接口声明：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IAsyncResult</span>
<span class="token punctuation">{</span>
    <span class="token return-type class-name"><span class="token keyword">object</span></span> AsyncState<span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token return-type class-name">WaitHandle</span> AsyncWaitHandle<span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token return-type class-name"><span class="token keyword">bool</span></span> CompletedSynchronously<span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token return-type class-name"><span class="token keyword">bool</span></span> IsCompleted<span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>等待调用结束的三种方法：</p><ol><li>使用<code>EndInvoke</code>主动等待异步调用结束。这是最简单的一种方法，适用于非用户界面程序及一些IO操作，因为在调用<code>EndInvoke</code>之后当前线程被阻塞，除了等待什么都不能做。</li><li>使用<code>WaitHandle</code>等待异步调用结束。<code>IAsyncResult</code>中有<code>WaitHandle</code>成员，获取用于等待异步操作完成的<code>WaitHandle</code>，即调用结束信号。使用<code>WaitHandle.WaitOne()</code>可以阻塞当前线程至异步调用完成。这样做的好处是：在调用<code>WaitOne</code>之后、<code>EndInvoke</code>之前，可以执行其他处理。</li><li>主动轮询。使用<code>IAsyncResult</code>中有<code>IsCompleted</code>成员检索当前异步调用情况。该方法适用于用户界面程序，想象可在一个循环内做到既等待委托完成，又可以更新用户界面。</li><li>使用回调，在异步调用结束时执行一个操作。前面的<code>BeginInvoke</code>方法签名的最后两个参数用于回调。需要用到<code>AsyncCallback</code>委托：</li></ol><p><code>public delegate void AsyncCallback(IAsyncResult asyncResult);</code></p><p>回调方法在系统线程池中执行。<code>BeginInvoke</code>的最后一个参数<code>（object asyncState）</code>可以传递包含回调方法将要使用的信息的对象。在回调方法中调用<code>EndInvoke</code>可以通过取得<code>System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate</code>实现。</p><p>个人认为方法1、2相差不算太大。</p><p>先写这么些，以后再补上其他的一些东西。</p>`,22),t=[o];function p(l,d){return s(),a("div",null,t)}const u=n(c,[["render",p],["__file","cspbase28.html.vue"]]);export{u as default};
