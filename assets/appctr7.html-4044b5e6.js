import{_ as n,o as s,c as a,a as t}from"./app-f0851ed3.js";const p={},e=t(`<h1 id="如何使-net程序只运行单一实例" tabindex="-1"><a class="header-anchor" href="#如何使-net程序只运行单一实例" aria-hidden="true">#</a> 如何使.NET程序只运行单一实例</h1><p>有时你会想只运行一个程序首次运行时的实例，有些时候则可能只需要运行最新的那个实例。以下是这两种实现这两种方法的例子。</p><p>你如何才能确保只有一个.NET的程序运行在你的机器上呢？多任务操作系统在很多方面都很有用，但是有时你只需要在某一时间内运行一个实例，例如，如果程序需要使用很多的资源或者需要排它地存取某一个资源。在这种情况下，你可能想确认当另一个实例启动时，它会检查是否有另一个实例正在运行。如果是，则将自身关闭。本文中，我会告诉大家如何去实现它，还有在相关的情况下如何只允许最新的程序实例运行。请在以下地址下载程序源码<code>ftp://ftp.wdj.com/pub/webzip/newsletters/20030815dnn.zip</code></p><p>最简单的方法是使用mutex对像。例如，在以下的代码中，Form的构造函数中创建了一个mutex对象，然后　试着去存取它。如果WaitOne()返回true，那么当前线程就已经拥有了mutex，如果返回false则mutex已经被另一个线程所拥有。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Windows<span class="token punctuation">.</span>Forms</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Form</span></span>
<span class="token punctuation">{</span>
    <span class="token class-name">Mutex</span> mutex<span class="token punctuation">;</span>

    <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Text <span class="token operator">=</span> <span class="token string">&quot;Single Instance!&quot;</span><span class="token punctuation">;</span>
        mutex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Mutex</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">&quot;SINGLE_INSTANCE_MUTEX&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mutex<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            mutex<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            mutex <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">bool</span></span> disposing<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>disposing<span class="token punctuation">)</span>
            mutex<span class="token punctuation">.</span><span class="token function">ReleaseMutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span>disposing<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">App</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>app<span class="token punctuation">.</span>mutex <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> Application<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> MessageBox<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span><span class="token string">&quot;Instance already running&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在以上代码中，方法Dispose()并不严格需要，这是因为当程序结束时，垃圾回收器将会dispose并且release mutex对象。但是我仍然添加了它，这是因为Form需要一段很长的时间来释放（dispose），并且另一个窗体（Form）的实例将会启动。</p><p>这种方法只允许第一个进程实例运行。但如果你只想运行最新的那个实例时怎么办呢？就是说如果我启动了一个新的进程实例，而且之前已经有一个实例正在运行中，那么我们需要停止之前的那个线程。例如屏保的显示属性对话框。这个对话框显示一个小的预览窗口，当用用户点击预览按钮时，另一个屏保程序实例（instance)就会启动并全屏显示。当全屏实例停止时（例如你移动了鼠标），另一个屏保实例就会开始在小的预览窗口中开始运行。很明显，当全屏实例开始，这个预览的屏保窗口进程就要结束。</p><p>一种实现的方法是为每一个实例去存取一个命名的事件核心对象（named event kernel object），如果事件对象没有被触发（nonsignaled），那么此实例就继续运行；如果事件被触发则程序实例会结束。应用程序可以周期性地测试事件去看是否它已经被触发。当一个新的实例启动，它就会设置事件（去关闭其它任何实例）然后重设事件以使它可以继续运行。这种方案除了一个小问题外运行良好：.NET　Framework不会允许你命名一个核心事件（kernel event)。以下是一个实现的类</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NamedEventHelper</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">DllImport</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">&quot;kernel32&quot;</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
    <span class="token keyword">static</span> <span class="token keyword">extern</span> <span class="token return-type class-name"><span class="token keyword">uint</span></span> <span class="token function">CreateEvent</span><span class="token punctuation">(</span>
         <span class="token class-name"><span class="token keyword">uint</span></span> sec<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">bool</span></span> manualReset<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">bool</span></span> initialState<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token return-type class-name">IntPtr</span> <span class="token function">CreateEvent</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">bool</span></span> manualReset<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">bool</span></span> initialState<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> name<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">IntPtr</span><span class="token punctuation">(</span><span class="token function">CreateEvent</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> manualReset<span class="token punctuation">,</span> initialState<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">DllImport</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">&quot;kernel32&quot;</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
    <span class="token keyword">static</span> <span class="token keyword">extern</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">CloseHandle</span><span class="token punctuation">(</span><span class="token class-name">IntPtr</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">ManualResetEvent</span> <span class="token function">CreateNamedEvent</span><span class="token punctuation">(</span>
         <span class="token class-name"><span class="token keyword">bool</span></span> initialState<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> name<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">ManualResetEvent</span> mre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ManualResetEvent</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">CloseHandle</span><span class="token punctuation">(</span>mre<span class="token punctuation">.</span>Handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mre<span class="token punctuation">.</span>Handle <span class="token operator">=</span> <span class="token function">CreateEvent</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> initialState<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> mre<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上的代码中，静态（static）方法CreateNamedEvent()创建了一个ManualResetEvent对象，并释放了当前的（underlying）Win32句柄（handle）。然后再创建一个命名事件（named event）并且使用此新事件的句柄初始化了ManualResetEvent对象。此事件对象就能被用于两个应用程序间的通信。</p><p>这种方案的弱点是一个应用程序一定要看它是否已经结束。一种解决方法是运行一个后台线程去管理事件</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name">ManualResetEvent</span> mre<span class="token punctuation">;</span>
mre <span class="token operator">=</span> NamedEventHelper<span class="token punctuation">.</span><span class="token function">CreateNamedEvent</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">&quot;LAST_INSTANCE_ONLY&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Stop the other instances</span>
mre<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Reset the event so that we can run</span>
mre<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Create a monitor thread</span>
<span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">ThreadStart</span><span class="token punctuation">(</span>Monitor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Make sure that this thread cannot keep the app alive</span>
t<span class="token punctuation">.</span>IsBackground <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//The Monitor() method looks like this:</span>
<span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Monitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    mre<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Application<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果程序有一个窗体，那么另一种方法就是告诉其它窗口去关闭这个新的程序实例。如果这是一个Ｗin32应用程序，那么此程序可以简单地通过调用FindWindowsEx()，并传入一个特定的窗口类参数，然后发送WM_CLOSE消息。但是你不能对Windows Form这样做 ，因为大多数窗体（Forms)都有相同的类名，正如我在上一封newsletter是所说的。在下一个newsletter中，我会解释另一种方法去解决这类问题。</p>`,13),o=[e];function c(l,u){return s(),a("div",null,o)}const i=n(p,[["render",c],["__file","appctr7.html.vue"]]);export{i as default};
