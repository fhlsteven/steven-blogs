import{_ as e,o as t,c as a,a as n}from"./app-f0851ed3.js";const s={},o=n('<h1 id="配件-assembly-、受管-managed-、映射-reflection" tabindex="-1"><a class="header-anchor" href="#配件-assembly-、受管-managed-、映射-reflection" aria-hidden="true">#</a> 配件(assembly)、受管(managed)、映射(reflection)</h1><h2 id="什么是配件-assembly" tabindex="-1"><a class="header-anchor" href="#什么是配件-assembly" aria-hidden="true">#</a> 什么是配件(assembly)?</h2><blockquote><p>www.chinacs.net 2001-5-25 8:45:00 中文C#技术站</p></blockquote><p>什么是配件(assembly)?</p><p>assembly, 这里把它翻译为配件, 以示和组件(Component)加以区别. 如果您觉得不合适, 请指正!</p><p>一个配件有时候是指一个EXE或者DLL文件, 实际上是一个应用程序(就是指带有主程序入口点的模块)或者一个库文件. 但是配件实际上可以是由一个或者多个文件组成(dlls, exes, html等等), 代表一组资源, 以及类型的定义和实现的集合. 一个配件也可以包含对其它配件的引用. 所有这些资源、类型和引用都在一个列表(manifest)中描述。这个manifest也是配件的一部分，所以配件是一个自我描述的，不需要其它附加的部件对其描述!</p><p>配件的另一个重要特性是，它是.Net环境下类型标识的一部分，也可以说是基本单位。因为，区分一个类型的标识就是包含这个类型的配件名字加上类型名本身。举个例子，配件A定义了类型T, 配件B也定义了同名类型T，但是.Net把这两个类型认为是不同的类型。</p><p>注意，不要把配件(assembly)和名字空间(namespace)混淆起来。其实，名字空间仅仅是用来把类型名用树的形式组织起来的手段。对于运行是环境来讲，类型名就是类型名，和名字空间一点关系都没有。</p><p>总之，记住配件名加上类型名唯一标识一个运行时类型。</p><p>另外，配件也是.Net框架用于安全策略的基本单位，许多安全策略都是基于配件的。</p><h2 id="什么是受管-managed" tabindex="-1"><a class="header-anchor" href="#什么是受管-managed" aria-hidden="true">#</a> 什么是受管(managed)?</h2><blockquote><p>www.chinacs.net 2001-5-25 8:46:00 中文C#技术站</p></blockquote><p>&quot;受管&quot;的概念在.Net环境下被广泛使用,但是不同地方的含义有点差别:</p><p><strong>受管代码:</strong></p><p>.Net环境提供了许多核心的运行时服务, 比如异常处理和安全策略. 为了能使用这些服务, 必须要给运行时环境提供一些信息, 这种代码就是受管代码. 所有的C#, VB.NET, JScript.NET缺省都是受管的. 注意VS7 C++不是受管的! 但是编译器能够使用命令行选项(/com+)产生受管代码!</p><p><strong>受管数据:</strong></p><p>所有由受管代码管理的数据都是受管数据, 这些数据都通过.Net垃圾自动处理器来管理. 但是即使使用了/com+命令行选项,VS7 C++数据也不是受管的, 必须加上_gc关键字才是受管的.</p><p><strong>受管类:</strong></p><p>通常就是指在ME(Managed Extensions)下的C++类, 加上_gc关键字, 就是一个受管类了. 这就意味着什么呢?</p><ul><li>第一: 这种类的实例是由垃圾自动收集器管理的.</li><li>第二: 除了上面一点, 还有由.Net带来的益处和弊处. 比如, 这种类可以和其它语言交互访问, 比如, ME C++可以从VB类中继承. 这就是益处. 但是受管类只能从一个基类继承, 这就是弊处.</li></ul><h2 id="什么是映射-reflection" tabindex="-1"><a class="header-anchor" href="#什么是映射-reflection" aria-hidden="true">#</a> 什么是映射(reflection)?</h2><blockquote><p>www.chinacs.net 2001-5-25 8:45:00 中文C#技术站</p></blockquote><p>所有的.Net编译器在产生模块(Modules)的目标代码时都会产生有关类型的元数据(metadata), 这种元数据被捆绑在模块目标代码上(多个模块组成assemblies, 一个assembly是.Net下安全控制的基本单位,也是类型对象识别的基本单位), 这种元数据可以通过.Net环境下的reflection对象访问. System.Reflection名字空间下包含了可以访问这种数据的多种类.</p><p>使用reflection访问.Net元数据和使用ITypeLib/ITypeInfo访问COM对象的类型库数据非常类似. 例如, 决定类型数据的大小, 通过(程序上下文/进程/机器)边界列集数据传递.</p><p>所以, 可以使用Reflection对象动态引用方法(可以查看System.Type.InvokeMember), 甚至还可以动态地在运行时产生类型(System.Reflection.Emit.TypeBuilder)</p>',25),c=[o];function l(p,i){return t(),a("div",null,c)}const d=e(s,[["render",l],["__file","netfw11.html.vue"]]);export{d as default};
