(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{460:function(s,t,a){"use strict";a.r(t);var n=a(2),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"概述c-中的索引器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述c-中的索引器"}},[s._v("#")]),s._v(" 概述C#中的索引器")]),s._v(" "),t("p",[s._v("未知   新一代技术网   2002-05-15")]),s._v(" "),t("p",[s._v("C#语言一个最令人感兴趣的地方就是类的索引器（"),t("code",[s._v("indexer")]),s._v("）。简单说来，所谓索引器就是一类特殊的属性，通过它们你就可以像引用数组一样引用自己的类。显然，这一功能在创建集合类的场合特别有用，而在其他某些情况下，比如处理大型文件或者抽象某些有限资源等，能让类具有类似数组的行为当然也是非常有用的。本文就会引领你设置类来采用索引器。但是，首先让我们概述下属性这个概念以便了解些必要的背景知识。")]),s._v(" "),t("h2",{attrs:{id:"属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[s._v("#")]),s._v(" 属性")]),s._v(" "),t("p",[s._v("假如你曾经用VB6编写过程序，那么你应该很熟悉属性方法才对，所谓属性方法其实就是特殊的类成员，它实现了对私有类域的受控访问。在C#语言中有两种属性方法，其一是"),t("code",[s._v("get")]),s._v("，通过它可以返回私有域的值，其二是"),t("code",[s._v("set")]),s._v("，通过它就可以设置私有域的值。比如说，以下面的代码为例，其间创建了一个"),t("code",[s._v("FirstName")]),s._v("属性，由它控制对私有类成员"),t("code",[s._v("firstname")]),s._v("的访问：")]),s._v(" "),t("div",{staticClass:"language-csharp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-csharp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Person")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("string")])]),s._v(" firstname"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token return-type class-name"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("string")])]),s._v(" FirstName "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("get")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" firstname"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("set")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("firstname "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("value")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("属性声明可以如下编码：")]),s._v(" "),t("div",{staticClass:"language-csharp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-csharp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Person")]),s._v(" p "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token constructor-invocation class-name"}},[s._v("Person")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\np"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("FirstName "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Lamont"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nConsole"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("WriteLine "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("FirstName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("如你你所看到的那样，属性声明倒更像是域声明，只不过它还声明了两个特殊的成员，按照微软的说法就是所谓的访问函数（accessor）。当某一表达式的右边调用属性或者属性用作其他子程序（或者函数）的参数时即会调用"),t("code",[s._v("get")]),s._v("访问函数。反之，当表达式左边调用属性并且通过隐式传递"),t("code",[s._v("value")]),s._v("参数设置私有域值的情况下就会调用set访问函数。你可以创建只读属性，方法是省略"),t("code",[s._v("set")]),s._v("访问函数，这样任何设置属性的尝试都会产生编译错误。")]),s._v(" "),t("h2",{attrs:{id:"采用索引器的益处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#采用索引器的益处"}},[s._v("#")]),s._v(" 采用索引器的益处")]),s._v(" "),t("p",[s._v("说了半天咱们转到正题上来，那么为什么我要兜这个圈子呢？其实，这是因为类的索引器非常像属性，从代码上看也是这样。以下是具有索引器的类示例，通过索引器会返回一个字符串：")]),s._v(" "),t("div",{staticClass:"language-csharp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-csharp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Sample")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token return-type class-name"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("string")])]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")])]),s._v(" index"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("get")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"You passed "')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" index"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("注意，这里的属性名是"),t("code",[s._v("this")]),s._v("，意思是回引类的当前实例，参数列表包含在方括号而非括号之内。还有，这是一个只读索引器。为了把它改成读/写类型，我又添加了一个"),t("code",[s._v("set")]),s._v("访问函数。在定义索引器的时候，你不一定只采用一个参数。索引器参数可以采用任何类型，不过"),t("code",[s._v("int")]),s._v("是通常采用也是最为合理的类型。同一类中还可能拥有一个以上的索引器（重载）。")]),s._v(" "),t("p",[s._v("如上定义了Sample类之后，我们就可以把索引器用作某种默认的属性，如下所示：")]),s._v(" "),t("div",{staticClass:"language-csharp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-csharp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Sample")]),s._v(" s "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token constructor-invocation class-name"}},[s._v("Sample")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nConsole"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("WriteLine")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("55")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("h2",{attrs:{id:"属性和索引器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性和索引器"}},[s._v("#")]),s._v(" 属性和索引器")]),s._v(" "),t("p",[s._v("属性和索引器之间有好些差别：")]),s._v(" "),t("p",[s._v("类的每一个属性都必须拥有唯一的名称，而类里定义的每一个索引器都必须拥有唯一的签名（signature）或者参数列表（这样就可以实现索引器重载）。\n属性可以是"),t("code",[s._v("static")]),s._v("（静态的）而索引器则必须是实例成员。\n为索引器定义的访问函数可以访问传递给索引器的参数，而属性访问函数则没有参数。")]),s._v(" "),t("h2",{attrs:{id:"接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[s._v("#")]),s._v(" 接口")]),s._v(" "),t("p",[s._v("类似数组的行为常受到程序实现者的喜爱，所以你还可以为接口定义索引器，"),t("code",[s._v("IList")]),s._v("和"),t("code",[s._v("IDictionary")]),s._v("集合接口都声明了索引器以便访问其存储的项目。")]),s._v(" "),t("p",[s._v("在为接口声明索引器的时候，记住声明只是表示索引器的存在。你只需要提供恰当的访问函数即可，不必包括范围修饰符。以下代码把索引器声明为接口"),t("code",[s._v("IImplementMe")]),s._v("的一部分：")]),s._v(" "),t("div",{staticClass:"language-csharp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-csharp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("interface")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("IImplementMe")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token return-type class-name"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("string")])]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")])]),s._v(" index"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("get")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("set")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("相应实现的类则必须为"),t("code",[s._v("IimplementMe")]),s._v("的索引器具体定义"),t("code",[s._v("get")]),s._v("和"),t("code",[s._v("set")]),s._v("访问函数。")]),s._v(" "),t("p",[s._v("以上就是有关索引器的一些基本概述了。现在你应该对索引器在你的开发中所具有的作用有了较深入的了解。")])])}),[],!1,null,null,null);t.default=e.exports}}]);