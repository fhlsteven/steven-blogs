import{_ as n,o as a,c as s,d as e}from"./app-e911b801.js";const p={},t=e(`<h1 id="第四章-c-类型" tabindex="-1"><a class="header-anchor" href="#第四章-c-类型" aria-hidden="true">#</a> 第四章 C#类型</h1><p>既然你知道了怎样创建一个简单的C#程序，我将会给你介绍C#的类型系统。在这一章中，你学到如何使用不同的值和引用类型，加框和消框机制能为你作些什么。尽管这一章的不侧重于例子，但你可以学到很多重要的信息，关于如何创建现成类型的程序。</p><h2 id="_4-1-值类型" tabindex="-1"><a class="header-anchor" href="#_4-1-值类型" aria-hidden="true">#</a> 4.1 值类型</h2><p>各种值类型总是含有相应该类型的一个值。C#迫使你初始化变量才能使用它们进行计算-变量没有初始化不会出问题，因为当你企图使用它们时，编译器会告诉你。</p><p>每当把一个值赋给一个值类型时，该值实际上被拷贝了。相比，对于引用类型，仅是引用被拷贝了，而实际的值仍然保留在相同的内存位置，但现在有两个对象指向了它（引用它）。C#的值类型可以归类如下：</p><ul><li>简单类型（Simple types ）</li><li>结构类型（struct types）</li><li>枚举类型（Enumeration types）</li></ul><h3 id="_4-1-1-简单类型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-简单类型" aria-hidden="true">#</a> 4.1.1 简单类型</h3><p>在C#中出现的简单类型共享一些特性。第一，它们都是.NET系统类型的别名。第二，由简单类型组成的常量表达式仅在编译时而不是运行时受检测。最后，简单类型可以按字面被初始化。以下为C#简单类型归类：</p><ul><li>整型</li><li>布尔型</li><li>字符型 (整型的一种特殊情况)</li><li>浮点型</li><li>小数型</li></ul><h4 id="_4-1-1-1-整型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-1-整型" aria-hidden="true">#</a> 4.1.1.1 整型</h4><p>C#中有9个整型。 <code>sbyte</code> 、<code>byte</code>、 <code>short</code>、 <code>ushort</code>、 <code>int</code>、 <code>uint</code>、 <code>long</code>、 <code>ulong</code> 和 <code>char</code>（单独一节讨论）。它们具有以下特性：</p><ul><li><code>sbyte</code>型为有符号8位整数，取值范围在128~127之间。</li><li><code>bytet</code>型为无符号16位整数，取值范围在0~255之间。</li><li><code>short</code>型为有符号16位整数，取值范围在-32,768~32,767之间。</li><li><code>ushort</code>型为无符号16位整数，取值范围在0~65,535之间。</li><li><code>int</code>型为有符号32位整数，取值范围在-2,147,483,648~ 2,147,483,647之间。</li><li><code>uint</code>型为无符号32位整数，取值范围在 0 ~ 4,294,967,295之间。</li><li><code>long</code>型为64位有符号整数，取值范围在9,223,372,036,854,775,808~ 9,223,372,036,854,775,807之间。</li><li><code>ulong</code>型为64位无符号整数，取值范围在0 ~ 18,446,744,073,709,551,615之间。</li></ul><p>VB和C程序员都可能会对<code>int</code>和<code>long</code>数据类型所代表的新范围感到惊讶。和其它的编程语言相比，在C#中，<code>int</code>不再取决于一个机器的字<code>（word)</code>的大小，而long被设成64位。</p><h4 id="_4-1-1-2-布尔型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-2-布尔型" aria-hidden="true">#</a> 4.1.1.2 布尔型</h4><p>布尔数据类型有<code>true</code>和<code>false</code>两个布尔值。可以赋于<code>true</code>或<code>false</code>值给一个布尔变量，或可以赋于一个表达式，其所求出的值等于两者之一：</p><p><code>bool bTest = (80 &gt; 90);</code></p><p>与C和C++相比，在C#中，<code>true</code>值不再为任何非零值。不要为了增加方便而把其它整型转换成布尔型。</p><h4 id="_4-1-1-3-字符型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-3-字符型" aria-hidden="true">#</a> 4.1.1.3 字符型</h4><p>字符型为一个单Unicode 字符。一个Unicode字符16位长，它可以用来表示世界上多种语言。可以按以下方法给一个字符变量赋值：</p><p><code>char chSomeChar = &#39;A&#39;;</code></p><p>除此之外，可以通过十六进制转义符（前缀\\x）或Unicode表示法给变量赋值（前缀\\u）：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">char</span></span> chSomeChar <span class="token operator">=</span> <span class="token char">&#39;\\x0065&#39;</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">char</span></span> chSomeChar <span class="token operator">=</span> <span class="token char">&#39;\\u0065&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>不存在把char转换成其它数据类型的隐式转换。这就意味着，在C#中把一个字符变量当作另外的整数数据类型看待是行不通的——这是C程序员必须改变习惯的另一个方面。但是，可以运用显式转换：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">char</span></span> chSomeChar <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token number">65</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> nSomeInt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token char">&#39;A&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>在C中仍然存在着转义符（字符含义）。要换换脑筋，请看表4.1。</p><p>Table 4.1 转义符（ Escape Sequences）</p><table><thead><tr><th>转义符</th><th>字符名</th></tr></thead><tbody><tr><td><code>\\&#39;</code></td><td>单引号</td></tr><tr><td><code>\\&quot;</code></td><td>双引号</td></tr><tr><td><code>\\\\</code></td><td>反斜杠</td></tr><tr><td><code>\\0</code></td><td>空字符</td></tr><tr><td><code>\\a</code></td><td>感叹号（Alert ）</td></tr><tr><td><code>\\b</code></td><td>退格</td></tr><tr><td><code>\\f</code></td><td>换页</td></tr><tr><td><code>\\n</code></td><td>新行</td></tr><tr><td><code>\\r</code></td><td>回车</td></tr><tr><td><code>\\t</code></td><td>水平 tab</td></tr><tr><td><code>\\v</code></td><td>垂直tab</td></tr></tbody></table><h4 id="_4-1-1-4-浮点型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-4-浮点型" aria-hidden="true">#</a> 4.1.1.4 浮点型</h4><p>两种数据类型被当作浮点型：<code>float</code>和<code>double</code>。它们的差别在于取值范围和精度：</p><ul><li><code>float</code>: 取值范围在 1.5x10^-45~ 3.4x10^38之间， 精度为7位数。</li><li><code>double</code>: 取值范围在 5.0x10^-324 ~ 1.7x10^308之间， 精度为 15~16 位数。</li></ul><p>当用两种浮点型执行运算时，可以产生以下的值：</p><ul><li>正零和负零</li><li>正无穷和负无穷</li><li>非数字值（Not-a-Number，缩写NaN）</li><li>非零值的有限数集</li></ul><p>另一个运算规则为，当表达式中的一个值是浮点型时，所有其它的类型都要被转换成浮点型才能执行运算。</p><h4 id="_4-1-1-5-小数型-the-decimal-type" tabindex="-1"><a class="header-anchor" href="#_4-1-1-5-小数型-the-decimal-type" aria-hidden="true">#</a> 4.1.1.5 小数型（The decimal Type）</h4><p>小数型是一种高精度、128位数据类型，它打算用于金融和货币的计算。它所表示的范围从大约<code>1.0x10^-28</code> 到 <code>7.9x10^28</code>，具有28至29位有效数字。要注意，精度是以位数 (digits)而不是以小数位（decimal places）表示。运算准确到28个小数位的最大值。</p><p>正如你所看到的，它的取值范围比<code>double</code>的还窄，但它更精确。因此，没有<code>decimal</code>和<code>double</code>之间的隐式转换——往一个方向转换可能会溢出，往另外一个方向可能会丢失精度。你不得不运用显式转换。 当定义一个变量并赋值给它时，使用 m 后缀以表明它是一个小数型：</p><p><code>decimal decMyValue = 1.0m;</code></p><p>如果省略了<code>m</code>，在变量被赋值之前，它将被编译器认作<code>double</code>型。</p><h3 id="_4-1-2-结构类型" tabindex="-1"><a class="header-anchor" href="#_4-1-2-结构类型" aria-hidden="true">#</a> 4.1.2 结构类型</h3><p>一个结构类型可以声明构造函数、常数、字段、方法、属性、索引、操作符和嵌套类型。尽管列出来的功能看起来象一个成熟的类，但在C#中，结构和类的区别在于结构是一个值类型，而类是一个引用类型。与C++相比，这里可以用结构关键字定义一个类。</p><p>使用结构的主要思想是用于创建小型的对象，如Point和FileInfo等等。你可以节省内存，因为没有如类对象所需的那样有额外的引用产生。例如，当声明含有成千上万个对象的数组时，这会引起极大的差异。</p><p>清单4.1 包含一个命名为IP的简单结构，它表示一个使用byte类型的4个字段的IP地址。我不包括方法等，因为这些工作正如使用类一样，将在下一章有详细的描述。</p><p>清单4.1 定义一个简单的结构</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">IP</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">byte</span></span> b1<span class="token punctuation">,</span>b2<span class="token punctuation">,</span>b3<span class="token punctuation">,</span>b4<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">IP</span> myIP<span class="token punctuation">;</span>
        myIP<span class="token punctuation">.</span>b1 <span class="token operator">=</span> <span class="token number">192</span><span class="token punctuation">;</span>
        myIP<span class="token punctuation">.</span>b2 <span class="token operator">=</span> <span class="token number">168</span><span class="token punctuation">;</span>
        myIP<span class="token punctuation">.</span>b3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        myIP<span class="token punctuation">.</span>b4 <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;{0}.{1}.&quot;</span><span class="token punctuation">,</span>myIP<span class="token punctuation">.</span>b1<span class="token punctuation">,</span>myIP<span class="token punctuation">.</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;{0}.{1}&quot;</span><span class="token punctuation">,</span>myIP<span class="token punctuation">.</span>b3<span class="token punctuation">,</span>myIP<span class="token punctuation">.</span>b4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre></div><h3 id="_4-1-3-枚举类型" tabindex="-1"><a class="header-anchor" href="#_4-1-3-枚举类型" aria-hidden="true">#</a> 4.1.3 枚举类型</h3><p>当你想声明一个由一指定常量集合组成的独特类型时，枚举类型正是你要寻觅的。最简单的形式，它看起来可能象这样：</p><p><code>enum MonthNames { January, February, March, April };</code></p><p>因我惯用缺省设置，故枚举元素是<code>int</code>型，且第一个元素为0值。每一个连续的元素按1递增。如果你想给第一个元素直接赋值，可以如下把它设成1：</p><p><code>enum MonthNames { January=1, February, March, April };</code></p><p>如果你想赋任意值给每个元素——甚至相同的值——这也没有问题：</p><p><code>enum MonthNames { January=31, February=28, March=31, April=30 };</code></p><p>最后的选择是不同于<code>int</code>的数据类型。可以在一条语句中按如此赋值：</p><p><code>enum MonthNames : byte { January=31, February=28, March=31, April=30 };</code></p><p>你可以使用的类型仅限于<code>long</code>、<code>int</code>、<code>short</code>和<code>byte</code>。</p><h2 id="_4-2-引用类型" tabindex="-1"><a class="header-anchor" href="#_4-2-引用类型" aria-hidden="true">#</a> 4.2 引用类型</h2><p>和值类型相比，引用类型不存储它们所代表的实际数据，但它们存储实际数据的引用。在C#中提供以下引用类型给你使用：</p><ul><li>对象类型</li><li>类类 型</li><li>接口</li><li>代表元</li><li>字符串类型</li><li>数组</li></ul><h3 id="_4-2-1-对象类型" tabindex="-1"><a class="header-anchor" href="#_4-2-1-对象类型" aria-hidden="true">#</a> 4.2.1 对象类型</h3><p>对象类型是所有类型之母——它是其它类型最根本的基类。因为它是所有对象的基类，所以可把任何类型的值赋给它。例如，一个整型：</p><p><code>object theObj = 123;</code></p><p>给所有的C++程序员一个警告：<code>object</code>并不等价于你可能正在寻找的<code>void*</code>。无论如何，忘掉指针总是个好主意。</p><p>当一个值类型被加框（作为一个对象利用）时，对象类型就被使用了。这一章稍后会讨论到加框和消框</p><h3 id="_4-2-2-类类型" tabindex="-1"><a class="header-anchor" href="#_4-2-2-类类型" aria-hidden="true">#</a> 4.2.2 类类型</h3><p>一个类类型可以包含数据成员、函数成员和嵌套类型。数据成员是常量、字段和事件。函数成员包括方法、属性、索引、操作符、构造函数和析构函数。类和结构的功能是非常相似的，但正如前面所述，结构是值类型而类是引用类型。</p><p>和C++相比，仅允许单继承。（你不能拥有派生一个新对象的多重基类。） 但是，C#中的一个类可以派生自多重接口，该接口在下一节将得到描述。</p><p><a href="#csp_6">第五章</a> “类”专门讨论使用类编程。这一节仅打算给出C#类在哪里适合类型图的一个全貌。</p><h3 id="_4-2-3-接口" tabindex="-1"><a class="header-anchor" href="#_4-2-3-接口" aria-hidden="true">#</a> 4.2.3 接口</h3><p>一个接口声明一个只有抽象成员的引用类型。跟C++中相似的概念为：一个结构的成员，且方法等于0。如果你不知道那些概念的任何东西，这里就是在C#中一个接口实际所做的。仅仅只存在着方法标志，但根本就没有执行代码。这就暗示了不能实例化一个接口，只能实例化一个派生自该接口的对象。</p><p>可以在一个接口中定义方法、属性和索引。所以，对比一个类，接口有什么特殊性呢？当定义一个类时，可以派生自多重接口，而你只能可以从仅有的一个类派生。</p><p>你可能会问：&quot;OK，但我必须实现所有的接口成员，那么我能从这个途径得到什么呢?&quot; 我想举一个来自.NET的例子：很多类实现了<code>IDictionary</code> 接口。你可以使用简单的类型转换访问接口：</p><p><code>IDictionary myDict = (IDictionary)someobjectthatsupportsit;</code></p><p>现在你的代码可以访问字典了。可等等，我说很多类可以实现这个接口——所以，你可以在多个地方重用代码来访问<code>IDictionary</code> 接口！一旦学会，任何地方都可使用。</p><p>当你决定在类设计中使用接口时，学习更多关于面向对象的设计是个好主意。这本书不能教你这些概念，但你可以学习如何创建接口。以下的代码段定义接口<code>IFace</code>，它只有一个方法：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">interface</span> <span class="token class-name">IFace</span>
<span class="token punctuation">{</span>
    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ShowMyFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>正如我所提到的，不能从这个定义实例化一个对象，但可以从它派生一个类。因此，该类必须实现<code>ShowMyFace</code>抽象方法：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">class</span> <span class="token class-name">CFace</span><span class="token punctuation">:</span><span class="token type-list"><span class="token class-name">IFace</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ShowMyFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;implementation&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接口成员和类成员的区别在于，接口成员不能被实现。因此，我不想在下一章中再次提到这一点。</p><h3 id="_4-2-4-代表元-delegates" tabindex="-1"><a class="header-anchor" href="#_4-2-4-代表元-delegates" aria-hidden="true">#</a> 4.2.4 代表元 (Delegates)</h3><p>一个代表元封装了具有一些标志的一个方法。基本上，代表元是类型安全和函数指针的安全版本(回调功能)。可以同时在一个代表元实例中同时封装静态和实例方法。</p><p>尽管你可以用代表员当作具有方法，但它们的主要用途是拥有有一个类事件。再次，我想把你引到下一章，那里会详细地讨论类。</p><h3 id="_4-2-5-字符串类型" tabindex="-1"><a class="header-anchor" href="#_4-2-5-字符串类型" aria-hidden="true">#</a> 4.2.5 字符串类型</h3><p>C程序员可能会诧异，但当然，C#有一个用于操作字符串数据的基本字符串类型。字符串类直接派生自对象，且它是被密封的，这意味着再不能从它派生类。就象其它类型，字符串是预定义类System String的一个别名。</p><p>它的用法十分简单：</p><p><code>string myString = &quot;some text&quot;;</code></p><p>合并字符串同样简单：</p><p><code>string myString = &quot;some text&quot; + &quot; and a bit more&quot;;</code></p><p>而如果你想访问单个字符，所要做的就是访问下标：</p><p><code>char chFirst = myString[0];</code></p><p>当比较两个字符串是否相等时，简单地使用&quot;==&quot;比较操作符。</p><p><code>if (myString == yourString) ...</code></p><p>我只不过想提到，尽管字符串是一个引用类型，比较时是比较值，而不是比较引用(内存地址)。</p><p>字符串类型几乎用于这本书的每一个例子中，而且在这些例程中，我会介绍给你一些由字符串对象所显露的极其有趣的方法。</p><h3 id="_4-2-6-数组" tabindex="-1"><a class="header-anchor" href="#_4-2-6-数组" aria-hidden="true">#</a> 4.2.6 数组</h3><p>一个数组包含有通过计算下标访问的变量。所有包含于数组中且被当作元素的变量必须是同一类型。这种类型自然被称为&quot;数组类型&quot;。数组可以存储整数对象、字符串对象或者 你提出的任何对象。</p><p>数组的维数就是所谓的排(rank)，它决定了相关数组元素的下标数。最常用的数组是一维数组(第一排)。一个多维数组具有的排数大于1 。每个维的下标始于0，终于维的长度减1 。</p><p>应有足够的理论支持。让我们看一下用一个数组初始化器(array initializer)初始化的数组：</p><p><code>string[] arrLanguages = { &quot;C&quot;, &quot;C++&quot;, &quot;C#&quot; };</code></p><p>该简写效果等同以下：</p><p><code>arrLanguages[0]=&quot;C&quot;; arrLanguages[1]=&quot;C++&quot;; arrLanguages[2]=&quot;C#&quot;;</code></p><p>而编译器为你做了所有的工作。当然，它将同样为多维数组初始化器工作：</p><p><code>int[,] arr = {{0,1}, {2,3}, {4,5}};</code></p><p>它是以下的简写：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre></div><p>如果你不想事先初始化一个数组，但知道了它的大小，该声明就象这样：</p><p><code>int[,] myArr = new int[5,3];</code></p><p>如果数组的大小必须动态地被计算，用于数组创建的语句可以象这样写：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> nVar <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> arrToo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">int</span></span><span class="token punctuation">[</span>nVar<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>正如我在这一节开始所陈述的，你可以往数组里面塞任何东西，只要所有的元素类型都相同。因此，如果你想把任何东西放进一个数组，就声明它的类型为对象：</p><h2 id="_4-3-加框和消框-boxing-and-unboxing" tabindex="-1"><a class="header-anchor" href="#_4-3-加框和消框-boxing-and-unboxing" aria-hidden="true">#</a> 4.3 加框和消框(Boxing and Unboxing)</h2><p>这一章的课程中，我已经给出了各式各样的值类型和引用类型。由于速度的原因，你会使用值类型——它除了占据一定空间的内存块外，就没有什么了。但是，有时对象的方便性就象值类型一样好用。</p><p>这就是加框和消框登上了舞台的地方，加框和消框是C#类型系统的核心概念。通过允许一个值类型转换成类型对象或从类型对象转换成值类型，这种机制形成了值类型和引用类型之间的捆绑连接。任何东西终究是一个对象——但是，仅当需要它们是对象时。</p><h3 id="_4-3-1-加框转换" tabindex="-1"><a class="header-anchor" href="#_4-3-1-加框转换" aria-hidden="true">#</a> 4.3.1 加框转换</h3><p>给一个值加框指隐式地把任何值类型转换成类型对象。当一个值类型被加框时，一个对象实例就被分配，且值类型的值被拷贝给新的对象。</p><p>看以下例子：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> nFunny <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">object</span></span> oFunny <span class="token operator">=</span> nFunny<span class="token punctuation">;</span>
</code></pre></div><p>第二行的赋值暗示调用一个加框操作。<code>nFunny</code>整型变量的值被拷贝给<code>oFunny</code>对象。现在整型变量和对象变量都同时存在于栈中，但对象的值居留在堆中。</p><p>那么，它暗示着什么呢?它们的值互相独立——在它们之间没有连接。(<code>oFunny</code>没有引用<code>nFunny</code>的值。) 以下代码说明了结果：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> nFunny <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">object</span></span> oFunny <span class="token operator">=</span> nFunny<span class="token punctuation">;</span>
oFunny <span class="token operator">=</span> <span class="token number">2001</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;{0} {1}&quot;</span><span class="token punctuation">,</span> nFunny<span class="token punctuation">,</span> oFunny<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当代码改变<code>oFunny</code>的值时，<code>nFunny</code>的值并没有改变。只要你脑袋中有这个copy动作，就能够使用值类型的对象功能，发挥出你的巨大优势！</p><h3 id="_4-3-2-消框转换" tabindex="-1"><a class="header-anchor" href="#_4-3-2-消框转换" aria-hidden="true">#</a> 4.3.2 消框转换</h3><p>和加框相比，消框是显式操作——必须告诉编译器，你想从对象中抽取出哪一种值类型。当执行消框操作时，C#检测所请求的值类型实际上存储在对象实例中。经过成功的校验，该值被消框。</p><p>这就是消框如何执行：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> nFunny <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">object</span></span> oFunny <span class="token operator">=</span> nFunny<span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> nNotSoFunny <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>oFunny<span class="token punctuation">;</span>
</code></pre></div><p>如果错误地请求一个<code>double</code>值</p><p><code>double nNotSoFunny = (double)oFunny;</code></p><p>通用语言运行时(Common Language Runtime，简写CLR)将会引发一个<code>InvalidCastException</code>异常。你可以在<a href="#csp_8">第7章</a> &quot;异常处理&quot; 中学到更多有关异常处理的知识。</p><h2 id="_4-4-小结" tabindex="-1"><a class="header-anchor" href="#_4-4-小结" aria-hidden="true">#</a> 4.4 小结</h2><p>在这一章中，你学到了C#中用到的各种类型。简单的值类型包括整型、布尔型、浮点型和小数型。你会非常经常地用到一些类型，进行数学和金融的计算，还有逻辑表达。</p><p>在介绍引用类型之前，我显示了一个看起来象类的结构类型。它几乎如一个类般地运作，但它只是一个值类型，这使它更加适合需要有大量的小对象的场合。</p><p>引用类型起始于所有对象之母的<code>object</code>本身。object是C#中所有对象的基类，且它同样用于值类型的加框和消框。除此之外，我还让你领略了代表元、字符串和数组。</p><p>令C#程序员十分神气的类型就是类。它是C#面向对象编程的心脏，下一章整章专门让你迅速理解这个激动人心且功能强大的类型</p>`,131),o=[t];function c(l,d){return a(),s("div",null,o)}const r=n(p,[["render",c],["__file","cspcls2_4.html.vue"]]);export{r as default};
