import{_ as s,r as o,o as t,c as p,b as a,d as e,e as i,a as c}from"./app-d9da1b6d.js";const r={},l={id:"system-threading-timer类的timercallback-委托",tabindex:"-1"},u=a("a",{class:"header-anchor",href:"#system-threading-timer类的timercallback-委托","aria-hidden":"true"},"#",-1),k={href:"https://www.cnblogs.com/rickie/archive/2004/11/20/66152.html",target:"_blank",rel:"noopener noreferrer"},m=c(`<blockquote><p>Written by: Rickie Lee --- Nov. 19, 2004</p></blockquote><p><code>System.Threading.Timer</code>是一个使用回调方法的计时器，而且由线程池线程服务，简单且对资源要求不高。</p><p>只要在使用 Timer，就必须保留对它的引用。对于任何托管对象，如果没有对 Timer 的引用，计时器会被垃圾回收。即使 Timer 仍处在活动状态，也会被回收。当不再需要计时器时，请使用 Dispose 方法释放计时器持有的资源。</p><p>使用 TimerCallback 委托指定希望 Timer 执行的方法。计时器委托在构造计时器时指定，并且不能更改。此方法不在创建计时器的线程中执行，而是在系统提供的线程池线程中执行。</p><p>创建计时器时，可以指定在第一次执行方法之前等待的时间量（截止时间）以及此后的执行期间等待的时间量（时间周期）。可以使用 Change 方法更改这些值或禁用计时器。</p><h2 id="demo-application" tabindex="-1"><a class="header-anchor" href="#demo-application" aria-hidden="true">#</a> Demo application</h2><p>应用场景：在windows form程序自动执行某项工作后，希望其windows form能够自动关闭。</p><p>代码设计：</p><p>（1）首先声明Timer变量：</p><p><code>private System.Threading.Timer timerClose;</code></p><p>（2）在上述自动执行代码后面添加如下Timer实例化代码：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token comment">// Create a timer thread and start it</span>
timerClose <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Timer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">TimerCallback</span><span class="token punctuation">(</span>timerCall<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Timer构造函数参数说明：</p><p>Callback：一个 TimerCallback 委托，表示要执行的方法。<br> State：一个包含回调方法要使用的信息的对象，或者为空引用（Visual Basic 中为 Nothing）。<br> dueTime：调用 callback 之前延迟的时间量（以毫秒为单位）。指定 Timeout.Infinite 以防止计时器开始计时。指定零 (0) 以立即启动计时器。<br> Period：调用 callback 的时间间隔（以毫秒为单位）。指定 Timeout.Infinite 可以禁用定期终止。</p><p>（3）定义TimerCallback委托要执行的方法：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">timerCall</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    timerClose<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然，除了使用上述<code>System.Threading.Timer</code>类的TimerCallback 委托机制外，应该还有很多其他的办法。另外，这里只是demo了TimerCallback委托的简单应用。</p><h2 id="appendix-about-the-article" tabindex="-1"><a class="header-anchor" href="#appendix-about-the-article" aria-hidden="true">#</a> Appendix about the article</h2><p>在读一段关于Design Pattern的代码时，看到使用Timer类TimerCallback委托，随并记录下来。</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2><p>1, MSDN, System.Threading.Timer class</p><blockquote><p>posted on 2004-11-20 11:27 Rickie 阅读(240) 评论(7)</p></blockquote><hr><p>2004-11-20 11:45 bill</p><blockquote><p>试试没有注册的用户能不能发文<br> 谢谢</p></blockquote><p>2004-11-20 22:22 msolap</p><blockquote><p>用Threading.Timer来完成“应用场景：在windows form程序自动执行某项工作后，希望其windows form能够自动关闭。”</p></blockquote><ol><li>好像大材小用了。</li><li>由线程池执行WinForm控件(包括Form)的方法非常危险！因为这些方法只能由创建该窗口控件的线程执行。</li><li>由线程池线程服务，资源要求不高的说法是有问题的，因为 a)需要线程切换；b)需要创建windows核心对象。</li></ol><blockquote><p>总之，<code>System.Threading.Timer</code>改成<code>System.Windows.Forms.Timer</code>更加合适</p></blockquote><p>2004-11-22 06:23 Rickie</p><blockquote><p>Thank you, msolap.<br>*<br></p></blockquote><ol><li>好像大材小用了。<br> 是的，这里只是提供一个简单的Demo演示一下而已。</li><li>由线程池执行WinForm控件(包括Form)的方法非常危险！因为这些方法只能由创建该窗口控件的线程执行。<br> Sorry，没有很明白你的意思，希望可以进一步阐述，谢谢。<br><br> 根据Microsoft的文档：TimerCallback委托声明的回调方法，不在创建计时器的线程中执行（创建计时器的线程也就是创建该窗口控件的线程），而是在系统提供的线程池线程中执行。</li><li>由线程池线程服务，资源要求不高的说法是有问题的，因为 a)需要线程切换；b)需要创建windows核心对象。<br> System.Threading.Timer 是一个使用回调方法的计时器，而且由线程池线程服务，简单且对资源要求不高－－这是源于Microsoft的说法（也有可能Microsoft的说法不严谨）。<br><br></li></ol><blockquote><p>如果根据上述特定的Demo程序而言，正如你说言，System.Windows.Forms.Timer可能更合适。<br><br> msolap, 谢谢你的回复。</p></blockquote><p>2004-11-22 16:36 msolap</p><blockquote><p>针对第2)点，说得直白一点就是所有窗口(包括上面的控件)只能由主线程执行，不能由其他线程执行。(窗口消息队列是依附于窗口线程的)<br><br> 第3)点，英文原文应该是<br> System.Threading.Timer is a simple, lightweight timer that uses callback methods and is served by threadpool threads.<br><br> lightweigth并非指对资源要求低，只是相对于过去常用的CreateWaitableTimer(Win32 SDK)而言低一点。<br> 其实从贵文中第二段：“当不再需要计时器时，请使用 Dispose 方法释放计时器持有的资源。” 就可以体会到它对资源的要求。😃<br></p></blockquote><p>2004-11-23 00:31 Rickie</p><blockquote><p>Thanks for your explanation. So far I really know what you mean on Point 2.<br> *<br> But why do you think it&#39;s very dangerous when doing it this way?<br><br> Thanks.</p></blockquote><p>2004-11-23 23:33 msolap</p><blockquote><p>主线程肯定不会是线程池里的某个线程，所以在线程池里调用Form的this.Close()，危险！应该让主线程调用才行。</p></blockquote><p>2004-11-24 02:28 Rickie</p><blockquote><p>Thank you, msolap.</p></blockquote>`,41);function d(b,h){const n=o("ExternalLinkIcon");return t(),p("div",null,[a("h1",l,[u,e(),a("a",k,[e("System.Threading.Timer类的TimerCallback 委托"),i(n)])]),m])}const w=s(r,[["render",d],["__file","pts13.html.vue"]]);export{w as default};
