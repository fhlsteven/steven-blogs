import{_ as t,r as o,o as p,c,b as a,d as n,e as i,a as s}from"./app-f0851ed3.js";const l="/steven-blogs/assets/cspcls2_6-7f4f9169.png",r="/steven-blogs/assets/cspcls2_7-a222bca6.png",u="/steven-blogs/assets/cspcls2_8-d4638367.png",d="/steven-blogs/assets/cspcls2_9-885ea738.png",h={},k=s(`<h1 id="第10章-用未操控的代码进行内部操作-chapter-10-interoperating-with-unmanaged-code" tabindex="-1"><a class="header-anchor" href="#第10章-用未操控的代码进行内部操作-chapter-10-interoperating-with-unmanaged-code" aria-hidden="true">#</a> 第10章 用未操控的代码进行内部操作(CHAPTER 10 Interoperating with Unmanaged Code)</h1><p>.NET is definitely a cool technology. But a cool technology isn’t worth a dime if it doesn’t allow you to use the (unmanaged) code that already exists, whether the code is in the form of COM components or functions implemented in C DLLs. Furthermore, sometimes managed code might get into the way of writing high-performance code—you must be able to write unmanaged,unsafe code.</p><p>.NET and C# offer you the following techniques to interoperate with unmanaged code:</p><ul><li>COM Interoperability</li><li>Platform Invocation Services</li><li>Unsafe code</li></ul><h2 id="_10-1-com互用性-com-interoperability" tabindex="-1"><a class="header-anchor" href="#_10-1-com互用性-com-interoperability" aria-hidden="true">#</a> 10.1 COM互用性(COM Interoperability)</h2><p>The first and most interesting interoperability technique is interoperability with COM. The reason is that for a long time to come, COM and .NET must coexist. Your .NET clients must be able to call your legacy COM components, and COM clients must make use of new .NET components.</p><p>The following two sections deal with both issues:</p><ul><li>Exposing .NET objects to COM</li><li>Exposing COM objects to .NET objects</li></ul><p>Though the interoperability discussion is centered around C#, please note that you could replace C# with VB or managed C++. It is an interoperability feature provided by the .NET framework to all programming languages emitting managed code.</p><h3 id="_10-1-1-向com展示-net对象-exposing-net-objects-to-com" tabindex="-1"><a class="header-anchor" href="#_10-1-1-向com展示-net对象-exposing-net-objects-to-com" aria-hidden="true">#</a> 10.1.1 向COM展示.NET对象(Exposing .NET Objects to COM)</h3><p>One way to interoperate is to allow a COM client to use an .NET component component (written in C#, for example). To prove the feasibility, the examples presented use the namespaced version of the RequestWebPage and WhoisLookup classes’ .NET component created in Chapter 8, “Writing Components in C#.”</p><p>The various tasks involved in making an .NET component work with a COM client are presented in the following two sections:</p><ul><li>Registering a .NET object</li><li>Invoking a .NET object</li></ul><h4 id="registering-a-net-object" tabindex="-1"><a class="header-anchor" href="#registering-a-net-object" aria-hidden="true">#</a> Registering a .NET Object</h4><p>In COM, you first have to register an object before it can be used. When registering a COM object, you use the regsvr32 application, which you obviously can’t use for a COM+ 2.0 application. However, there is a similar tool for .NET components: <code>regasm.exe</code>. The <code>regasm</code> tool enables you to register an .NET component in the Registry (including all classes that are contained, given that they are publicly accessible), and it also creates a Registry file for you when you request it. The latter is useful when you want to examine what entries are added to the Registry.</p><p>The command is as follows:</p><p><code>regasm csharp.dll /reg:csharp.reg</code></p><p>The output file (csharp.reg) that is generated is shown in Listing 10.1. When you are used to COM programming, you’ll recognize the entries that are being made to the Registry. Note that the ProgId is composed of the namespace and class names.</p><p>Listing 10.1 The Registry File Generated by regasm.exe</p><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>REGEDIT4

[HKEY_CLASS_ROOT\\Presenting.CSharp.RequestWebPage]
@=”COM+ class: Presenting.CSharp.RequestWebPage”

[HKEY_CLASS_ROOT\\Presenting.CSharp.RequestWebPage\\CLSID]
@=”{6B74AC4D-4489-3714-BB2E-58F9F5ADEEA3}”

[HKEY_CLASS_ROOT\\CLSID\\{6B74AC4D-4489-3714-BB2E-58F9F5ADEEA3}]
@=”COM+ class: Presenting.CSharp.RequestWebPage”

[HKEY_CLASS_ROOT\\CLSID\\{6B74AC4D-4489-3714-BB2E-58F9F5ADEEA3}\\InprocServer32]
@=”D:\\WINNT\\System32\\MSCorEE.dll”
“ThreadingModel”=”Both”
“Class”=”Presenting.CSharp.RequestWebPage”
“Assembly”=”csharp, Ver=1.0.1.0”

[HKEY_CLASS_ROOT\\CLSID\\{6B74AC4D-4489-3714-BB2E-58F9F5ADEEA3}\\ProgId]
@=”Presenting.CSharp.RequestWebPage”

[HKEY_CLASS_ROOT\\Presenting.CSharp.WhoisLookup]
@=”COM+ class: Presenting.CSharp.WhoisLookup”

[HKEY_CLASS_ROOT\\Presenting.CSharp.WhoisLookup\\CLSID]
@=”{8B5D2461-07DB-3B5C-A8F9-8539A4B9BE34}”

[HKEY_CLASS_ROOT\\CLSID\\{8B5D2461-07DB-3B5C-A8F9-8539A4B9BE34}]
@=”COM+ class: Presenting.CSharp.WhoisLookup”

[HKEY_CLASS_ROOT\\CLSID\\{8B5D2461-07DB-3B5C-A8F9-8539A4B9BE34}\\InprocServer32]
@=”D:\\WINNT\\System32\\MSCorEE.dll”
“ThreadingModel”=”Both”
“Class”=”Presenting.CSharp.WhoisLookup”
“Assembly”=”csharp, Ver=1.0.1.0”

[HKEY_CLASS_ROOT\\CLSID\\{8B5D2461-07DB-3B5C-A8F9-8539A4B9BE34}\\ProgId]
@=”Presenting.CSharp.WhoisLookup”
</code></pre></div><p>Take a closer look at lines 30–34. As you can see, the execution engine (MSCorEE.dll) is called when an instance of your object is requested, not your library itself. The execution engine is responsible for providing the CCW (COM Callable Wrapper) for your object. If you want to register the component without a Registry file, all you have to do is issue this command:</p><p><code>regasm csharp.dll</code></p><p>Now the component can be used in programming languages that support late binding. If you are not content with late binding (and you shouldn’t be), the <code>tlbexp</code> utility enables you to generate a type library for your .NET component:</p><p><code>tlbexp csharp.dll /out:csharp.tlb</code></p><p>This type library can be used in programming languages that support early binding. Now your .NET component is a good citizen in COM society.</p><p>Now that we are in the COM world, I want to dive right into the type library and point out a few important things. I have used the OLE View application, which comes with Visual Studio, to open the type library and extract the IDL (Interface Description Language) of the classes contained in the .NET component. Listing 10.2 shows the results I obtained.</p><p>Listing 10.2 The IDL File for the WhoisLookup and RequestWebPage Classes</p><div class="language-IL" data-ext="IL"><pre class="language-IL"><code>// Generated .IDL file (by the OLE/COM Object Viewer)
// 
// typelib filename: &lt;could not determine filename&gt;

[
uuid(A4466FD5-EB56-3C07-A0D8-43153AC4FD06),
version(1.0)
]
library csharp
{
// TLib : // TLib : : {BED7F4EA-1A96-11D2-8F08-00A0C9A6186D}
importlib(&quot;mscorlib.tlb&quot;);
// TLib : OLE Automation : {00020430-0000-0000-C000-000000000046}
importlib(&quot;stdole2.tlb&quot;);

// Forward declare all types defined in this typelib
interface _RequestWebPage;
interface _WhoisLookup;

[
uuid(6B74AC4D-4489-3714-BB2E-58F9F5ADEEA3),
custom({0F21F359-AB84-41E8-9A78-36D110E6D2F9}, &quot;Presenting.CSharp.RequestWebPage&quot;)
]
coclass RequestWebPage {
[default] interface _RequestWebPage;
interface _Object;
};

[
odl,
uuid(1E8F7AAB-FA6C-315B-9DFE-59C80C6483A9),
hidden,
dual,
nonextensible,
oleautomation,
custom({0F21F359-AB84-41E8-9A78-36D110E6D2F9}, &quot;Presenting.CSharp.RequestWebPage&quot;) 

]
interface _RequestWebPage : IDispatch {
[id(00000000), propget]
HRESULT ToString([out, retval] BSTR* pRetVal);
[id(0x60020001)]
HRESULT Equals(
[in] VARIANT obj, 
[out, retval] VARIANT_BOOL* pRetVal);
[id(0x60020002)]
HRESULT GetHashCode([out, retval] long* pRetVal);
[id(0x60020003)]
HRESULT GetType([out, retval] _Type** pRetVal);
[id(0x60020004), propget]
HRESULT URL([out, retval] BSTR* pRetVal);
[id(0x60020004), propput]
HRESULT URL([in] BSTR pRetVal);
[id(0x60020006)]
HRESULT GetContent([out] BSTR* strContent);
};

[
uuid(8B5D2461-07DB-3B5C-A8F9-8539A4B9BE34),
custom({0F21F359-AB84-41E8-9A78-36D110E6D2F9}, &quot;Presenting.CSharp.WhoisLookup&quot;)
]
coclass WhoisLookup {
[default] interface _WhoisLookup;
interface _Object;
};

[
odl,
uuid(07255177-A6E5-3E9F-BAB3-1B3E9833A39E),
hidden,
dual,
nonextensible,
oleautomation,
custom({0F21F359-AB84-41E8-9A78-36D110E6D2F9}, &quot;Presenting.CSharp.WhoisLookup&quot;)

]
interface _WhoisLookup : IDispatch {
[id(00000000), propget]
HRESULT ToString([out, retval] BSTR* pRetVal);
[id(0x60020001)]
HRESULT Equals(
[in] VARIANT obj, 
[out, retval] VARIANT_BOOL* pRetVal);
[id(0x60020002)]
HRESULT GetHashCode([out, retval] long* pRetVal);
[id(0x60020003)]
HRESULT GetType([out, retval] _Type** pRetVal);
};
};
</code></pre></div><p>If you are a C++ programmer, you are used to writing and maintaining such monsters. As a VB programmer, looking at such an IDL file might be a first for you.</p><p>Note that both co-classes have one IDispatch-derived interface, as well as an interface named Object (lines 24 and 62). The IDispatch default interface contains the methods you implemented in your object, plus those from the Object interface. You will also notice that now everything is using the BSTR and VARIANTs that we all know and love.</p><p>Now let’s look at the interfaces in more detail. First, I want to pick the RequestWebPage interface. Figure 10.1 shows it expanded in the OLE View application.</p><p><img src="`+l+'" alt="Figure 10.1"><br> Figure 10.1 The RequestWebPage method exposes its URL property, as well as the <code>GetContent</code> method.</p><p>The <code>URL</code> property is exposed (via <code>get</code> and <code>set</code> methods), as well as the <code>GetContent</code> method. There are also four methods that belong to the Object interface. It looks just like it would in C# directly.</p><p>The <code>WhoisLookup</code> interface is a little bit different. It shows the four Object methods, but where is the <code>Query</code> method? (See Figure 10.2.)</p><p><img src="'+r+'" alt="Figure 10.2"><br> Figure 10.2 Static methods do not show up. This object cannot be used in COM.</p><p>The reason the <code>Query</code> method is not shown is that static methods do not show up in COM. You cannot use this object in COM unless you rewrite <code>Query</code> to an instance method. Therefore, if you plan to use objects outside the CLR, decide wisely which methods are static and which are instance methods.</p><h4 id="invoking-an-net-object" tabindex="-1"><a class="header-anchor" href="#invoking-an-net-object" aria-hidden="true">#</a> Invoking an .NET Object</h4><p>The .NET component and all classes are is registered, and you have a type library for environments that prefer early binding—you are all set. To demonstrate that the component works as expected, I choose Excel as the environment to script it.</p><p>To be able to use early binding in Excel, you must reference the type library. In the VBA Editor, run the References command in the Tools menu. Choose Browse in the References dialog box and then select the type library in the Add Reference dialog box (see Figure 10.3).</p><p><img src="'+u+`" alt="Figure 10.3"><br> Figure 10.3 Importing the type library for the component.</p><p>The only task left is coding the retrieve operation. As you can see from Listing 10.3, it isn’t complicated. Note that I added an On Error GoTo statement to perform the necessary COM error handling.</p><p>Listing 10.3 Using the RequestWebPage Class in an Excel Module</p><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>Option Explicit

Sub GetSomeInfo()
On Error GoTo Err_GetSomeInfo
Dim wrq As New csharp.RequestWebPage
Dim strResult As String

wrq.URL = “http://www.alphasierrapapa.com/iisdev/”
wrq.GetContent strResult
Debug.Print strResult

Exit Sub
Err_GetSomeInfo:
MsgBox Err.Description
Exit Sub
End Sub
</code></pre></div><p>.NET exceptions are translated to <code>HRESULTs</code>, and the exception information is passed via the error information interfaces. Excel then raises an error based on this information.</p><p>When you run the code in Listing 10.3, the output is written to the immediate window. Try entering an invalid URL to see how the exceptions are propagated from the CLR to a COM client.</p><h3 id="_10-1-2-向-net对象展示com对象-exposing-com-objects-to-the-net-object" tabindex="-1"><a class="header-anchor" href="#_10-1-2-向-net对象展示com对象-exposing-com-objects-to-the-net-object" aria-hidden="true">#</a> 10.1.2 向.NET对象展示COM对象(Exposing COM Objects to the .NET Object)</h3><p>Interoperation also works the other way around—.NET clients can interoperate with classic COM objects. Accessing legacy objects is the more likely scenario during the transition period from COM to .NET.</p><p>There are two ways to access COM objects from an .NET client application:</p><ul><li>Invoking early-bound objects</li><li>Invoking late-bound objects</li></ul>`,49),m={href:"http://www.alphasierrapapa.com/iisdev/components/",target:"_blank",rel:"noopener noreferrer"},g=s('<h3 id="invoking-early-bound-objects" tabindex="-1"><a class="header-anchor" href="#invoking-early-bound-objects" aria-hidden="true">#</a> Invoking Early-Bound Objects</h3><p>For a component to be used early-bound in COM, it must have a type library. For the CLR, this ttranslates to the metadata that is stored with the types. But wait—metadata is associated with a type, but what is the .NET type for the COM component?</p><p>To be able to call the COM component from a .NET object, you need a wrapper around the unsafe code. Such a wrapper is called an RCW (Runtime Callable Wrapper), and it is built from the type library information. A tool generates the wrapper code for you, based on the information obtained from the type library.</p><p>The tool to use is <code>tlbimp</code> (type library import). Its command line is simple:</p><p><code>tlbimp asptouch.dll /out:asptouchlib.dll</code></p><p>This command imports the COM type library from <code>asptouch.dll</code> (it is contained in the DLL as a resource), and creates and stores an RCW that can be used in the CLR in the file <code>asptouchlib.dll</code>. You can use <code>ildasm.exe</code> to view the metadata for the RCW (see Figure 10.4). Chapter 11, “Debugging C# Code,” covers the use of <code>ILDasm</code> at greater length.</p><p><img src="'+d+`" alt="Figure 10.4"><br> Figure 10.4 Using ILDasm to view the metadata of <code>asptouchlib.dll</code>.</p><p>When you look at the <code>ILDasm</code> output, you can see that <code>ASPTOUCHlib</code> is the namespace (it was the name of the type library), and TouchIt is the class name of the proxy that was generated for the original COM object. With this information, you can write a .NET object that uses the COM component (see Listing 10.4).</p><p>Listing 10.4 Using a COM Component in C# via an RCW</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">ASPTOUCHLib</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TouchFile</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">TouchIt</span> ti <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TouchIt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">bool</span></span> bResult <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span>
        <span class="token punctuation">{</span>
            bResult <span class="token operator">=</span> ti<span class="token punctuation">.</span><span class="token function">SetToCurrentTime</span><span class="token punctuation">(</span><span class="token string">&quot;asptouch.cs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">finally</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">==</span> bResult<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Successfully changed file time!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>This code looks and feels just like any other C# code that uses a class. There is a using statement, method invocation, and exception handling (this time, the HRESULTs are wrapped as exceptions). Even the compilation command is familiar to you:</p><p><code>csc /r:asptouchlib.dll /out:touch.exe asptouch.cs</code></p><p>It works just like with any other .NET component. After you have created the RCW, working with COM components is a walk in the park.</p><h3 id="invoking-late-bound-objects" tabindex="-1"><a class="header-anchor" href="#invoking-late-bound-objects" aria-hidden="true">#</a> Invoking Late-Bound Objects</h3><p>If you have a component without a type library, or you have to call it on-the-fly without prior generation of an RCW, you aren’t lost at all. A cool feature of the CLR will help you out: reflection. Now you can find out all about a component at runtime.</p><p>Reflection is the way to go when dealing with late-bound objects. The code in Listing 10.5 uses reflection to create the object and to invoke its methods. It performs the same actions as the previous script, but it doesn’t have a wrapper class.</p><p>Listing 10.5 Accessing a COM Component Using Reflection</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Reflection</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TestLateBound</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">Type</span> tTouch<span class="token punctuation">;</span>
        tTouch <span class="token operator">=</span> Type<span class="token punctuation">.</span><span class="token function">GetTypeFromProgID</span><span class="token punctuation">(</span><span class="token string">&quot;AspTouch.TouchIt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Object</span> objTouch<span class="token punctuation">;</span>
        objTouch <span class="token operator">=</span> Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>tTouch<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Object<span class="token punctuation">[</span><span class="token punctuation">]</span></span> parameters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        parameters<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;noway.txt&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">bool</span></span> bResult <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span>
        <span class="token punctuation">{</span>
            bResult <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">)</span>tTouch<span class="token punctuation">.</span><span class="token function">InvokeMember</span><span class="token punctuation">(</span><span class="token string">&quot;SetToCurrentTime&quot;</span><span class="token punctuation">,</span>
            BindingFlags<span class="token punctuation">.</span>InvokeMethod<span class="token punctuation">,</span>
            <span class="token keyword">null</span><span class="token punctuation">,</span> objTouch<span class="token punctuation">,</span> parameters<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>bResult<span class="token punctuation">)</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Changed successfully!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>The class to use for reflection is Type, which is included in the <code>System.Reflection</code> namespace. Line 9 then calls <code>GetTypeFromProgID</code> with the ProgId of the COM component in question to get the component’s type. Although I don’t check for an exception, you should do so; an exception is thrown if the type could not be loaded.</p><p>Now that the type is loaded, I can create an instance of it by using the <code>CreateInstance</code> static method of the Activator class. The <code>TouchIt</code> object is ready to be used. But the really ugly part of late-bound programming has just begun—invoking methods.</p><p>If you loved late-bound programming with C++ and COM, you’ll find yourself at home with this code immediately. All parameters—in this case, the name of the file—must be packaged in an array (lines 14–15), and the call to the method is performed indirectly via the <code>InvokeMember</code> of the Type object (lines 20–22). You have to pass it the name of the method, the binding flags, a binder, the object, and finally, the parameters. The result returned by the invocation must be cast to the appropriate type of C#/CLR.</p><p>Looks and feels ugly, doesn’t it? And the call I use in this example is not even the most complicated one you can come up with. Passing parameters by reference is much more fun, I promise.</p><p>Although the complexity of working with late-bound objects is manageable after all, there is exactly one reason why you always should work with RCWs instead: speed. Late-bound invocation is a magnitude slower than working with early-bound objects.</p><h2 id="_10-2-平台请求服务-platform-invocation-services" tabindex="-1"><a class="header-anchor" href="#_10-2-平台请求服务-platform-invocation-services" aria-hidden="true">#</a> 10.2 平台请求服务(Platform Invocation Services)</h2><p>Even with all the .NET framework classes and COM Interoperability, you sometimes might feel the need to call a single function provided by WIN32 or some other unmanaged DLL. This is the time when you might want to use the Platform Invocation Services (<code>PInvoke</code>). <code>PInvoke</code> takes care of finding and invoking the correct function, as well as marshaling its managed arguments to and from their unmanaged counterparts.</p><p>All you have to do to is use the <code>sysimport</code> attribute when defining an extern method in C#:</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">sysimport</span><span class="token attribute-arguments"><span class="token punctuation">(</span>
dll<span class="token operator">=</span>dllname<span class="token punctuation">,</span>
name<span class="token operator">=</span>entrypoint<span class="token punctuation">,</span>
charset<span class="token operator">=</span><span class="token class-name">character</span> <span class="token keyword">set</span>
<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
</code></pre></div><p>Only the dll argument is mandatory; both other arguments are optional. If you omit the name attribute, the name of the externally implemented function must match the name of the internal static method.</p><p>Listing 10.6 demonstrates how to invoke the message box function of WIN32 using <code>PInvoke</code>.</p><p>Listing 10.6 Using PInvoke to Call WIN32 Functions</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TestPInvoke</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">sysimport</span><span class="token attribute-arguments"><span class="token punctuation">(</span>dll<span class="token operator">=</span><span class="token string">&quot;user32.dll&quot;</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">extern</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">MessageBoxA</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> hWnd<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> strMsg<span class="token punctuation">,</span>
    <span class="token class-name"><span class="token keyword">string</span></span> strCaption<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> nType<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">int</span></span> nMsgBoxResult<span class="token punctuation">;</span>
        nMsgBoxResult <span class="token operator">=</span> <span class="token function">MessageBoxA</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello C#&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;PInvoke&quot;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Line 5 uses the <code>sysimport</code> attribute to specify that the function I am going to call is declared in <code>user32.dll</code>. Because I do not specify a name argument, the following definition for the extern method must exactly match the name of the function I want to call: MessageBoxA, where A is for the ANSI version of this function. The output of this simple application is a message box with a <code>&quot;Hello C#&quot;</code> message.</p><p>Listing 10.7 demonstrates that by using the name argument, you can rename the extern method to your liking.</p><p>Listing 10.7 Modifying the sysimport Attribute Still Yields the Desired Result</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TestPInvoke</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">sysimport</span><span class="token attribute-arguments"><span class="token punctuation">(</span>dll<span class="token operator">=</span><span class="token string">&quot;user32.dll&quot;</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">&quot;MessageBoxA&quot;</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">extern</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">PopupBox</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> h<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> m<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> c<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">int</span></span> nMsgBoxResult<span class="token punctuation">;</span>
        nMsgBoxResult <span class="token operator">=</span> <span class="token function">PopupBox</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello C#&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;PInvoke&quot;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Although I demonstrated only a very straightforward and simple WIN32 method, you can invoke any method that comes to your mind. If you get extremely fancy, you can access WIN32 resource data or implement your own data marshaling. For this, however, you have to take a look into the SDK documentation of the .NET SDK.</p><h2 id="_10-3-不安全代码-unsafe-code" tabindex="-1"><a class="header-anchor" href="#_10-3-不安全代码-unsafe-code" aria-hidden="true">#</a> 10.3 不安全代码(Unsafe Code)</h2><p>Programming unsafe code yourself is definitely not a task you will perform every day when using C#. However, it is good to know that you can use pointers when you have to do so. C# supports you with two keywords for writing unsafe code:</p><ul><li><p><code>unsafe</code>—This keyword denotes an unsafe context. When you want to perform unsafe actions, you must wrap the corresponding code with this modifier. It can be applied to constructors, methods, and properties.</p></li><li><p><code>fixed</code>—Declaring a variable as <code>fixed</code> prevents the garbage collector from relocating it.</p></li></ul><p>Unless you really need to work with raw blocks of memory—with pointers, that is—COM Interoperability and the Platform Invocation Services should cover almost all your needs to talk to COM or WIN32 functions.</p><p>To give you an idea what unsafe code might look like, take a look at Listing 10.8. It shows how to use the <code>unsafe</code> and <code>fixed</code> keywords to create a program that performs the square calculation just a little bit differently. To learn more about writing unsafe code, please take a look at the C# reference.</p><p>Listing 10.8 Working with Unsafe Code</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SquareSampleUnsafe</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsafe</span> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CalcSquare</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> nSideLength<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> pResult<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token operator">*</span>pResult <span class="token operator">=</span> nSideLength <span class="token operator">*</span> nSideLength<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">TestUnsafe</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">int</span></span> nResult <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">unsafe</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">fixed</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> pResult <span class="token operator">=</span> <span class="token operator">&amp;</span>nResult<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token class-name">SquareSampleUnsafe</span> sqsu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SquareSampleUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sqsu<span class="token punctuation">.</span><span class="token function">CalcSquare</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> pResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>nResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_10-4-小结-summary" tabindex="-1"><a class="header-anchor" href="#_10-4-小结-summary" aria-hidden="true">#</a> 10.4 小结(Summary)</h2><p>This chapter was entirely about how managed code can interoperate with unmanaged code. At first, you learned how COM Interoperability can make .NET components work with COM clients, as well as how you can use COM components in .NET clients. You learned about the differences of calling an object with late binding or early binding, and what metadata and type libraries look like for the conversion process.</p><p>A further interoperability service is the Platform Invocation Service PInvoke. It enables you to call WIN32 functions, and it takes care of the data marshaling for you. However, if you want to do it on your own, PInvoke allows you to do so.</p><p>The last feature presented is unsafe code. Although C# prefers managed code, you still can work with pointers, pin blocks of memory to a specific location, and do all the stuff you always wanted to do but that managed C# didn’t allow.</p>`,47);function y(f,b){const e=o("ExternalLinkIcon");return p(),c("div",null,[k,a("p",null,[n("For the examples presented in this section I chose the AspTouch component, which can change the file date of a given file. AspTouch has a dual interface and a type library, and it is free. If you want to follow the examples in this section, you can download AspTouch from "),a("a",m,[n("http://www.alphasierrapapa.com/iisdev/components/"),i(e)]),n(".")]),g])}const C=t(h,[["render",y],["__file","cspcls2_10.html.vue"]]);export{C as default};
