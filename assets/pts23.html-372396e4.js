import{_ as n,o as s,c as a,a as o}from"./app-57d1f7b1.js";const e={},p=o(`<h1 id="在多线程中如何调用winform" tabindex="-1"><a class="header-anchor" href="#在多线程中如何调用winform" aria-hidden="true">#</a> 在多线程中如何调用Winform</h1><h2 id="问题的产生" tabindex="-1"><a class="header-anchor" href="#问题的产生" aria-hidden="true">#</a> 问题的产生</h2><p>我的WinForm程序中有一个用于更新主窗口的工作线程（worker thread），但文档中却提示我不能在多线程中调用这个form（为什么？），而事实上我在调用时程序常常会崩掉。请问如何从多线程中调用form中的方法呢？</p><h2 id="解答" tabindex="-1"><a class="header-anchor" href="#解答" aria-hidden="true">#</a> 解答</h2><p>每一个从Control类中派生出来的WinForm类（包括Control类）都是依靠底层Windows消息和一个消息泵循环（message pump loop）来执行的。消息循环都必须有一个相对应的线程，因为发送到一个window的消息实际上只会被发送到创建该window的线程中去。其结果是，即使提供了同步（synchronization），你也无法从多线程中调用这些处理消息的方法。大多数plumbing是掩藏起来的，因为WinForm是用代理（delegate）将消息绑定到事件处理方法中的。WinForm将Windows消息转换为一个基于代理的事件，但你还是必须注意，由于最初消息循环的缘故，只有创建该form的线程才能调用其事件处理方法。如果你在你自己的线程中调用这些方法，则它们会在该线程中处理事件，而不是在指定的线程中进行处理。你可以从任何线程中调用任何不属于消息处理的方法。</p><p>Control类（及其派生类）实现了一个定义在System.ComponentModel命名空间下的接口 -- ISynchronizeInvoke，并以此来处理多线程中调用消息处理方法的问题：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISynchronizeInvoke</span>
<span class="token punctuation">{</span>
    <span class="token return-type class-name"><span class="token keyword">object</span></span> <span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token class-name">Delegate</span>　method<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token return-type class-name">IAsyncResult</span> <span class="token function">BeginInvoke</span><span class="token punctuation">(</span><span class="token class-name">Delegate</span>　method<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token return-type class-name"><span class="token keyword">object</span></span> <span class="token function">EndInvoke</span><span class="token punctuation">(</span><span class="token class-name">IAsyncResult</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token return-type class-name"><span class="token keyword">bool</span></span> InvokeRequired <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ISynchronizeInvoke提供了一个普通的标准机制用于在其他线程的对象中进行方法调用。例如，如果一个对象实现了ISynchronizeInvoke，那么在线程T1上的客户端可以在该对象中调用ISynchronizeInvoke的Invoke()方法。Invoke()方法的实现会阻塞（block）该线程的调用，它将调用打包发送（marshal）到 T2，并在T2中执行调用，再将返回值发送会T1，然后返回到T1的客户端。Invoke()方法以一个代理来定位该方法在T2中的调用，并以一个普通的对象数组做为其参数。</p><p>调用者还可以检查InvokeRequired属性，因为你既可以在同一线程中调用ISynchronizeInvoke也可以将它重新定位（redirect）到其他线程中去。如果InvokeRequired的返回值是false的话，则调用者可以直接调用该对象的方法。</p><p>比如，假设你想要从另一个线程中调用某个form中的Close方法，那么你可以使用预先定义好的的MethodInvoker代理，并调用Invoke方法:</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name">Form</span> form<span class="token punctuation">;</span>
<span class="token comment">/* obtain a reference to the form, 
then: */</span>
<span class="token class-name">ISynchronizeInvoke</span> synchronizer<span class="token punctuation">;</span>
synchronizer <span class="token operator">=</span> form<span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>synchronizer<span class="token punctuation">.</span>InvokeRequired<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">MethodInvoker</span> invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MethodInvoker</span><span class="token punctuation">(</span>form<span class="token punctuation">.</span>Close<span class="token punctuation">)</span><span class="token punctuation">;</span>
    synchronizer<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
    form<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>ISynchronizeInvoke不仅仅用于WinForm中。例如，一个Calculator类提供了将两个数字相加的Add()方法，它就是通过ISynchronizeInvoke来实现的。用户必须确定ISynchronizeInvoke.Invoke()方法的调用是执行在正确的线程中的。</p><h2 id="c-在正确的线程中写入调用" tabindex="-1"><a class="header-anchor" href="#c-在正确的线程中写入调用" aria-hidden="true">#</a> C# 在正确的线程中写入调用</h2><p>列表A. Calculator类的Add()方法用于将两个数字相加。如果用户直接调用Add()方法，它会在该用户的线程中执行调用，而用户可以通过 ISynchronizeInvoke.Invoke()将调用写入正确的线程中。</p><p>列表A:</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Calculator</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ISynchronizeInvoke</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> arg1<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> arg2<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">int</span></span> threadID <span class="token operator">=</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span><span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Trace<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Calculator thread ID is &quot;</span> <span class="token operator">+</span> threadID<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> arg1 <span class="token operator">+</span> arg2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//ISynchronizeInvoke implementation</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">object</span></span> <span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token class-name">Delegate</span> method<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token return-type class-name">IAsyncResult</span> <span class="token function">BeginInvoke</span><span class="token punctuation">(</span><span class="token class-name">Delegate</span> method<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">object</span></span> <span class="token function">EndInvoke</span><span class="token punctuation">(</span><span class="token class-name">IAsyncResult</span> result<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> InvokeRequired
                <span class="token punctuation">{</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token comment">//Client-side code</span>
            <span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">AddDelegate</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> arg1<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name"><span class="token keyword">int</span></span> threadID <span class="token operator">=</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span><span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Trace<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Client thread ID is &quot;</span> <span class="token operator">+</span> threadID<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">Calculator</span> calc<span class="token punctuation">;</span>
            <span class="token comment">/* Some code to initialize calc */</span>
            <span class="token class-name">AddDelegate</span> addDelegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AddDelegate</span><span class="token punctuation">(</span>calc<span class="token punctuation">.</span>Add<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">object</span></span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

            <span class="token class-name"><span class="token keyword">int</span></span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>calc<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>addDelegate<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">/* Possible output:
            Calculator thread ID is 29
            Client thread ID is 30 
            */</span>
</code></pre></div><p>或许你并不想进行同步调用，因为它被打包发送到另一个线程中去了。你可以通过<code>BeginInvoke()</code>和<code>EndInvoke()</code>方法来实现它。你可以依照通用的.NET非同步编程模式（asynchronous programming model）来使用这些方法：用<code>BeginInvoke()</code>来发送调用，用<code>EndInvoke()</code>来实现等待或用于在完成时进行提示以及收集返回结果。</p><p>还值得一提的是<code>ISynchronizeInvoke</code>方法并非安全类型。 类型不符会导致在执行时被抛出异常，而不是编译错误。所以在使用<code>ISynchronizeInvoke</code>时要格外注意，因为编辑器无法检查出执行错误。</p><p>实现<code>ISynchronizeInvoke</code>要求你使用一个代理来在后期绑定（late binding）中动态地调用方法。每一种代理类型均提供<code>DynamicInvoke()</code>方法： <code>public object DynamicInvoke(object[] args);</code></p><p>理论上来说，你必须将一个方法代理放到一个需要提供对象运行的真实的线程中去，并使<code>Invoke()</code> 和<code>BeginInvoke()</code>方法中的代理中调用<code>DynamicInvoke()</code>方法。<code>ISynchronizeInvoke</code>的实现是一个非同一般的编程技巧，本文附带的源文件中包含了一个名为<code>Synchronizer</code>的帮助类（helper class）和一个测试程序，这个测试程序是用来论证列表A中的Calculator类是如何用Synchronizer类来实现<code>ISynchronizeInvoke</code>的。<code>Synchronizer</code>是<code>ISynchronizeInvoke</code>的一个普通实现，你可以使用它的派生类或者将其本身作为一个对象来使用，并将<code>ISynchronizeInvoke</code>实现指派给它。</p><p>用来实现Synchronizer的一个重要元素是使用一个名为WorkerThread的嵌套类（nested class）。WorkerThread中有一个工作项目（work item）查询。WorkItem类中包含方法代理和参数。Invoke()和BeginInvoke()用来将一个工作项目实例加入到查询里。WorkerThread新建一个.NET worker线程，它负责监测工作项目的查询任务。查询到项目之后，worker会读取它们，然后调用DynamicInvoke()方法。</p>`,21),t=[p];function c(l,k){return s(),a("div",null,t)}const r=n(e,[["render",c],["__file","pts23.html.vue"]]);export{r as default};
