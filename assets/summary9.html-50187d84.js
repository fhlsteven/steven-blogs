import{_ as s,o as n,c as a,a as t}from"./app-f0851ed3.js";const e={},p=t(`<h1 id="六种快速修理c-bug的方法" tabindex="-1"><a class="header-anchor" href="#六种快速修理c-bug的方法" aria-hidden="true">#</a> 六种快速修理C#Bug的方法</h1><p><strong>运用由来已久的技术更快地得到高质量的代码。</strong> —— by Bill Wagner</p><p>.NET Framework中包含许多工具可以用来更快、更容易地编写正确的程序。但我们得面临这样的情况：出现bugs。不管程序多么简单，程序员都可能出错。根据我的经验，大多数程序的bugs出现在程序员之间的接口：当一个程序员编写的代码被另一个程序员调用时。不知何故，调用者破坏了代码编写时做的假设。是谁的过错呢？这并不要紧，更重要的是你能多快修好它？下面这些技巧将帮你在程序投入使用前更快地发现并解决这些问题。最终，这些技巧会帮你诊断任何的确在使用中出现的问题。</p><h2 id="测试假设条件" tabindex="-1"><a class="header-anchor" href="#测试假设条件" aria-hidden="true">#</a> 测试假设条件</h2><p>测试假设条件是构建正确的程序最重要的一个方法。在你写一个函数时，你应该考虑并确定你对那个函数做了什么样的假设。你应该问自己以下这些问题：</p><ol><li>当这个函数被调用时，这个对象必须是怎样的（对象初试化，某个内在变量值）？</li><li>当这个函数存在时，这个对象将会怎样（仍是#1，但包括该函数的副作用）？</li><li>该函数的任何参数必须是怎样的（允许空值吗，输入值的范围是什么）？</li><li>返回值必须是怎样的？</li></ol><p>一旦你问了自己这四个问题并作出回答后，把答案放到代码中。在C#中，用<code>System.Diagnostics.Debug</code>类的<code>Assert</code>方法来表示：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> ProcessIterations <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> numIters<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Debug<span class="token punctuation">.</span>Assert <span class="token punctuation">(</span>numIters <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token string">&quot;ProcessIterations.&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;Iterations must be more than 0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// More code...</span>
</code></pre></div><p>该代码片段执行了numIters参数必须大于零这样一个假设。如果你用一个无效的参数调用ProcessIterations，该Assert被触发。这时候，程序停止运行并通知用户出现的错误。声明（Assertions）只被编译到Debug 版本中的程序，所以它们不影响生产情况中的性能。</p><p>为什么用这种方法？ 运用这种技巧可以确保很快地发现对你的类的方法未预料地使用。然后，或者调用者修改他的代码，或者要求在你的类的行为（behavior）中修改。</p><h2 id="验证完整性" tabindex="-1"><a class="header-anchor" href="#验证完整性" aria-hidden="true">#</a> 验证完整性</h2><p>一个C# 程序中的大多数函数都是一个对象上的实例方法。对任何对象的有效状态都有暗示的假设。当一个公有的方法被调用时，你应该确保那些暗示的假设经过了测试。C# 的条件编译特征使这一点很容易实现。</p><p>首先，写一个私用的函数来测试对象的完整性。你在这么做时，将该方法标为“Conditional”：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Conditional</span> <span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">&quot;DEBUG&quot;</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
<span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ImOK</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Debug<span class="token punctuation">.</span>Assert <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token string">&quot;Testing Object State&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;this cannot be null&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// More here.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后，在每个公有的方法中，调用ImOK方法：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">ProcessIterations</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> numIters<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ImOK <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Debug<span class="token punctuation">.</span>Assert <span class="token punctuation">(</span>numIters <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;ProcessIterations.&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Iterations must be more than 0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在发布（Release）版本中，编译器自动取消对ImOK 的调用。</p><p>为什么用这种方法？运用该技巧，你可以快速发现任何你的对象状态变得无效的情况。</p><h2 id="运用debug-和trace-输出" tabindex="-1"><a class="header-anchor" href="#运用debug-和trace-输出" aria-hidden="true">#</a> 运用Debug 和Trace 输出</h2><p>打印诊断消息可以帮你确定你的程序是怎么出错的。你需要知道当触发一个Assert时，发生了什么情况；你也通常需要知道在这之前发生了什么。知道这些的最好的方式就是运用你的代码，这样你就可以很容易地看到在出现bug前，调用了什么函数。</p><p>在生成调试输出时，.NET Framework有一些新的功能可以用。System.Diagnostic.Debug类可以让你格式化调试输出，并能很容易地创建不同的类或级别的调试输出。下面是我喜欢用的一些指导方针。</p><p>首先，在你的程序中为每个类建一个TraceSwitch对象：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">TraceSwitch</span> myClassSwitch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TraceSwitch</span><span class="token punctuation">(</span><span class="token string">&quot;MyClassSwitch&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Controls the / debug output of MyClass&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>然后，用<code>WriteIf()</code> 和 <code>WriteLineIf()</code> 方法来记录任何你觉得有助于你跟踪你的程序的信息：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> ProcessIterations <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> numIters<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">WriteLineIf</span><span class="token punctuation">(</span>myClassSwitch<span class="token punctuation">.</span>TraceInfo<span class="token punctuation">,</span> <span class="token string">&quot;Entering ProcessIterations&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;CallTrace&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ImOK <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Debug<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>numIters <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token string">&quot;ProcessIterations.&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Iterations must be more than 0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>我更喜欢用<code>WriteLineIf()</code>，它可以打印出错误消息以及错误种类。第一个参数包含一个用于调试开关的值，可以让你控制打印什么级别的输出。</p><p>System.Diagnostics.Trace 的运用同Debug的用法完全一样。 不同的地方是，Debug只编译到Debug版本中，而Trace语句编译到Debug和Release版本中。因此，运用Trace语句应更谨慎。将Trace语句用到可以在编程实战中帮你发现bugs或捕获使用特征的代码中。</p><p>为什么用这种方法？ 运用这些方法可以让你知道代码执行的顺序。这有助于你确定在程序出错前有何动作（actions）。</p><h2 id="动态地控制输出" tabindex="-1"><a class="header-anchor" href="#动态地控制输出" aria-hidden="true">#</a> 动态地控制输出</h2><p>这些新的.NET Framework类的最大的好处是通过编辑一个配置文件，你可以改变任何跟踪开关（trace switch) 的级别。在应用程序目录中建一个XML文件，该文件的名字与你的程序的名字相同，扩展名为“.config”。例如，如果你的程序是myApp.exe，就建一个myApp.exe.config。你可以用这个文件来设置你的跟踪开关的值。比如下面的文件：</p><div class="language-xml" data-ext="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version=&quot;1.0&quot;?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>system.diagnostics</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>switches</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>add</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>MyClassSwitch<span class="token punctuation">&quot;</span></span>  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>4<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>switches</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>system.diagnostics</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>该文件把MyClassSwitch的值设置为4，符合“Info”的设置。仅通过编辑这个config文件，你就可以改变你的程序中任何开关的级别。</p><p>为什么用这种方法？通过运用多个开关和创建适当的config文件，你可以改变记录输出，集中精力到你关心的那些元素上。</p><h2 id="设置你的listeners" tabindex="-1"><a class="header-anchor" href="#设置你的listeners" aria-hidden="true">#</a> 设置你的Listeners</h2><p>.NET Framework有一个代表接收Debug、Assert和Trace输出的对象的Listeners集合。默认情况下，你的应用程序有一个单一的DefaultTraceListener。这个listener忽略Debug和Trace输出，显示一个Assert消息的对话框。你可以添加项目到这个集合，或从这个集合中删除项目。已为你创建好的两项是TextWriterTraceListener和EventLogTraceListener。TextWriterTraceListener把消息写到一个流（stream）中，EventLogTraceListener把消息写到一个EventLog中。EventLog可以让你把你的程序的调试和跟踪消息写到系统事件日志记录中。</p><p>我喜欢为所有程序建一个调试日志文件：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> Main <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    Debug<span class="token punctuation">.</span>Listeners<span class="token punctuation">.</span>Add <span class="token punctuation">(</span><span class="token return-type class-name">New</span> <span class="token function">TextWriteTraceListener</span><span class="token punctuation">(</span><span class="token string">&quot;MyLog.log&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// etc.</span>
</code></pre></div><p>为什么用这个方法？ 该技巧可以让你控制在哪里用调试和跟踪语句。</p><h2 id="在你发现bugs时-用这些技巧" tabindex="-1"><a class="header-anchor" href="#在你发现bugs时-用这些技巧" aria-hidden="true">#</a> 在你发现Bugs时，用这些技巧</h2><p>坦白地说，在开始写代码时，没有人用所有这些技巧。实际上，当我们努力想发现那些重大bugs的原因时我们通常添加这些语句。在你陷入那种困境时，尝试以下方法：</p><ol><li>当你创建类时，通常为每个类建一个跟踪开关。</li><li>通常为每个类建一个验证函数。</li><li>当你要诊断错误的行为时，添加其它的跟踪和调试语句。确信把这些变化保留在代码中。我发现的最常见的错误之一就是：当程序员想找到bugs时，他们添加许多跟踪和调试语句来发现错误。然后，一旦他们找到了他们查找的错误，他们就把这些语句删掉。</li></ol><p>这些工具会帮你发现并修理bugs，就看你用不用它们了。</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p>Bill Wagner 是 SRT Solutions的创始人和顾问，专门研究.NET 开发。他是The C# Core Language Little Black Book一书的作者。 十多年来，他一直从事软件开发与教学工作。他是 Visual Studio Magazine的专栏作家，并在许多关于改进软件开发习惯的会议上做演讲。他从事的软件程序的范围很广，从儿童游戏到生物信息学研究。联系方式： wwagner@SRTsolutions.com。</p>`,44),o=[p];function c(u,l){return n(),a("div",null,o)}const r=s(e,[["render",c],["__file","summary9.html.vue"]]);export{r as default};
