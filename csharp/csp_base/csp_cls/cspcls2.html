<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.66">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <meta name="theme-color" content="#3eaf7c"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title>.net编程先锋C#系列 | Steven Blogs</title><meta name="description" content="steven blogs ">
    <link rel="preload" href="/steven-blogs/assets/style-16f07109.css" as="style"><link rel="stylesheet" href="/steven-blogs/assets/style-16f07109.css">
    <link rel="modulepreload" href="/steven-blogs/assets/app-8e5157a8.js"><link rel="modulepreload" href="/steven-blogs/assets/cspcls2.html-e73cd152.js"><link rel="modulepreload" href="/steven-blogs/assets/cspcls2.html-e445d3a9.js"><link rel="modulepreload" href="/steven-blogs/assets/cspcls2_1-3a34f0b7.js"><link rel="modulepreload" href="/steven-blogs/assets/cspcls2_3-e8261734.js"><link rel="prefetch" href="/steven-blogs/assets/index.html-36a0654f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/index.html-f67a91c5.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/驴子的故事.html-ea457f1b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/index.html-20031bda.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/using-vue.html-9c513162.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase10.html-0d196eee.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase11.html-8305680c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase12.html-1547a554.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase13.html-4ba1718f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase14.html-4ea38634.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase15.html-47e56532.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase16.html-3d8c9eac.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase17.html-919c456a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase18.html-4a7b0f3c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase19.html-f6c7b426.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase2.html-d69cffe7.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase20.html-04b1fb5b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase21.html-ed879461.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase22.html-a01eac19.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase23.html-d066d033.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase24.html-0392d000.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase25.html-4d3ed568.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase26.html-2ba5354b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase27.html-1aa3e6a1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase28.html-00fcf62b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase29.html-96ddcb81.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase3.html-675b514b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase30.html-bb15f1bb.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase31.html-19206a18.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase32.html-cf977c16.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase33.html-269b01dc.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase34.html-e8c14840.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase35.html-c78e5b39.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase36.html-abe11cea.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase37.html-6e256166.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase38.html-5d5d5767.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase39.html-9d99d5e2.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase40.html-0cc9660b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase41.html-ab73ea5d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase42.html-f17082ba.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase43.html-370a1331.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase44.html-dde36a3a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase5.html-10134b2e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase6.html-4e771ff5.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase7.html-5c47d305.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase8.html-b661cc58.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase9.html-a3788802.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbasesexps.html-e2734f8f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspusepointer.html-df978237.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw1.html-7dd49be2.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw10.html-ddff1969.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw11.html-5400ab2a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw12.html-1d79775c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw2.html-ad826d22.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw3.html-675fb130.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw4.html-35bfd912.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw5.html-f95b5f88.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw6.html-961b0517.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw7.html-f66a25ae.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw8.html-39f3f71d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw9.html-47ac28dc.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/bubble.html-4b2ff25c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/insertion.html-020b1661.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/questions.html-21405257.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/shell.html-7bd360f6.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/slection.html-aab3d080.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/sorters.html-a76ea8fe.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/timelogn.html-4db2d923.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspapi1.html-687e03f1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspapi2.html-03025dd8.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspapi3.html-a0547a09.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspapi4.html-9d96b8cb.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspapi5.html-ec7cc71c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls1.html-f4b60ec1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls10.html-41badc80.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_0.html-b354c429.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_1.html-d1f4306a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_10.html-3fd60f23.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_11.html-53884211.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_12.html-3fce1870.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_2.html-dbbbc5c4.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_3.html-76b6edbe.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_4.html-b47b62b7.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_5.html-251e1fbc.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_6.html-01ae148e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_7.html-3f73225b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_8.html-65381434.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_9.html-e8e101f5.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls3.html-116251c8.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_1.html-32e1fb7e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_10.html-d8adaa50.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_11.html-53a0a79e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_2.html-e73499b4.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_3.html-f411cb61.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_4.html-2f95685c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_5.html-6ac047e5.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_6.html-13475ed6.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_7.html-b97a9057.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_8.html-6ee344a1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_9.html-cef0fc3f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls5.html-eafc2741.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls6.html-85971892.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls7.html-0a3d520d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls8.html-d01a5c54.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls9.html-49c7bcb4.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg1.html-caf41284.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg10.html-b66065ce.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg11.html-9daf6d3a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg12.html-e980f719.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg13.html-739c0536.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg14.html-263c3b75.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg15.html-f6bcd953.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg2.html-15b0e7af.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg3.html-b88eecb0.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg4.html-ac8acf96.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg5.html-155ddb5c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg6.html-c8eb4313.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg7.html-afa10cbc.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg8.html-60dc274a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg9.html-cd9b9d17.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct1.html-13276952.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct12.html-1e29fe40.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct2.html-96d90dd0.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct3.html-f251ab48.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct4.html-cda24b47.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct5.html-608a2be4.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct6.html-b231c3db.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct7.html-b1637a07.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct8.html-5488cf72.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop1.html-87aa19e8.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop10.html-72781d78.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop11.html-eff1c9ae.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop12.html-d71564b8.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop13.html-9905e097.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop14.html-3af84943.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop15.html-2a92a975.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop16.html-a2ff21c4.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop2.html-bf4718df.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop3.html-3769a64f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop4.html-0b77318f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop5.html-5034603c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop6.html-9647e354.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop7.html-03da2d9a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop8.html-d28de4a6.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop9.html-16163b3b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra1.html-4958d2f0.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra2.html-cea25b82.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra3.html-92fecefd.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra4.html-c706c68e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra5.html-f7f76635.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra6.html-822381ee.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra7.html-181a2a67.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme1.html-3121d91d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme2.html-ad598aec.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme3.html-fb08d41c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme4.html-a6d98816.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme5.html-ebd4be43.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme6.html-f3df06bf.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme7.html-0daecb41.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme8.html-0475585a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspwrox1.html-58f1208a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter1.html-c50a4c79.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter10.html-e9f0306c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter11.html-1d9b2149.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter12.html-75ca4b5c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter13.html-a87851e1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter14.html-608429c9.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter15.html-8be45681.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter16.html-d84d20b8.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter17.html-079dea01.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter18.html-f5a0016c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter19.html-6e58c144.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter2.html-4f1be0be.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter3.html-5ae913cb.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter4.html-fdede67b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter5.html-08b07874.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter6.html-027e3994.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter7.html-fbedc962.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter8.html-dea919db.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter9.html-3c1d9207.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu1.html-ed13df97.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu2.html-44679dab.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu3.html-15ebeb30.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu4.html-8d3842b2.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu5.html-06c50db6.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu6.html-10c9011f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu7.html-843a3edb.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu8.html-df461356.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc1.html-ce436c41.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc10.html-8eb2148b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc11.html-4fc5151e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc12.html-fd969a86.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc13.html-3f7bdfd3.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc14.html-994e5b0c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc15.html-f937f6a2.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc16.html-84419a76.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc17.html-021f79ab.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc18.html-f5869b16.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc19.html-9783ba9b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc2.html-3e06d130.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc20.html-9d50c0bf.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc21.html-0335882e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc22.html-813d19f8.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc23.html-514a054c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc24.html-3c666c64.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc25.html-46f3ff9f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc26.html-726e8550.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc27.html-a29071a3.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc3.html-9d733e4c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc4.html-1a4456d1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc5.html-b510bf70.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc6.html-d260877c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc7.html-9e15b072.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc8.html-ad2d2d06.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc9.html-4c8d1048.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/index.html-d071cdd1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/index.html-9bf8a944.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/驴子的故事.html-4a24cd55.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/index.html-b03ca482.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/using-vue.html-16dbd08d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase10.html-9d344b96.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase11.html-26d49ad9.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase12.html-b3c434cf.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase13.html-cf91b811.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase14.html-bd29596d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase15.html-de82b92c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase16.html-1336f3ae.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase17.html-1ea51e28.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase18.html-08f55e1d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase19.html-59ba7f2e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase2.html-ca56790f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase20.html-cf55c47a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase21.html-0024c8e1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase22.html-d69ff20b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase23.html-c5e8dc76.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase24.html-ce36bcdd.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase25.html-639ef2b8.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase26.html-5042b976.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase27.html-60299e68.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase28.html-6ad164cf.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase29.html-9a91345d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase3.html-649a4e1c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase30.html-00d9aa9e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase31.html-efcd23f7.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase32.html-ae55cd10.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase33.html-b08cd13e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase34.html-3469395c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase35.html-a174a8f9.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase36.html-319a8707.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase37.html-c13994da.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase38.html-4c59f693.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase39.html-bf8f9491.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase40.html-c43da0d2.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase41.html-6d7ad66a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase42.html-b7e3fabd.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase43.html-2a00ed8a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase44.html-06dd8378.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase5.html-1a8d6b25.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase6.html-b70dff9a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase7.html-b6765ab6.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase8.html-97ec50cd.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbase9.html-efddad0f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspbasesexps.html-97d29ce0.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspusepointer.html-f0980d4f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw1.html-9aa0fd4f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw10.html-0ef0e0a1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw11.html-7f3d70bb.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw12.html-bfa2b4a2.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw2.html-feef2faa.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw3.html-a939ba2a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw4.html-6f30bf82.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw5.html-1a7beac1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw6.html-44188b24.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw7.html-895657da.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw8.html-155cadfe.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netfw9.html-4e749885.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/bubble.html-bdeb713e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/insertion.html-a75eb99f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/questions.html-6a7f2ccd.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/shell.html-62e93213.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/slection.html-a417ab52.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/sorters.html-083b3674.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/timelogn.html-53976faa.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspapi1.html-2440f780.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspapi2.html-53af192d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspapi3.html-132bcb28.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspapi4.html-a3a38ac5.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspapi5.html-843edc8e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls1.html-38e3f943.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls10.html-6c5b850b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_0.html-28f22e6e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_1.html-9f950655.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_10.html-b952b094.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_11.html-3ae8e96e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_12.html-43a9a749.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_2.html-75d6a791.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_3.html-858a5a85.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_4.html-93da846b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_5.html-bb714337.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_6.html-9fe569dc.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_7.html-ab7bf416.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_8.html-b7df3d10.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls2_9.html-a72859c3.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls3.html-6b839c2f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_1.html-9e3b89a9.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_10.html-2ee1ef19.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_11.html-8176bdec.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_2.html-721e118d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_3.html-ea5b756b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_4.html-bfa52005.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_5.html-92b3b2ad.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_6.html-b4f367e4.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_7.html-9c0654e1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_8.html-2e586769.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls4_9.html-23a17a42.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls5.html-78277b03.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls6.html-156f923d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls7.html-f5757d48.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls8.html-d59c0485.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcls9.html-09470c50.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg1.html-9344172b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg10.html-dcd04d15.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg11.html-14ac0fde.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg12.html-d7a31e33.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg13.html-39279dcc.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg14.html-1745f0ca.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg15.html-7a924b9a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg2.html-4e490cda.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg3.html-821931d9.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg4.html-b65fcc8b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg5.html-f7456c5a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg6.html-4e7b1bd1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg7.html-0ca5d854.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg8.html-7575c84e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspcsg9.html-d0d68249.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct1.html-26df8874.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct12.html-a419b3b9.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct2.html-7026ab6a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct3.html-e54894e7.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct4.html-2a07711d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct5.html-31e9cdbb.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct6.html-f264f3df.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct7.html-8c5a8a40.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspct8.html-1c94cceb.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop1.html-9e795a17.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop10.html-cb185814.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop11.html-6ced70e0.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop12.html-f8bc449f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop13.html-b1cf9ef8.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop14.html-68bc2c28.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop15.html-08e3e3d7.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop16.html-ca4626c3.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop2.html-6bfa1f84.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop3.html-7cde34a2.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop4.html-3d0a0c1b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop5.html-d8aa483b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop6.html-87a51a2b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop7.html-07f4dad9.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop8.html-1bc4580d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspdsop9.html-d2a19011.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra1.html-87d06933.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra2.html-04ea13d0.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra3.html-8586ba01.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra4.html-9dbeff9b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra5.html-791654ea.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra6.html-9ebbc473.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspgra7.html-8e245727.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme1.html-2223fbac.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme2.html-0d4cc7ea.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme3.html-b04e4fe0.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme4.html-4e3a6650.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme5.html-a458ac3a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme6.html-d5d269df.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme7.html-598a0413.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspme8.html-dba15c25.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/cspwrox1.html-bbc7ff79.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter1.html-36ec6fb9.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter10.html-21b85e02.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter11.html-1410308b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter12.html-5b9ac476.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter13.html-27704f65.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter14.html-7ad8f9d3.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter15.html-1d2186b6.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter16.html-2631b813.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter17.html-784db2d3.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter18.html-51e34a80.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter19.html-084939e5.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter2.html-b72a5dff.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter3.html-9db4e171.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter4.html-e4f364fd.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter5.html-dc9491e8.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter6.html-3565d615.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter7.html-7e0b0971.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter8.html-6a9c2bc5.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinter9.html-d600472f.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu1.html-ed086074.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu2.html-1b4a9d13.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu3.html-cce7ad0d.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu4.html-4060a8ec.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu5.html-090e6ff4.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu6.html-1d6c1346.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu7.html-627abc7a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netinterdu8.html-78084fcb.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc1.html-2db63bec.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc10.html-bc75a282.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc11.html-41cbff92.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc12.html-7e68a2be.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc13.html-39a35d1c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc14.html-0f45ec3a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc15.html-6bab6979.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc16.html-92b6876b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc17.html-dda86862.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc18.html-c6df1cd1.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc19.html-d7f92aae.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc2.html-c4be330a.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc20.html-c37a60cb.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc21.html-07a94963.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc22.html-4f8215dc.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc23.html-f01a9cb4.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc24.html-5fa5c87b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc25.html-b4991851.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc26.html-cf997f6b.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc27.html-888c69b7.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc3.html-769119a7.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc4.html-266a47a4.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc5.html-07ef7d14.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc6.html-6784e77c.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc7.html-d1c7105e.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc8.html-4690b494.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/netsoc9.html-eb7c5739.js" as="script"><link rel="prefetch" href="/steven-blogs/assets/404.html-901dfb9b.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/steven-blogs/" class=""><!----><span class="site-name">Steven Blogs</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/steven-blogs/csharp/" class="router-link-active" aria-label="C#"><!--[--><!--]--> C# <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Steven的博客"><span class="title">Steven的博客</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Steven的博客"><span class="title">Steven的博客</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://github.com/fhlsteven" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://www.cnblogs.com/fhlsteven" rel="noopener noreferrer" target="_blank" aria-label="博客园"><!--[--><!--]--> 博客园 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/steven-blogs/csharp/" class="router-link-active" aria-label="C#"><!--[--><!--]--> C# <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Steven的博客"><span class="title">Steven的博客</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Steven的博客"><span class="title">Steven的博客</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://github.com/fhlsteven" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://www.cnblogs.com/fhlsteven" rel="noopener noreferrer" target="_blank" aria-label="博客园"><!--[--><!--]--> 博客园 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/steven-blogs/csharp/" class="router-link-active sidebar-item sidebar-heading collapsible" aria-label="C# 基础"><!--[--><!--]--> C# 基础 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">C# 算法 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_algorithm/sorters" class="sidebar-item" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_algorithm/bubble" class="sidebar-item" aria-label="C#算法(一)冒泡排序"><!--[--><!--]--> C#算法(一)冒泡排序 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_algorithm/slection" class="sidebar-item" aria-label="C#算法(二)选择排序"><!--[--><!--]--> C#算法(二)选择排序 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_algorithm/insertion" class="sidebar-item" aria-label="C#算法(三)插入排序"><!--[--><!--]--> C#算法(三)插入排序 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_algorithm/shell" class="sidebar-item" aria-label="C#算法(四)希尔排序"><!--[--><!--]--> C#算法(四)希尔排序 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_algorithm/timelogn" class="sidebar-item" aria-label="时间复杂度O(log n)"><!--[--><!--]--> 时间复杂度O(log n) <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_algorithm/questions" class="sidebar-item" aria-label="其他信息"><!--[--><!--]--> 其他信息 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">初探C# <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_ct/cspct1" class="sidebar-item" aria-label="C#初探-1"><!--[--><!--]--> C#初探-1 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_ct/cspct2" class="sidebar-item" aria-label="C#初探-2"><!--[--><!--]--> C#初探-2 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_ct/cspct3" class="sidebar-item" aria-label="C#初探-3"><!--[--><!--]--> C#初探-3 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_ct/cspct4" class="sidebar-item" aria-label="C#初探-4"><!--[--><!--]--> C#初探-4 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_ct/cspct5" class="sidebar-item" aria-label="C#初探-5"><!--[--><!--]--> C#初探-5 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_ct/cspct6" class="sidebar-item" aria-label="C#初探-6"><!--[--><!--]--> C#初探-6 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_ct/cspct7" class="sidebar-item" aria-label="C#初探-7"><!--[--><!--]--> C#初探-7 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_ct/cspct8" class="sidebar-item" aria-label="C#初探-8,9,10"><!--[--><!--]--> C#初探-8,9,10 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_ct/cspct12" class="sidebar-item" aria-label="C#初探-12,13,14"><!--[--><!--]--> C#初探-12,13,14 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">数据类型操作 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop1" class="sidebar-item" aria-label="字符串加密"><!--[--><!--]--> 字符串加密 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop2" class="sidebar-item" aria-label="C#.NET 中的类型转换"><!--[--><!--]--> C#.NET 中的类型转换 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop3" class="sidebar-item" aria-label="System.String是不可变的字符串吗?"><!--[--><!--]--> System.String是不可变的字符串吗? <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop4" class="sidebar-item" aria-label="字符串操作技巧"><!--[--><!--]--> 字符串操作技巧 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop5" class="sidebar-item" aria-label="数据类型转换小结"><!--[--><!--]--> 数据类型转换小结 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop6" class="sidebar-item" aria-label="数据类型之间的转换"><!--[--><!--]--> 数据类型之间的转换 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop7" class="sidebar-item" aria-label="判断一个整数是否是对称数"><!--[--><!--]--> 判断一个整数是否是对称数 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop8" class="sidebar-item" aria-label="C#中的日期数据类型的使用"><!--[--><!--]--> C#中的日期数据类型的使用 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop9" class="sidebar-item" aria-label="关于C#中的日期类型"><!--[--><!--]--> 关于C#中的日期类型 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop10" class="sidebar-item" aria-label="日期类型"><!--[--><!--]--> 日期类型 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop11" class="sidebar-item" aria-label="日期类型的转换问题"><!--[--><!--]--> 日期类型的转换问题 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop12" class="sidebar-item" aria-label="DateTime类型的变量怎么累加"><!--[--><!--]--> DateTime类型的变量怎么累加 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop13" class="sidebar-item" aria-label="关于C#的高效随机字符串"><!--[--><!--]--> 关于C#的高效随机字符串 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop14" class="sidebar-item" aria-label="C#中如何取得数据字段长度"><!--[--><!--]--> C#中如何取得数据字段长度 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop15" class="sidebar-item" aria-label="C#中一些字符串操作的常用用法"><!--[--><!--]--> C#中一些字符串操作的常用用法 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_dsop/cspdsop16" class="sidebar-item" aria-label="C#中分割字符串的几种方法"><!--[--><!--]--> C#中分割字符串的几种方法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">基本教程 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls1" class="sidebar-item" aria-label="C#及其特性"><!--[--><!--]--> C#及其特性 <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item collapsible">.net编程先锋C# <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_0" class="sidebar-item" aria-label="前言"><!--[--><!--]--> 前言 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_1" class="sidebar-item" aria-label="第一章 C#简介"><!--[--><!--]--> 第一章 C#简介 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_2" class="sidebar-item" aria-label="第二章 理论基础-公用语言 运行环境"><!--[--><!--]--> 第二章 理论基础-公用语言 运行环境 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_3" class="sidebar-item" aria-label="第三章 第一个C#应用程序"><!--[--><!--]--> 第三章 第一个C#应用程序 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_4" class="sidebar-item" aria-label="第四章 C#类型"><!--[--><!--]--> 第四章 C#类型 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_5" class="sidebar-item" aria-label="第五章 类"><!--[--><!--]--> 第五章 类 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_6" class="sidebar-item" aria-label="第六章 控制语句"><!--[--><!--]--> 第六章 控制语句 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_7" class="sidebar-item" aria-label="第七章 异常处理"><!--[--><!--]--> 第七章 异常处理 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_8" class="sidebar-item" aria-label="第八章 用C#写组件"><!--[--><!--]--> 第八章 用C#写组件 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_9" class="sidebar-item" aria-label="第九章 配置和调度"><!--[--><!--]--> 第九章 配置和调度 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_10" class="sidebar-item" aria-label="第10章 用未操控的代码进行内部操作"><!--[--><!--]--> 第10章 用未操控的代码进行内部操作 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_11" class="sidebar-item" aria-label="第11章 调试C#代码"><!--[--><!--]--> 第11章 调试C#代码 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls2_12" class="sidebar-item" aria-label="第12章 安全性"><!--[--><!--]--> 第12章 安全性 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls3" class="sidebar-item" aria-label="C#进阶教程系列"><!--[--><!--]--> C#进阶教程系列 <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item collapsible">循序渐进学C# <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_1" class="sidebar-item" aria-label="C#教程第01课:简单的欢迎程序"><!--[--><!--]--> C#教程第01课:简单的欢迎程序 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_2" class="sidebar-item" aria-label="C#教程第02课:表达式,类型和变量"><!--[--><!--]--> C#教程第02课:表达式,类型和变量 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_3" class="sidebar-item" aria-label="C#教程第03课:选择控制语句"><!--[--><!--]--> C#教程第03课:选择控制语句 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_4" class="sidebar-item" aria-label="C#教程第04课:循环控制语句"><!--[--><!--]--> C#教程第04课:循环控制语句 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_5" class="sidebar-item" aria-label="C#教程第05课:方法"><!--[--><!--]--> C#教程第05课:方法 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_6" class="sidebar-item" aria-label="C#教程第06课:名称空间"><!--[--><!--]--> C#教程第06课:名称空间 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_7" class="sidebar-item" aria-label="C#教程第07课:类的入门"><!--[--><!--]--> C#教程第07课:类的入门 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_8" class="sidebar-item" aria-label="C#教程第08课:类的继承"><!--[--><!--]--> C#教程第08课:类的继承 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_9" class="sidebar-item" aria-label="C#教程第09课:多态性"><!--[--><!--]--> C#教程第09课:多态性 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_10" class="sidebar-item" aria-label="C#教程第10课:属性"><!--[--><!--]--> C#教程第10课:属性 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls4_11" class="sidebar-item" aria-label="C#教程第11课:索引指示器"><!--[--><!--]--> C#教程第11课:索引指示器 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls5" class="sidebar-item" aria-label="一周学会C#系列"><!--[--><!--]--> 一周学会C#系列 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls6" class="sidebar-item" aria-label="C#中的异常处理"><!--[--><!--]--> C#中的异常处理 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls7" class="sidebar-item" aria-label="C#重点知识详解系列"><!--[--><!--]--> C#重点知识详解系列 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls8" class="sidebar-item" aria-label="讲解C#的Namespace"><!--[--><!--]--> 讲解C#的Namespace <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls9" class="sidebar-item" aria-label="天下第七C#学习笔记"><!--[--><!--]--> 天下第七C#学习笔记 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_cls/cspcls10" class="sidebar-item" aria-label="C#学习笔记二：用实例深入理解装箱、拆箱"><!--[--><!--]--> C#学习笔记二：用实例深入理解装箱、拆箱 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">消息与事件 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_me/cspme1" class="sidebar-item" aria-label="C#事件及响应方法"><!--[--><!--]--> C#事件及响应方法 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_me/cspme2" class="sidebar-item" aria-label="C#的消息处理方法"><!--[--><!--]--> C#的消息处理方法 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_me/cspme3" class="sidebar-item" aria-label="如何用代码给一个控件添加新的事件"><!--[--><!--]--> 如何用代码给一个控件添加新的事件 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_me/cspme4" class="sidebar-item" aria-label="使用delegate类型设计自定义事件"><!--[--><!--]--> 使用delegate类型设计自定义事件 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_me/cspme5" class="sidebar-item" aria-label="浅析Java与C#的事件处理机制"><!--[--><!--]--> 浅析Java与C#的事件处理机制 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_me/cspme6" class="sidebar-item" aria-label="C#中的消息处理"><!--[--><!--]--> C#中的消息处理 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_me/cspme7" class="sidebar-item" aria-label="C#消息队列应用程序"><!--[--><!--]--> C#消息队列应用程序 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_me/cspme8" class="sidebar-item" aria-label="C#事件"><!--[--><!--]--> C#事件 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">语法问题 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_gra/cspgra1" class="sidebar-item" aria-label="用“|”间隔是什么意思"><!--[--><!--]--> 用“|”间隔是什么意思 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_gra/cspgra2" class="sidebar-item" aria-label="C#中一行if语句太长如何折行"><!--[--><!--]--> C#中一行if语句太长如何折行 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_gra/cspgra3" class="sidebar-item" aria-label="C#中Console.WriteLine语句输出格式问题"><!--[--><!--]--> C#中Console.WriteLine语句输出格式问题 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_gra/cspgra4" class="sidebar-item" aria-label="实现Interface的方法不能使用static修饰符"><!--[--><!--]--> 实现Interface的方法不能使用static修饰符 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_gra/cspgra5" class="sidebar-item" aria-label="objA==objB和objA.Equals(objB)是否等价"><!--[--><!--]--> objA==objB和objA.Equals(objB)是否等价 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_gra/cspgra6" class="sidebar-item" aria-label="C#的基本语法介绍"><!--[--><!--]--> C#的基本语法介绍 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_gra/cspgra7" class="sidebar-item" aria-label="C#关于Namespace一点介绍"><!--[--><!--]--> C#关于Namespace一点介绍 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">API <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_api/cspapi1" class="sidebar-item" aria-label="几个比较好用的WindowsAPI在C#中的用法"><!--[--><!--]--> 几个比较好用的WindowsAPI在C#中的用法 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_api/cspapi2" class="sidebar-item" aria-label="C#调用WIndows API函数"><!--[--><!--]--> C#调用WIndows API函数 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_api/cspapi3" class="sidebar-item" aria-label="PC喇叭响和任务栏闪烁"><!--[--><!--]--> PC喇叭响和任务栏闪烁 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_api/cspapi4" class="sidebar-item" aria-label="C#中调用Windows API的要点"><!--[--><!--]--> C#中调用Windows API的要点 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_api/cspapi5" class="sidebar-item" aria-label="C#中操作API"><!--[--><!--]--> C#中操作API <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">编码规范 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg1" class="sidebar-item" aria-label=".NET建议使用的大小写命名原则"><!--[--><!--]--> .NET建议使用的大小写命名原则 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg2" class="sidebar-item" aria-label="VB.net 编码规范(也适用于C#)"><!--[--><!--]--> VB.net 编码规范(也适用于C#) <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg3" class="sidebar-item" aria-label="菜鸟编程十大好习惯"><!--[--><!--]--> 菜鸟编程十大好习惯 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg4" class="sidebar-item" aria-label="C#编码标准--命名约定和风格"><!--[--><!--]--> C#编码标准--命名约定和风格 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg5" class="sidebar-item" aria-label="C#编码规范"><!--[--><!--]--> C#编码规范 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg6" class="sidebar-item" aria-label="C#编码规范和编程好习惯"><!--[--><!--]--> C#编码规范和编程好习惯 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg7" class="sidebar-item" aria-label="什么是高质量的代码"><!--[--><!--]--> 什么是高质量的代码 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg8" class="sidebar-item" aria-label="C#编码规范（修订）"><!--[--><!--]--> C#编码规范（修订） <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg9" class="sidebar-item" aria-label="C#编码规范 整理"><!--[--><!--]--> C#编码规范 整理 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg10" class="sidebar-item" aria-label="C# Coding Style Guide"><!--[--><!--]--> C# Coding Style Guide <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg11" class="sidebar-item" aria-label="C#程序编码规范"><!--[--><!--]--> C#程序编码规范 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg12" class="sidebar-item" aria-label="IDesign C#编程规范"><!--[--><!--]--> IDesign C#编程规范 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg13" class="sidebar-item" aria-label="C#和ASP.net命名规范"><!--[--><!--]--> C#和ASP.net命名规范 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg14" class="sidebar-item" aria-label="应用程序设计/命名及编码规范方案"><!--[--><!--]--> 应用程序设计/命名及编码规范方案 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/csp_csg/cspcsg15" class="sidebar-item" aria-label="编码问题?"><!--[--><!--]--> 编码问题? <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">Wrox的C#高级编程 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/csp_base/csp_wrox/cspwrox1" class="sidebar-item" aria-label="Wrox的C#高级编程部分"><!--[--><!--]--> Wrox的C#高级编程部分 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/steven-blogs/csharp/csp_base/cspusepointer" class="sidebar-item" aria-label="C#中使用指针"><!--[--><!--]--> C#中使用指针 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase2" class="sidebar-item" aria-label="通过事件，在两窗体间传递数据"><!--[--><!--]--> 通过事件，在两窗体间传递数据 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase3" class="sidebar-item" aria-label="概述C#中的索引器"><!--[--><!--]--> 概述C#中的索引器 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase5" class="sidebar-item" aria-label="用C#做简单的信息过滤"><!--[--><!--]--> 用C#做简单的信息过滤 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase6" class="sidebar-item" aria-label="解读C#中的规则表达式"><!--[--><!--]--> 解读C#中的规则表达式 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase7" class="sidebar-item" aria-label="全面剖析C#接口编程之定义接口(1)"><!--[--><!--]--> 全面剖析C#接口编程之定义接口(1) <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase8" class="sidebar-item" aria-label="全面剖析C#接口编程之接口概述"><!--[--><!--]--> 全面剖析C#接口编程之接口概述 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase9" class="sidebar-item" aria-label="由C++转向C#：我们需要注意哪些方面的变化?"><!--[--><!--]--> 由C++转向C#：我们需要注意哪些方面的变化? <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase10" class="sidebar-item" aria-label="C#中的delegate和event"><!--[--><!--]--> C#中的delegate和event <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase11" class="sidebar-item" aria-label="使用C#实现阿拉伯数字到大写中文的转换"><!--[--><!--]--> 使用C#实现阿拉伯数字到大写中文的转换 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase12" class="sidebar-item" aria-label="如何在Windows Form中实现URL Encoding/Decoding"><!--[--><!--]--> 如何在Windows Form中实现URL Encoding/Decoding <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase13" class="sidebar-item" aria-label="C#实现控件数组"><!--[--><!--]--> C#实现控件数组 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase14" class="sidebar-item" aria-label="关于销毁(Dispose)的问题--简单"><!--[--><!--]--> 关于销毁(Dispose)的问题--简单 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase15" class="sidebar-item" aria-label="C#中的委托"><!--[--><!--]--> C#中的委托 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase26" class="sidebar-item" aria-label="C#中的委托样例代码"><!--[--><!--]--> C#中的委托样例代码 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase16" class="sidebar-item" aria-label="从数组中移除元素"><!--[--><!--]--> 从数组中移除元素 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase17" class="sidebar-item" aria-label="C#轻松解决世纪迷题"><!--[--><!--]--> C#轻松解决世纪迷题 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase18" class="sidebar-item" aria-label="C#实例看多态"><!--[--><!--]--> C#实例看多态 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbasesexps" class="sidebar-item" aria-label="C#小经验"><!--[--><!--]--> C#小经验 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase19" class="sidebar-item" aria-label="C#数学运算类"><!--[--><!--]--> C#数学运算类 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase20" class="sidebar-item" aria-label="Console输出彩色字体(源码)"><!--[--><!--]--> Console输出彩色字体(源码) <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase21" class="sidebar-item" aria-label="随机数的使用"><!--[--><!--]--> 随机数的使用 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase22" class="sidebar-item" aria-label="C#中的非安全编程"><!--[--><!--]--> C#中的非安全编程 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase23" class="sidebar-item" aria-label="实现运行时从字符串动态创建对象"><!--[--><!--]--> 实现运行时从字符串动态创建对象 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase24" class="sidebar-item" aria-label="用C#开发程序应用框架"><!--[--><!--]--> 用C#开发程序应用框架 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase25" class="sidebar-item" aria-label="c#中结构与类的区别"><!--[--><!--]--> c#中结构与类的区别 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase27" class="sidebar-item" aria-label="C#编程实践"><!--[--><!--]--> C#编程实践 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase28" class="sidebar-item" aria-label="关于.NET异步调用的初步总结"><!--[--><!--]--> 关于.NET异步调用的初步总结 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase29" class="sidebar-item" aria-label="根据typeName获取Type较为完备的办法"><!--[--><!--]--> 根据typeName获取Type较为完备的办法 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase30" class="sidebar-item" aria-label="如何调用只有私有构造函数的类"><!--[--><!--]--> 如何调用只有私有构造函数的类 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase31" class="sidebar-item" aria-label="关于for和foreach,兼顾效率与安全"><!--[--><!--]--> 关于for和foreach,兼顾效率与安全 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase32" class="sidebar-item" aria-label="看流程图,写代码"><!--[--><!--]--> 看流程图,写代码 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase33" class="sidebar-item" aria-label="关于使用for循环"><!--[--><!--]--> 关于使用for循环 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase34" class="sidebar-item" aria-label="切勿锁定类型对象"><!--[--><!--]--> 切勿锁定类型对象 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase35" class="sidebar-item" aria-label="C#学习笔记:多态,重写"><!--[--><!--]--> C#学习笔记:多态,重写 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase36" class="sidebar-item" aria-label="数组"><!--[--><!--]--> 数组 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase37" class="sidebar-item" aria-label="C#中移位操作符的语法陷阱"><!--[--><!--]--> C#中移位操作符的语法陷阱 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase38" class="sidebar-item" aria-label="浅表副本和深层副本的区别"><!--[--><!--]--> 浅表副本和深层副本的区别 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase39" class="sidebar-item" aria-label="引用类型参数传递测试"><!--[--><!--]--> 引用类型参数传递测试 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase40" class="sidebar-item" aria-label=".NET中的Exception处理(C#)"><!--[--><!--]--> .NET中的Exception处理(C#) <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase41" class="sidebar-item" aria-label="C#锐利体验"><!--[--><!--]--> C#锐利体验 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase42" class="sidebar-item" aria-label="在C#中处理结构内的数组"><!--[--><!--]--> 在C#中处理结构内的数组 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase43" class="sidebar-item" aria-label="C#实现动态灵活调用业务方法的机制"><!--[--><!--]--> C#实现动态灵活调用业务方法的机制 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/csp_base/cspbase44" class="sidebar-item" aria-label="异步调用"><!--[--><!--]--> 异步调用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">NetFramework <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/net_framework/netfw1" class="sidebar-item" aria-label=".NET框架与COM"><!--[--><!--]--> .NET框架与COM <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw2" class="sidebar-item" aria-label=".NET中的垃圾回收"><!--[--><!--]--> .NET中的垃圾回收 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw3" class="sidebar-item" aria-label="Microsoft .NET 框架常见问题"><!--[--><!--]--> Microsoft .NET 框架常见问题 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw4" class="sidebar-item" aria-label=".Net反射技术应用解决对象不同版本方法不同参数的问题"><!--[--><!--]--> .Net反射技术应用解决对象不同版本方法不同参数的问题 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw5" class="sidebar-item" aria-label="在.net开发中几个重要的认识误区"><!--[--><!--]--> 在.net开发中几个重要的认识误区 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw6" class="sidebar-item" aria-label="深入理解.NET内存回收机制"><!--[--><!--]--> 深入理解.NET内存回收机制 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw7" class="sidebar-item" aria-label="托管和非托管资源"><!--[--><!--]--> 托管和非托管资源 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw8" class="sidebar-item" aria-label=".Net边学边讲"><!--[--><!--]--> .Net边学边讲 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw9" class="sidebar-item" aria-label=".net框架下的自动内存管理"><!--[--><!--]--> .net框架下的自动内存管理 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw10" class="sidebar-item" aria-label="NET编译时都做了一些什么"><!--[--><!--]--> NET编译时都做了一些什么 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw11" class="sidebar-item" aria-label="配件(assembly)、受管(managed)、映射(reflection)"><!--[--><!--]--> 配件(assembly)、受管(managed)、映射(reflection) <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_framework/netfw12" class="sidebar-item" aria-label=".Net 是未来的趋势, 为什么?"><!--[--><!--]--> .Net 是未来的趋势, 为什么? <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">网络编程 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">Internet <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">下载/上传文件 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/net_code/net_inter/netinterdu1" class="sidebar-item" aria-label="下载网页数据_zj"><!--[--><!--]--> 下载网页数据_zj <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinterdu2" class="sidebar-item" aria-label="用Visual C#实现文件下载功能"><!--[--><!--]--> 用Visual C#实现文件下载功能 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinterdu3" class="sidebar-item" aria-label="C#上传文件的一个实现"><!--[--><!--]--> C#上传文件的一个实现 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinterdu4" class="sidebar-item" aria-label="利用WebClient类向服务器上载文件"><!--[--><!--]--> 利用WebClient类向服务器上载文件 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinterdu5" class="sidebar-item" aria-label="怎样实现多线程分块下载文件"><!--[--><!--]--> 怎样实现多线程分块下载文件 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinterdu6" class="sidebar-item" aria-label="C#做windows登陆程序,上传文件"><!--[--><!--]--> C#做windows登陆程序,上传文件 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinterdu7" class="sidebar-item" aria-label="用WebClient怎样设置才能上传文件"><!--[--><!--]--> 用WebClient怎样设置才能上传文件 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinterdu8" class="sidebar-item" aria-label="C#实现Web文件的上传"><!--[--><!--]--> C#实现Web文件的上传 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter1" class="sidebar-item" aria-label="自动上网的机器人自动抓数据"><!--[--><!--]--> 自动上网的机器人自动抓数据 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter2" class="sidebar-item" aria-label="用程序来代替IIS打开ASP.NET"><!--[--><!--]--> 用程序来代替IIS打开ASP.NET <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter3" class="sidebar-item" aria-label="使用.NET实现断点续传"><!--[--><!--]--> 使用.NET实现断点续传 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter4" class="sidebar-item" aria-label="用程序实现自动拨号"><!--[--><!--]--> 用程序实现自动拨号 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter5" class="sidebar-item" aria-label="在WinForm 中完整支持在多级目录中保存的ASP.NET"><!--[--><!--]--> 在WinForm 中完整支持在多级目录中保存的ASP.NET <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter6" class="sidebar-item" aria-label="在WinForm程序中嵌入ASP.NET"><!--[--><!--]--> 在WinForm程序中嵌入ASP.NET <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter7" class="sidebar-item" aria-label="发送电子邮件"><!--[--><!--]--> 发送电子邮件 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter8" class="sidebar-item" aria-label="利用POP3收取邮件"><!--[--><!--]--> 利用POP3收取邮件 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter9" class="sidebar-item" aria-label="如何用c#实现IE浏览器菜单的屏蔽"><!--[--><!--]--> 如何用c#实现IE浏览器菜单的屏蔽 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter10" class="sidebar-item" aria-label="怎样主动访问一个页面"><!--[--><!--]--> 怎样主动访问一个页面 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter11" class="sidebar-item" aria-label="如何用winform程序登录网页"><!--[--><!--]--> 如何用winform程序登录网页 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter12" class="sidebar-item" aria-label="Post方式"><!--[--><!--]--> Post方式 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter13" class="sidebar-item" aria-label="因特网上Cookies是如何工作的"><!--[--><!--]--> 因特网上Cookies是如何工作的 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter14" class="sidebar-item" aria-label=".NET环境下几种不同的邮件发送解决方案"><!--[--><!--]--> .NET环境下几种不同的邮件发送解决方案 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter15" class="sidebar-item" aria-label="怎样在程序中设置“internet选项”中的“http代理设置”"><!--[--><!--]--> 怎样在程序中设置“internet选项”中的“http代理设置” <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter16" class="sidebar-item" aria-label="网络程序？"><!--[--><!--]--> 网络程序？ <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter17" class="sidebar-item" aria-label="怎样设置“离线”？"><!--[--><!--]--> 怎样设置“离线”？ <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter18" class="sidebar-item" aria-label="如何在C#程序中通过modem拨号上网,并且随时能够判断是否已联网"><!--[--><!--]--> 如何在C#程序中通过modem拨号上网,并且随时能够判断是否已联网 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_inter/netinter19" class="sidebar-item" aria-label="一个扩充拨号类"><!--[--><!--]--> 一个扩充拨号类 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">Socket <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc1" class="sidebar-item" aria-label="Socket,好像也挺简单,可是,真够烦"><!--[--><!--]--> Socket,好像也挺简单,可是,真够烦 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc2" class="sidebar-item" aria-label="基于TCP协议的发送和接收端"><!--[--><!--]--> 基于TCP协议的发送和接收端 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc3" class="sidebar-item" aria-label="Socket基本编程"><!--[--><!--]--> Socket基本编程 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc4" class="sidebar-item" aria-label="用Visual C#实现局域网点对点通讯"><!--[--><!--]--> 用Visual C#实现局域网点对点通讯 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc5" class="sidebar-item" aria-label="用.net中的socket实现文件传输"><!--[--><!--]--> 用.net中的socket实现文件传输 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc6" class="sidebar-item" aria-label="关于Socket的学习代码"><!--[--><!--]--> 关于Socket的学习代码 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc7" class="sidebar-item" aria-label="异步Socket通信"><!--[--><!--]--> 异步Socket通信 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc8" class="sidebar-item" aria-label="Multi-threaded .NET TCP Server Examples"><!--[--><!--]--> Multi-threaded .NET TCP Server Examples <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc9" class="sidebar-item" aria-label="Socket聊天程序"><!--[--><!--]--> Socket聊天程序 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc10" class="sidebar-item" aria-label="用Socket实现点对点的文件传输"><!--[--><!--]--> 用Socket实现点对点的文件传输 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc11" class="sidebar-item" aria-label="异步Socket通信总结"><!--[--><!--]--> 异步Socket通信总结 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc12" class="sidebar-item" aria-label="Socket文件传输总结"><!--[--><!--]--> Socket文件传输总结 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc13" class="sidebar-item" aria-label="网络socket编程指南"><!--[--><!--]--> 网络socket编程指南 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc14" class="sidebar-item" aria-label="Socket基本编程"><!--[--><!--]--> Socket基本编程 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc15" class="sidebar-item" aria-label="浅析C#中的套接字编程"><!--[--><!--]--> 浅析C#中的套接字编程 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc16" class="sidebar-item" aria-label="使用C#开发一个简单的P2P应用"><!--[--><!--]--> 使用C#开发一个简单的P2P应用 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc17" class="sidebar-item" aria-label="构建轻量消息传递系统"><!--[--><!--]--> 构建轻量消息传递系统 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc18" class="sidebar-item" aria-label="socket编程"><!--[--><!--]--> socket编程 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc19" class="sidebar-item" aria-label="Visual C#.Net 网络程序开发-Socket篇"><!--[--><!--]--> Visual C#.Net 网络程序开发-Socket篇 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc20" class="sidebar-item" aria-label="socket异步处理问题"><!--[--><!--]--> socket异步处理问题 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc21" class="sidebar-item" aria-label="C#写的Socket Server 和Client"><!--[--><!--]--> C#写的Socket Server 和Client <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc22" class="sidebar-item" aria-label="C#的socket收发数据"><!--[--><!--]--> C#的socket收发数据 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc23" class="sidebar-item" aria-label="如何通过Socket传递自定义的对象"><!--[--><!--]--> 如何通过Socket传递自定义的对象 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc24" class="sidebar-item" aria-label="socket与防火墙,网络通信问题"><!--[--><!--]--> socket与防火墙,网络通信问题 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc25" class="sidebar-item" aria-label="关于c#的socket"><!--[--><!--]--> 关于c#的socket <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc26" class="sidebar-item" aria-label="100求使用socket的例子"><!--[--><!--]--> 100求使用socket的例子 <!--[--><!--]--></a><!----></li><li><a href="/steven-blogs/csharp/net_code/net_soc/netsoc27" class="sidebar-item" aria-label="Visual C#托管Socket的实现方法"><!--[--><!--]--> Visual C#托管Socket的实现方法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/steven-blogs/csharp/驴子的故事.md" class="sidebar-item sidebar-heading" aria-label="驴子的故事"><!--[--><!--]--> 驴子的故事 <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="net编程先锋c-系列" tabindex="-1"><a class="header-anchor" href="#net编程先锋c-系列" aria-hidden="true">#</a> .net编程先锋C#系列</h1><ul><li><a href="#csp_1">前言</a></li><li><a href="#csp_2">第一章 C#简介</a></li><li><a href="#csp_3">第二章 理论基础-公用语言 运行环境</a></li><li><a href="#csp_4">第三章 第一个C#应用程序</a></li><li><a href="#csp_5">第四章 C#类型</a></li><li><a href="#csp_6">第五章 类</a></li><li><a href="#csp_7">第六章 控制语句</a></li><li><a href="#csp_8">第七章 异常处理</a></li><li><a href="#csp_9">第八章 用C#写组件</a></li><li><a href="#csp_10">第九章 配置和调度</a></li></ul><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> <a id="csp_1">前言</a></h2><p>相关书籍：<a href="https://www.doc88.com/p-186788607809.html" target="_blank" rel="noopener noreferrer">《presenting c#》<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_0-1-提要" tabindex="-1"><a class="header-anchor" href="#_0-1-提要" aria-hidden="true">#</a> 0.1 提要</h3><p>欢迎阅读《展现 C#》(Presenting C#)。这本书是你提高企业编程语言的一条捷径。这种企业编程语言带有下一代编程语言服务运行时(NGWS Runtime)：C#(发音&quot;C sharp&quot;)。</p><p>NGWS Runtime 是一个不仅管理执行代码、同时也提供使编程更加容易的动态环境。编译器产生受管代码以指向这种受管理执行环境。你获得跨平台语言集成、跨平台语言异常处理、增强安全性、版本控制、安排支持和查错服务。</p><p>支持NGWS Runtime 的主要语言是C#。支持NGWS框架的很多程序是用C#写的，因此，在一些带有NGWS Runtime的编译器中，它的编译器可以被认为是非常经得起测试且是经过优化的。C#语言借鉴了C++，但是具备现代化和新增的类型安全——使C#成为企业解决方案的首选语言。</p><h3 id="_0-2-谁应该读这本书" tabindex="-1"><a class="header-anchor" href="#_0-2-谁应该读这本书" aria-hidden="true">#</a> 0.2 谁应该读这本书</h3><p>如果你对编程很陌生，这本书不适合你。这本书企图让程序员解脱并使用C#，基于他们已经拥有的知识。《展现 C#》的目标瞄准了已经具有如C/C++、VB、Java或其它编程经验的程序员。</p><p>如果你具有C++的背景，转向C#会很容易，但是，如果你精通于其它不同的语言，这本书也会耗掉你的一些日子。如果你有一点COM编程的知识，这本会更有趣，但会COM编程不再是必要的。</p><h3 id="_0-3-这本书如何组织" tabindex="-1"><a class="header-anchor" href="#_0-3-这本书如何组织" aria-hidden="true">#</a> 0.3 这本书如何组织</h3><ul><li><strong>第一章 C#简介</strong>——这一章把你带到C#逛一回，同时回答了有关你应该考虑学习C#的问题。</li><li><strong>第二章 NGWS Runtime 的技术基础</strong>——介绍NGWS Runtime为运行的C#代码所提供的低层架构。</li><li><strong>第三章 第一个C#应用程序</strong>——创建真正第一个C#应用程序(否则它是什么呢?)，它就是一个&quot;Hello World&quot;应用程序。</li><li><strong>第四章 C#类型</strong>——可以看到用在C#应用程序中的各种类型。探索值型和引用型的区别，还有如何加框和消框。</li><li><strong>第五章 类</strong>——C#功能真正强大的标志，它是具有类的面向对象的编程。你会学到好多好多的东西，如构造函数、析构函数、方法、属性、索引和事件等。</li><li><strong>第六章 控制语句</strong>——对应用程序实行流程控制。探索C#提供的各种选择和陈述语句。</li><li><strong>第七章 异常处理</strong>——获得了编写实现异常处理的应用程序技巧，拥有这种技巧，在NGWS Runtime世界，你是一个好的公民</li><li><strong>第八章 用C#写组件</strong>——用C#构建组件，因为支持NGWS Runtime，它可以被不同语言平台的客户使用。</li><li><strong>第九章 配置和安排</strong>——学到如何用C#有条件地进行编译工作，和如何为你的C#源码自动地创建文档。另外，这一章将介绍到NGWS的版本技术问题。</li><li><strong>第十章 用非受管代码交互操作</strong>——发现你如何使用C#内部的非受管代码，且非受管代码如何与你的C#组件一起交互操作。</li><li><strong>第十一章 C#代码查错</strong>——获得使用SDK查错工具的技巧，可以在应用程序中准确地找到错误并修改它们。</li><li><strong>第十二章 安全</strong>——探索NGWS Runtime的安全概念。学到代码访问安全性和基于角色的安全性。</li></ul><h3 id="_0-4-使用这本书你需要什么" tabindex="-1"><a class="header-anchor" href="#_0-4-使用这本书你需要什么" aria-hidden="true">#</a> 0.4 使用这本书你需要什么?</h3><p>从这本书的观点看，你所需要的就是下一代windows服务软件开发包(NGWS SDK)。尽管至少只要有NGWS Runtime 和C#编译器就可以，但当探索这些激动人心的新技术功能 时，在一台机器上装有说明文件档和所有的SDK工具(包括debugger)，将是一个极好的主意。</p><p>这本书不需要你装在机器上的Visual Studio 7的任何工具。我仅建议你要有一个优秀的支持行数的程序编辑器，用以编辑C#源文件。</p><p>……</p><p>(省略掉一些有关出版过程和表示感谢的段落)</p><h3 id="_0-5-关于作者" tabindex="-1"><a class="header-anchor" href="#_0-5-关于作者" aria-hidden="true">#</a> 0.5 关于作者</h3><p>Christoph Wille，微软系统工程师(MCSE)、微软系统开发师(MCSD)、Netware网络管理员(CNA)和MCP-IT，作为一个网络咨询人员和程序员，特别精通Windows DNA。微软认为他是ASP方面最有价值的人(MVP)，他是和微软在一起使用早期的C#版本的少数开发者之一。</p><p>Christoph 独自或参与了几本书的写作，包括Sams出版社的《自学ADO2.5 21天》、《自学ASP 24小时》、《自学MCSE TCP/IP 14天》和《MCSE 训练指南：SQL Server 7管理》。</p><h2 id="第一章-c-简介" tabindex="-1"><a class="header-anchor" href="#第一章-c-简介" aria-hidden="true">#</a> <a id="csp_2">第一章 C#简介</a></h2><p>欢迎您加入C#的世界！ 这一章将把您引进C#的天地，并回答一些相关的问题，如：您为什么要使用C#，C++和C#的主要有什么不同点，以及为什么C#使开发更容易而且还使您感到很有趣。</p><p>为什么是另外一种编程语言?</p><p>必须回答的一个问题：当您已经使用C++或VB从事企业开发时，为什么还要学习另一种语言? 市场式的回答就是：&quot;在企业计算领域，C#将会变成为用于编写&quot;下一代窗口服务&quot;(Next Generation Windows Services,简写为NGWS )应用程序的主要语言。&quot; 这一章将对用参数请求提供支持，并陈列了C#的一些功能。这一章会使您开胃的。</p><p>C#语言自C/C++演变而来。但是，它现代、简单、完全面向对象和类型安全。如果您是C/C++程序员，学习曲线将会很平坦。许多C#语句直接借用您所喜爱的语言，包括表达式和操作符。假如不仔细看，简直会把它当成C++。</p><p>关于C#最重要的一点：它是现代的编程语言。它简化和现代化了C++在类、名字空间、方法重载和异常处理等领域。屏弃了C++的复杂性，使它更易用、更少出错。</p><p>对C#的易用有贡献的是减少了C++的一些特性，不再有宏、模板和多重继承。特别对企业开发者来说，上述功能只会产生更多的麻烦而不是效益。</p><p>使编程更方便的新功能是严格的类型安全、版本控制、垃圾收集(garbage collect)等等。所有的这些功能的目标都是瞄准了开发面向组件的软件。</p><p>在继续呈现出更多的功能之前，我想停下来并在下面说明C#至关重要的各种要素。</p><ul><li>简单</li><li>现代</li><li>面向对象</li><li>类型安全</li><li>版本控制</li><li>兼容</li><li>灵活</li></ul><h3 id="简单" tabindex="-1"><a class="header-anchor" href="#简单" aria-hidden="true">#</a> 简单</h3><p>C#具有C++所没有的一 个优势就是学习简单。该语言首要的目标就是简单。很多功能(还不如说是缺少了C++的一些功能)有助于C#全方位的简单。</p><p>在C#中，没有C++中流行的指针。默认地，您工作在受管理的代码中，在那里不允许如直接存取内存等不安全的操作。我想没有C++程序员可以声称，从没有使用指针访问过不属于他们的内存。</p><p>与指针&quot;戏剧性&quot;密切相关的是&quot;愚蠢的&quot;操作。在C++中，有::、.、和-&gt;操作符，它们用于名字空间、成员和引用。对于新手来说，操作符至今仍是学习的一道难关。C#弃用其它操作符，仅使用单个操作符 &quot;.&quot;。现在一个程序员所需要理解的就是嵌套名字的注解了。</p><p>您不必记住基于不同处理器架构的隐含的类型，甚至各种整型的变化范围。C#使用统一的类型系统，屏弃了C++多变的类型系统。这种系统充许您把各种类型作为一个对象查看，它是一个原始类型还是一个full-blown 类。和其它编程语言相比，由于加框(boxing)和消框(unboxing)的机制，把简单类型当作对象处理并不能获得性能的改善。稍后将详细解释加框和消框，但基本上仅当需要时才使用对象访问简单类型这种技术。</p><p>首先，老练的程序员可能不喜欢它，但是整型和布尔型如今终归是两种完全不同的数据类型。这就意味着原来if语句中错误的赋值现在会被编译出错，因为if语句只接受布尔类型的值。再也不会出现误用赋值符为比较符这样的错误！</p><p>C#同时也解决了存在于C++中已经有些年头的多余东西(redundancies)。这种多余包括常数预定义，不同字符类型等。鉴于多余表单已经从该语言中消失，故一般在C#中都可以使用表单了。</p><h3 id="现代" tabindex="-1"><a class="header-anchor" href="#现代" aria-hidden="true">#</a> 现代</h3><p>您投入学习C#的努力是一笔大投资，因为C#是为编写NGWS 应用程序的主要语言而设计。您 将会发现很多自己用C++可以实现或者很费力实现的功能，在C#中不过是一部分基本的功能而已。</p><p>对于企业级的编程语言来说，新增的金融数据类型很受欢迎。您用到了一种新的十进制数据类型，它专用于金融计算方面。如果不喜欢这种现成简单的类型，根据您应用程序的特殊需求，可以很容易地创建出新的一种数据类型。</p><p>我已经提到，指针不再是您编程武器的一部分。不要太惊讶，全面的内存管理已经不是您的任务。运行时NGWS提供了一个垃圾收集器，负责C#程序中的内存管理。因内存和应用程序都受到管理，所以很必要增强类型安全，以确保应用的稳定性。</p><p>对于C++程序员，异常处理的切不是新的东西，但它是C#的主要功能。C#的异常处理与C++的不同点在于它是交叉语言的(运行时的另一个功能)。在没有C#之前，您必须处理怪异的HRESULTs，但现在由于使用了基于异常的健壮的出错处理， 这一切都结束了。</p><p>对于现代的应用程序，安全是首要的，C#也不会例外。它提供了元数据语法，用于声明下述NGWS安全模式的能力和许可。元数据是NGWS运行时的一个关键的概念，下一章将涉及到它更深的含义。</p><h3 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象" aria-hidden="true">#</a> 面向对象</h3><p>您不会预料一种新语言不支持面向对象的功能吧? C#当然支持所有关键的面向对象的概念，如封装、继承和多态性。完整的C#类模式构建在NGWS运行时的虚拟对象系统(VOS，Virtual Object System)的上层，VOS将在下章描述。对象模式只是基础的一部分，不再是编程语言的一部分。</p><p>您一开始必须关注的事，就是不再有全局函数、变量或者是常量。所有的东西都封装在类中，包括事例成员(通过类的事例--对象可以访问)或都静态成员(通过数据类型)。这些使C#代码更加易读且有助于减少潜在的命名冲突。</p><p>定义类中的方法默认是非虚拟的(它们不能被派生类改写)。主要论点是，这样会消除由于偶尔改写方法而导致另外一些原码出错。要改写方法，必须具有显式的虚拟标志。 这种行为不但缩减速了虚拟函数表，而且还确保正确版本的控制。</p><p>使用C++编写类，您可以使用访问权限(access modifiers) 给类成员设置不同的访问等级。C#同样支持private、protected 和public 三种访问权限 ，而且还增加了第四种：internal。有关访问权限 的详细情况将在第五章 &quot;类&quot; 中说明。</p><p>您曾经创建了多少个类是从多基类派生出来的(ATL 程序员，您的投票不计在内！) ? 大多数情况，仅需从一个类派生出。多基类惹出的麻烦通常比它们解决的问题还多。那就是为什么C#仅允许一个基类。如果您觉得需要多重继承，可以运用接口。</p><p>一个可能出现的问题：在C#中不存在指针，如何模仿它? 这个问题的答案很有代表性，它提供了对NGWS运行时事件模式的支持。再次，我将把对它的全面解释放到第五章。</p><h3 id="类型安全" tabindex="-1"><a class="header-anchor" href="#类型安全" aria-hidden="true">#</a> 类型安全</h3><p>我再次选指针作为一个例子。在C++中拥有一个指针，您能自由地把它强制转换成为任何类型，包括干出诸如把一个<code>int*</code>(整型指针)强制转换成一个<code>double *</code>(双精度指针)这样的傻事。只要内存支持这种操作，它就&quot;干过&quot;。这并不是您所想象的企业级编程语言的类型安全。</p><p>纲要性的问题，C#实施最严格的类型安全，以保护自己及垃圾收集器(garbage collector)。所以必须遵守C#中一些相关变量的规则：</p><ul><li>您不能使用没有初始化的变量。对于对象的成员变量，编译器负责清零。而局部变量，则由您负责清零。当您使用一个没有初始化的变量时，编译器会教您怎么做。优点是能够避免由于使用不经初始化的变量计算结果而导致的错误，而您还不知道这些奇怪的结果是如何产生的。</li><li>C#取消了不安全的类型转换。不能把一个整型强制转换成一个引用类型(如对象)，而当向下转换时，C#验证这种转换是正确的。(也就是说，派生类真的是从向下转换的那个类派生出来的。)</li><li>边界检查是C#的一部分。再也不会出现这种情况：当数组实际只定义了n-1个元素，却超额地使用了n个元素。</li><li>算术运算有可能溢出终值数据类型的范围。C#允许在语句级或应用程序级检测这些运算。在允许检测溢出的情况下，当溢出发生时将会抛出一个异常。</li><li>在C#中，被传递的引用参数是类型安全的。</li></ul><h3 id="版本可控-versionable" tabindex="-1"><a class="header-anchor" href="#版本可控-versionable" aria-hidden="true">#</a> 版本可控(Versionable)</h3><p>在过去的几年中，几乎所有的程序员都至少有一次不得不涉及到众所周知的&quot;DLL地狱&quot;。该问题起因于多个应用程序都安装了相同DLL名字的不同版本。有时，老版本的应用程序可以很好地和新版本的DLL一起工作，但是更多的时候它们会中断运行。现在的版本问题真是令人头痛。</p><p>就象您将在第八章&quot;用C#写组件&quot;所看到的，NGWS runtime 将对您所写的应用程序提供版本支持。C#可以最好地支持版本控制。尽管C#不能确保正确的版本控制，但是它可以为程序员保证版本控制成为可能。有这种支持，一个开发人员就可以确保当他的类库升级时，仍保留着对已存在的客户应用程序的二进制兼容。</p><h3 id="兼容" tabindex="-1"><a class="header-anchor" href="#兼容" aria-hidden="true">#</a> 兼容</h3><p>C#并没有存在于一个封闭的世界中。它允许使用最先进的NGWS的通用语言规定(Common Language Specification，简写为CLS)访问不同的API。CLS规定了一个标准，用于符合这种标准的语言的内部之间的操作。为了加强CLS的编译，C#编译器检测所有的公共出口编译，并在通不过时列出错误。</p><p>当然，您也想能够访问旧一点的COM对象。NGWS运行时提供对COM透明的访问。如何集成原来的代码将在第10章&quot;非管理代码的内部操作&quot;有介绍。</p><p>OLE 自动化是一种特殊的动物。任一个使用C++创建OLE自动化项目的人已经喜欢上各种各样的自动化数据类型。有个好消息就是C#支持它们，而没有烦锁的细节。</p><p>最后，C#允许您 用C 原型的API进持内部操作。可以从您的应用程序访问任何DLL中的入口点(有C的原型)。用于访问原始API的功能称作平台调用服务(Plaform Invocation Services ，缩写PInovke)，第10章将展示使用C API进行内部操作的一些例子。</p><h3 id="灵活" tabindex="-1"><a class="header-anchor" href="#灵活" aria-hidden="true">#</a> 灵活</h3><p>上一部分的最后一段有可能提醒了程序员。您可能会问：&quot;难道就没有我要传递指针的API吗?&quot; 您是正确的。不是仅有少数的这种API，而是很多(有点保守的估计)。这种对原始WIN32代码的访问有时导致对非安全类指定指针的使用(尽管它们中的一些由于受COM和PInvoke的支持可以解决)。</p><p>尽管C#代码的缺省状态是类型安全的，但是您可以声明一些类或者仅声明类的的方法是非安全类型的。这样的声明允许您使用指针、结构，静态地分配数组。安全码和非安全码都运行在同一个管理空间，这样暗示着当从安全码调用非安全码时不会陷入列集(marshaling)。</p><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p>C#语言从C和C++演变而来，它是给那些愿意牺牲C++一点底层功能，以获得更方便和更产品化的企业开发人员而创造的。C#现代、简单、面向对象和类型安全。尽管它借鉴了C和C++的许多东西，但是在一些诸如名字空间、类、方法和异常处理等特定领域，它们之间还存在着巨大的差异。</p><p>C#为您提供了方便的功能，如垃圾收集、类型安全、版本控制，等等。仅有的&quot;代价&quot;就是，代码操作默认是类型安全的，不允许指针。光是类型安全就可以搞定了。但是，如果您需要指针，仍可以通过非安全码使用它们，而且当调用非安全码时，不能含有列集。</p><h2 id="第二章-理论基础-公用语言-运行环境" tabindex="-1"><a class="header-anchor" href="#第二章-理论基础-公用语言-运行环境" aria-hidden="true">#</a> <a id="csp_3">第二章 理论基础-公用语言 运行环境</a></h2><p>既然你已经具有了C#全面的印象，我也想让你了解NGWS runtime的全貌。C#依靠由NGWS提供的运行时；因此，有必要知道运行时如何工作，以及它背后所蕴含的概念。</p><p>所以，这一章分为两部分——它们是所有的概念和使用的基础。两部分的内容虽然有些重叠，但它有助于加深理解正在学习的概念。</p><h3 id="_2-1-ngws-runtime" tabindex="-1"><a class="header-anchor" href="#_2-1-ngws-runtime" aria-hidden="true">#</a> 2.1 NGWS Runtime</h3><p>NGWS和NGWS Runtime为你提供了一种运行时环境。该运行时管理执行代码，并提供了使编程更容易的服务。只要你的编译器支持这种运行时，你就会从这种受管理的执行环境中得益。</p><p>你猜测C#编译器支持NGWS runtime很正确，但是不仅它支持NGWS runtime，VB和C++也支持。这些为支持运行时所创建的代码称作&quot;受管代码&quot;(managed code)。以下是你的应用程序从NGWS runtime那里所得到的利益：</p><p>交叉语言集成(通过通用语言规范)<br> 自动内存管理(垃圾收集)<br> 交叉语言异常处理(统一展开)<br> 增强安全(包括类型安全)<br> 版本支持(&quot;DLL地狱&quot;终结者)<br> 组件交互简化模式</p><p>因NGWS runtime 要提供了所有的这些好处，编译器必须把元文件和受管代码一起发出。元文件描述代码中的类型，它和你的代码存在一起(与PE类似---PE为可变位执行文件)</p><p>正如你从很多种交叉语言功能所看到的，NGWS runtime主要是关于高度集成交叉多异编程语言(tight integration across multiple different programming languages)。这种支持可达到允许你从一个VB对象派生出一个C#类的程度(我后面会给出要讨论的文章)。</p><p>C#程序员将会喜欢的一个功能是，他们不必担心内存管理—也就是说不必担心臭名昭著的内存泄漏。NGWS runtime提供了内存管理，当对象和变量的生命期结束(不再被引用)时，垃圾收集器释放它们。我真的喜欢这个功能，因为在COM中的内存管理一直是我的一块心病。</p><p>应该鼓励配置一个管理应用程序或者组件。因为管理应用程序含有元数据文件，NGWS runtime可以利用这些信息，以确保你的应用程序具有它所需的各种规定版本。所产生的明显效果为，由于你的代码没有相互之间的依赖，很少可能出现中断。</p><p>这章余下来的将分为两部分，每一部分讨论NGWS runtime的各个方面，直到你的C#应用程序能执行为止。</p><p>1、中间语言(Intermediate Language，缩写IL)和元数据<br> 2、即时编译器(just-in-time compliers,简称JITers)</p><h4 id="_2-1-1-中间语言和元数据" tabindex="-1"><a class="header-anchor" href="#_2-1-1-中间语言和元数据" aria-hidden="true">#</a> 2.1.1 中间语言和元数据</h4><p>由C#编译器生成的受管代码并不是原始代码，但它是中间语言(IL)代码。这种IL代码自身变成了NGWS runtime的受管执行进程的入口。IL代码明显的优势在于它是CPU无关的，这也意味着，你要用目标机器上的一个编译器才能把IL代码转换成原始代码。</p><p>尽管IL代码由编译器产生，但它并不是编译器提供给运行时仅有的东西。编译器同样产生有关你代码的元数据，它告诉运行时有关你代码的更多的东西，例如各种类型的定义、各种类型成员的签名以及其它数据。基本上，元数据是类型库、注册表内容和其它用于COM的信息。尽管如此，元数据还是直接和执行代码合并在一起，并不处在隔离的位置。</p><p>IL和元数据存放于扩展了PE格式的文件中(PE格式用于.exe和.dll文件)。当这样的一个PE文件被装载时，运行时从文件中定位和分离出元数据和IL。</p><p>在进一步说明之前，我想给你已有的IL指令的简短目录。尽管它不是一个完整的清单，也不需要你熟记和理解，但是它列出了你所必需的、C#程序所基于的知识基础。</p><p>算术和逻辑操作符<br> 控制流<br> 直接内存访问<br> 堆栈操作<br> 参数和局部变量<br> 堆栈分配<br> 对象模式<br> 实例类型值<br> 临界区<br> 数组<br> 分型位置<br> 即时编译器(JITters)</p><h4 id="_2-1-2-即时编译器-jitters" tabindex="-1"><a class="header-anchor" href="#_2-1-2-即时编译器-jitters" aria-hidden="true">#</a> 2.1.2 即时编译器(JITters)</h4><p>由C#或其它能产生受管代码的编译器所生成的受管代码就是IL码。虽然IL代码被包装在一个有效的PE文件中，但是你还是不能执行它，除非它被转换成为受管原始代码。这就是NGWS runtime 即时编译器(也称作JITters)大显身手的时候。</p><p>为什么你会对即时编译代码感到厌繁， 为什么不把整个IL PE文件编译成原始代码? 答案是时间——需要把IL代码编译成CPU规格的代码的时间。这种编译将更加有效率，因为一些程序段从来就没有被执行过。例如，在我的字处理器中，邮件合并功能从来就没有被编译。</p><p>从技术上说，全部的处理过程如下：当一个类型被装载时，装载器创建一个存根(stub)，并使它连接每一个类型的方法。当一个方法第一次被调用时，存根把控制交给JIT。JIT把IL编译为原始代码，且把存根指针指向缓冲了的原始代码。接着的调用将执行原始码。在某些位置上(At some point)，所有的IL都被转换成为原始代码，而JITter处于空闲状态。</p><p>正如我在前面提到的，JIT编译器有很多，不止一个。在Windows平台上，NGWS runtime装有3个不同的JIT编译器。</p><ul><li>JIT——这是NGWS runtime默认使用的JIT编译器。它是一个后台(back end)优化的编译器 ，在前台(up front)实行数据流分析，并创建了高度优化的受管原始代码做为输出结果。JIT可以使用不严格的IL指令集编码，但是所需资源将十分可观。主要的限制在于内存足迹(footprint)、结果工作集，以及实行优化所消耗的时间。</li><li>EconoJIT—— 和主JIT相比，EconJIT的目标是把IL高速地转换成受管原始代码。它允许缓冲所产生的原始代码，但是输出码并不象主JIT生成的代码那样优化(代码小)。当内存紧张时，快速代码生成方案的优势将荡然无存。通过永久地抛弃无用的已JIT过的代码，你可以把更大的IL程序装入代码缓冲区。因为JIT编译快，执行速度也仍然很快。</li><li>PreJIT—尽管它是基于主JIT的，但操作起来更象是一个传 统的编译器。你安装了NGWS组件，它才能运行，才可以把IL代码编译成受管原始代码。当然最终的结果为，更快的装载时间和更快的应用程序启动时间(不需要更多的JIT编译)。</li></ul><p>在所列出的JITters中，有两个是运行时的JITters。可是你怎么决定要使用哪一个JIT，它如何使用内存? 有一个称做&quot;JIT编译管理器&quot;的小应用程序(jitman.exe)，它存放于NGWS SDK安装目录下的bin目录中。当执行该程序时，它把一个图标加到系统任务条上，双击该图标打开程序对话框(见图2.1)。</p><p><img src="/steven-blogs/assets/cspcls2_1-5453a9c2.png" alt="图2.1 JIT编译管理器允许你设置各种相关性能的选项"><br> 图2.1 JIT编译管理器允许你设置各种相关性能的选项</p><p>尽管它是一个小小的对话框，可是你所选择的选项功能是相当强大的。每一个选项将在以下描述。</p><ul><li>Use EconoJIT only 选项——当该复选框没有选上时，NGWS runtime使用默认的正常的JIT编译器。前面就曾经解释过两种JITter的区别。</li><li>Max Code Pitch Overhead(%)选项——该设置仅保留给EconoJIT。它控制了JIT编译时间和执行代码时间的百分比。如果超过了设定的域值，代码缓冲区得到扩充，以缩短JIT编译所消耗的时间。</li><li>Limit Size of Code Cache选项——该项默认为非选。没有选择该项意味着缓冲区将使用它所能得到的内存。如果你想限制缓冲区大小，复选该选项，这将允许你使用Max Size of Cache(bytes)选项。</li><li>Max Size of Cache(bytes)选项—控制容纳JIT代码的缓冲区的最大值。虽然你可以非常严格地限制这个值，但你还是应该小心，不能超过这个缓冲区所适合的最大值。否则该方法的JIT编译将会失败。</li><li>Optimize For Size选项——告诉JIT 编译器，优化的目的是为了使代码更小而不是能执行得更快。这个设置默认是关掉的。</li><li>Enable Concurrent GC[garbage collection]选 项——垃圾收集(GC)默认地运行在用户代码的线程中。意味GC发生时，可能会注意到回应有轻微的延迟。为防止出现该现象，打开当前GC。注意，当前GC比标准GC更慢，它仅在windows 2000上写时(the time of writing)有效。</li></ul><p>当用C#创建项目时，你可能使用不同的设置试验过。当创建 UI-intensive应用程序时，你将会看到允许当前GC的最大差别。</p><h3 id="_2-2-虚拟对象系统-vos" tabindex="-1"><a class="header-anchor" href="#_2-2-虚拟对象系统-vos" aria-hidden="true">#</a> 2.2 虚拟对象系统(VOS)</h3><p>到目前为止，你仅看到了NGWS runtime如何工作，但是并不了解它工作的技术背景以及为什么它要这样工作。这节都是关于 NGWS 虚拟对象系统的(VOS)。</p><p>以下为在VOS中形成声明、使用和管理类型模型时，NGWS runtime的规则。在VOS背后的思想是建立一个框架，在执行代码时不能牺牲性能，允许交叉语言集成和类型安全。</p><p>我提到的框架是运行时架构的基础。为了帮助你更好地了解它，我将它勾出四个区域。当开发C#应用程序和组件时，理解它们很重要。</p><ul><li>VOS类型系统——提供丰富的类型系统，它打算支持全面编程语言的完全实施。</li><li>元数据——描述和引用VOS类型系统所定义的类型。元数据的永久格式与编程语言无关，但是，元数据拿自己当作一种互换机制(nterchange mechanism)来使用，这种互换是在在工具和NGWS的虚拟执行系统之间。</li><li>通用语言规范(CLS)——CLS定义了VOS中类型的子集，也定义了常规的用法。如果一个类库遵守CLS的规则，它确保类库可以在其它所有能实现CLS的编程语言上使用。</li><li>虚拟执行系统(VES)——这是VOS实时的实现。VES负责装入和执行为NGWS运得时编写的程序。</li></ul><p>这四个部分一起组成了NGWS runtime架构。每一部分在下面小节中描述。</p><h4 id="_2-2-1-vos类型系统" tabindex="-1"><a class="header-anchor" href="#_2-2-1-vos类型系统" aria-hidden="true">#</a> 2.2.1 VOS类型系统</h4><p>VOS类型系统提供丰富的类型系统，它打算支持多种编程语言的完全实施。所以，VOS必须都支持面向对象的语言和过程编程语言。</p><p>现在，存在着很多种近似但有点不兼容的类型。就拿整型当例子，在VB中，它是16位长，而在C++中，它是32位。还有更多的例子，特别是用在日期和时间以及数据库方面的数据类型。这种不兼容使应用程序的创建和维护不必要地复杂化，尤其当程序使用了多种编程语言时。</p><p>另一个问题是，因为编程语言之间存在着一些差别，你不能在一种语言中重用另一种语言创建的类型。(COM用二进制标准接口部分地解决了这个问题)。 当今代码重用肯定是有限的。</p><p>发布应用程序的最大障碍是各种编程语言的对象模型不统一。几乎每一方面都存在着差异：事件、属性、永久保存(persistence)等等。</p><p>VOS这里将改变 这种现象 。VOS定义了描述值的类型，并规定了类型的所有值所必须支持的一条合约。由于前面提到的支持面向对象和过程编程语言，就存在着两种值和对象。</p><p>对于值，类型存储于表述(representation)中，同样操作也在其中实行。对象更强大因为它显式地存于表述中。每一个对象都有一个区别于其它对象的识别号。支持不同的VOS类型在<a href="#csp_5">第四章</a> &quot;C#类型&quot;中提出。</p><h4 id="_2-2-2元数据" tabindex="-1"><a class="header-anchor" href="#_2-2-2元数据" aria-hidden="true">#</a> 2.2.2元数据</h4><p>尽管元数据用于描述和引用由VOS类型系统定义的类型，但它还不能锁定到这个单个目标。当你写一个程序时，通过利用类型声明，你所声明的类型(假定它们是数值类型或引用类型)被介绍给NGWS runtime类型系统。类型声明在存于PE可执行文件内部的元数据中得到描述。</p><p>基本上，元数据用于各项任务：用于表示NGWS runtime用途的信息，如定位和装载类、 内存中这些类的事例、解决调用 、翻译IL为原始码、加强安全并设置运行时上下文边界。</p><p>你不必关心元数据的生成。元数据是由C#的&quot;代码转IL编译器&quot;(code-to-IL compiler,不是JIT编译器)生成的。代码转IL编译器发送二进制元数据信息给PE文件，是以标准的方式发送的，不象C++编译器那样，为出口函数创建它们自己的修饰名字。</p><p>你从元数据和可执行代码并存所获得的主要优势为，有关类型的信息同类型自身固定在一起，不会遍布很多地方。同样有助于解决存在于COM中的版本问题。进一步地，你可以在相同的上下文中使用不同的版本库，因为库不仅被注册表引用，也被包含在可执行代码中的元数据引用。</p><h4 id="_2-2-3通用语言规范" tabindex="-1"><a class="header-anchor" href="#_2-2-3通用语言规范" aria-hidden="true">#</a> 2.2.3通用语言规范</h4><p>通用语言规范(CLS)并不是虚拟对象系统(VOS)真正的一部分，它是特殊的。CLS定义了VOS中的一个类型子集，也定义了必须符合CLS的常规用法。</p><p>那么，对此有什么迷惑呢?如果一个类库遵守CLS规则，其它编程语言同样也遵守CLS规则，那么其它编程语言的客户也可以使用类库。CLS是关于语言的交互可操作性(interoperability)。因此，常规用法必须仅遵循外部可访问项目 (externally visible items)如方法、属性和事件等等。</p><p>我所描述的优点是你可以做以下工作。用C#写一个组件，在VB中派生它，因加在VB中的功能是如此之强大，在C#中再次从VB类派生它。只要所有的外部可访问项遵守CLS规则，这样是可行的。</p><p>我在这本书中出示的代码不关心CLS协定。但在构建你的类库时要注意到CLS协定。我提供了表2.1，用以给类型和外部可访问项定义协定规则。</p><p>这个清单不完整。它仅包含一些很重要的项目。我不指出出现在本书中每一种类型的CLS协定，所以有个好主意：当你寻找CLS协定时，至少应该用浏览该表，以了解哪种功能有效。不要担心你不熟悉这章表中的每一个含义，在这本书中你会学到它们。</p><p>表2.1 通能语言规范中的类型和功能</p><p>bool<br> char<br> byte<br> short<br> int<br> long<br> float<br> double<br> string<br> object(所有对象之母)</p><p>Arrays(数组)<br> 数组的维数必须是已知的(&gt;=1)，而且最小下标数必须为0。<br> 要素类型必须是一个CLS类型。</p><p>类型(Types)<br> 可以被抽象或隐藏。<br> 零或更多的接口可以被实现。不同的接口允许拥有具有相同名字和签名的方法。<br> 一个类型可以准确地从一个类型派生。允许成员被覆盖和被隐藏。<br> 可以有零或更多的成员，它们是字段(fields)、方法、事件或者类型。<br> 类型可以拥有零或更多个构造函数。<br> 一种类型的可访问性可以是公共的或者对NGWS组件来说是局部的；但是，仅公共成员可以认为是类型接口的一部分。<br> 所有的值型必须从系统值型继承。异常是一个枚举——它必须从系统枚举(System Enum)继承。</p><p>类型成员<br> 类型成员允许隐藏或者覆盖另一种类型中的其它成员。<br> 参数和返回值的类型都必须是 CLS 协定 类型。<br> 构造函数、方法和属性可以被重载。<br> 一个类型可以有抽象成员，但仅当类型不被封装时。</p><p>方法<br> 一种方法可以是静态、虚拟或者实例。<br> 虚拟和实例方法可以是抽象的，或者是一个实现。静态方法必须总拥有一个实现。<br> 虚拟方法可能是最后的(或者不是)。</p><p>字段(Fields)<br> 可以是静态或者是非静态。<br> 静态字段可以被描述或只初始化。</p><p>属性<br> 当获取和设置方法而不是使用属性语法时，属性可以公开。<br> 获取的返回类型和设置方法的第一个参数必须是相同的CLS类型——属性的类型。<br> 属性名字必须不同，不同的属性类型用于区分是不充分的。<br> 由于使用方法实现属性访问，如果 PropertyName 是同一个类中定义的一个属性，你不能实现命名为 get_PropertyName 和 set_PropertyName 的方法。<br> 属性可以被索引。<br> 属性访问必须遵循这种命名格式：get_ProName，set_PropName。</p><p>枚举(Enumerations)<br> 强调类型必须是byte、short、int 或long。<br> 每一个成员是一个枚举类型的静态描述字段。<br> 一个枚举不能实现任何接口。<br> 你允许给多字段设定相同的值。<br> 一个枚举必须继承系统枚举(隐含在C#中)</p><p>异常<br> 可以被引发和被捕获。<br> 自定义异常必须继承系统异常。</p><p>接口<br> 可需要实现其它接口。<br> 一个接口可以定义属性、事件和虚拟方法。实现取决于派生类。</p><p>事件<br> 增加和取消方法必须是都提供或者都没有 ，每一种方法采用一个参数，它是一个从系统代表元(System Delegate)派生下来的类。</p><p>自定义属性<br> 可以仅使用下更类型：Type(类型),char, char, bool, byte, short, int, long, float, double, enum (一种CLS 类型), and object.</p><p>代表元(Delegates)<br> 可以被创建和被激活</p><p>标识符(Identifiers)<br> 一个标识符的第一个字母必须来自一限制集。<br> 通过大小写在单一范围内，不可能唯一地区别两个或更多个标识符(大小写不敏感)。</p><h4 id="_2-2-4虚拟执行系统-ves" tabindex="-1"><a class="header-anchor" href="#_2-2-4虚拟执行系统-ves" aria-hidden="true">#</a> 2.2.4虚拟执行系统(VES)</h4><p>虚拟执行系统实现了虚拟对象系统。通过实现一个负责NGWS runtime的执行引擎(execution engine，缩写EE)创建VES。这个执行引擎执行你用C#编写和编译的应用程序。</p><p>下列组件为VES的一部分。</p><p>1、中间语言(IL)——被设计为很容易受各种各样的编译器所兼容 。在该框架之外，C++、VB和C#编译器都能够生成IL。<br> 2、装入受管代码——这包括解决内存中的名字、 表层类(laying out classes )，并且创建JIT编译所必需的存根。通过执行经常性校验，包括加强一些访问规则，类装载器同样也增强了安全性。<br> 3、用JIT转换IL成原始代码——IL代码并不是设计成为一种传统的解释字节代码或树型代码，IL转换是真正的编译。<br> 4、装入元数据、校验类型安全和方法的完整性<br> 5、垃圾收集(GC)和异常处理——两者都是基于堆栈格式的服务。受管代码允许你动态地跟踪堆栈。要动态地识别各个堆栈框架，JITter或其它编译器必须提供一个代码管理器。<br> 6、描绘和查错服务——两者都取决于由源语言编译器所生成的信息。必须发出两个映射：一个映射从源语言结构发到指令流中的地址，一个映射从地址发到堆栈框架中的位置。当执行从IL到原始代码的转换时，这些映射被重新计算。<br> 7、管理线程和上下文，还有远程管理——VES为受管代码提供这些服务。</p><p>虽然这个清单并不完整，但它足以让你理解运行时基于的由VES提供的低层架构。肯定将会有专门讨论运行时的书，而这本书将稍为深入地挖掘各种话题。</p><h3 id="_2-3-小结" tabindex="-1"><a class="header-anchor" href="#_2-3-小结" aria-hidden="true">#</a> 2.3 小结</h3><p>这一章，我带你逛了一回运行时的世界。我描述了当创建、编译和配置C#程序时它是如何工作的。你学会了中间语言(IL)，还有元数据是如何用于描述被编译为IL的类型。元数据和IL都用于JITter检测和执行你的代码。你甚至可以选择用哪一种JITter来执行应用程序。</p><p>在这一章的第二部分，涉及到了运行时为何按这种方式工作的理论。你学了虚拟对象系统(VOS)和组成它的那部分。对于类库设计者最为感兴趣的就是通用语言规范(CLS)，它为基于VOS的语言交互操作设定规则。最后，你看到了虚拟执行系统(VES)如何通过NGWS runtime实现VOS。</p><h2 id="第三章-第一个c-应用程序" tabindex="-1"><a class="header-anchor" href="#第三章-第一个c-应用程序" aria-hidden="true">#</a> <a id="csp_4">第三章 第一个C#应用程序</a></h2><h3 id="_3-0-选择一个编辑器" tabindex="-1"><a class="header-anchor" href="#_3-0-选择一个编辑器" aria-hidden="true">#</a> 3.0 选择一个编辑器</h3><p>尽管我是一个顽固的Notepad狂，但这次我不建议用它编辑源码。原因是你正在与真正的编程语言打交道，使用Notepad编辑源码编译时可能产生大量的错误信息行(C++程序员知道我在说什么。) 你有几种选择。可以重新配置你信任的老式Visual C++ 6.0，使它能够和C#源文件一起工作。第二种选择是使用新的Visual Studio 7。第三，你可以用任何第三方程序编辑器，最好要支持行数、色彩编码、工具集成和良好的搜索功能。CodeWright就是其中一个例子，如图3.1所示。</p><p><img src="/steven-blogs/assets/cspcls2_2-b8c46c06.png" alt="图3.1 CodeWright"><br> 图3.1 CodeWright 是你可以用于创建C#代码文件众多可能编辑器中的一个。</p><p>当然，在所提到的编辑器中，没有一个对创建C#程序来说是必要的。用Notepad肯定可以编辑。但是，如果你考虑到要编写更大的项目，最好还是忍痛割爱吧。</p><h3 id="_3-1-hello-world-代码" tabindex="-1"><a class="header-anchor" href="#_3-1-hello-world-代码" aria-hidden="true">#</a> 3.1 &quot;Hello World&quot; 代码</h3><p>讨论编辑器有点离题 ，让我们把话题转回到一个非常出名的小应用程序。这个最短的C#版本应用程序见清单3.1。把它存起来，文件名为 helloworld.cs，以便使你能按照说明，完成诸如编译应用程序等其它余下来的步骤。</p><p>清单 3.1 最简单的 &quot;Hello World &quot;程序</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">class</span> <span class="token class-name">HelloWorld</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre></div><p>在C#中，代码块(语句组)由大括弧(<code>{</code>和<code>}</code>)所括住。所以，甚至你以前没有C++的经验，你也可以说出<code>Main()</code>方法就是<code>HelloWorld</code> 类语句的一部分，因为类被括在所定义的大括弧中。</p><p>C#应用程序(可执行)的入口点就是 <code>static Main</code> 方法，它必须包含在一个类中。仅有一个类能使用该标志定义，除非你告诉编译器它应使用哪一个 Main 方法(否侧，会产生一个编译错误)。</p><p>和C++相比，Main的第一个字母是大写的M，而不是你曾经使用过的小写字母。在这个方法中，你的程序开始并结束。方法中可以调用其它方法——如这个例子中，用于输出文本——或者创建对象并激活该方法。 正如你所看到的，Main方法返回一个void类型。</p><p><code>public static void Main()</code></p><p>尽管看到这些语句时，C++程序员肯定会觉得似曾相识，但是其他程序员并不如此。首先，<code>public</code> 的访问标志告诉我们这个方法可以被任何程序访问，这是它被调用的必要条件。其次，<code>static</code> 意味着没有先创建类的实例也可以调用方法——你所要做的就是用类名调用方法。</p><p><code>HelloWorld.Main();</code></p><p>但是，我不赞成在Main方法中执行这行代码，递归会导致堆栈溢出。</p><p>另一重要的方面是返回类型。对于方法Main，可选择void (意味着根本就没有返回值)，或用int 为整型结果(应用程序返回的错误级别)。因此，两种可能的Main方法为：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>C++程序员会同样知道后面我要提到的——可以传给应用程序的命令行参数数组。如：</p><p><code>public static void Main(string[] args)</code></p><p>我现在并不想详细地说明如何访问参数，但我想事先给C++程序员一个警告：和C++相比，应用程序路径不是这个数组的一部分。仅仅那些参数包含在这个数组中。</p><p>在对Main方法并不简短的介绍之后，让我们把注意力集中到唯一真正的代码行——这行代码在屏幕上显示&quot;Hello Wold&quot;。</p><p><code>System.Console.WriteLine(&quot;Hello World&quot;);</code></p><p>假如不是由于有了System，大家会马上猜到WriteLine是Console 对象的一个静态方法。那么System代表什么呢? 它是包含Console对象的名字空间(范围)，实际上并不是每次都在Console对象前加上名字空间的前缀，你可以象清单3.2所示范的那样，在应用程序中引入名字空间。</p><p>清单3.2 在应用程序中引入名字空间</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">HelloWorld</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre></div><p>所有你要做的就是给System名字空间加一个using指令。在这之后，不再需要规定名字空间，就可以使用它们的方法和属性了。NGWS 框架体系中有很多的名字空间，我只对巨大的名字空间池中的少数几个对象进行探讨。但在第八章 &quot;用C#写组件&quot;将介绍为你的对象创建自己的名字空间。</p><h3 id="_3-2-编译应用程序" tabindex="-1"><a class="header-anchor" href="#_3-2-编译应用程序" aria-hidden="true">#</a> 3.2 编译应用程序</h3><p>由于NGWS Runtime支持所有的编译器(VB、C++和C#)，你不必买一个单独的开发工具用来把应用程序编译成IL(中间语言)。但是，如果你从没有用过命令行编译器编译过应用程序(仅懂得编译名，而没有熟记)， 它还是你的首要选择。</p><p>打开命令提示符并切换到存 helloworld.cs 的目录。敲入以下命令：</p><p><code>csc helloworld.cs</code></p><p>helloworld.cs 被编译并链接成hellworld.exe。因为源码没有错误(那当然！)，C#编译器没有出错提示，在整个编译过程没有丝毫停顿。如图3.2所示。</p><p><img src="/steven-blogs/assets/cspcls2_3-fbafeabf.png" alt="图3.2 "><br> 图3.2 使用命令行编译器 csc.exe 编译应用程序</p><p>现在你已经准备好运行第一个真正用C#编写的应用程序。简单地在命令行上敲入helloworld，输出结果为 &quot;Hello World&quot;。</p><p>在继续往下介绍之前， 我想稍为想象一下第一个应用程序和一个编译器开关的使用：</p><p><code>csc /out:hello.exe helloworld.cs</code></p><p>这个开关告诉编译器输出文件命名为hello.exe。虽然这不是什么绝招，但它是这本书中用到的未来编译器的基本功。</p><h3 id="_3-3-输入和输出" tabindex="-1"><a class="header-anchor" href="#_3-3-输入和输出" aria-hidden="true">#</a> 3.3 输入和输出</h3><p>到目前为止，我仅仅演示了把简单的常量字符串输出到屏幕。尽管这本书只介绍了C#编程的概念而不介绍用户接口编程，但我需要让你迅速学会简单的屏幕输入和输出方法——相应于C的scanf 和 printf，或者C++的cin 和cout。我不能提供VB相应的函数，因为屏幕访问不是该核心语言的一部分。</p><p>你只需要能够读用户的输入并提示一些信息给用户。清单3.3 说明如何读一个用户请求的名字输入，并显示一条已定制好的&quot;Hello&quot; 信息。</p><p>Listing 3.3 从控制台读输入信息</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">InputOutput</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;Please enter your name: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">string</span></span> strName <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Hello &quot;</span> <span class="token operator">+</span> strName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre></div><p>第7行使用Console对象的一个新方法用于提示文本信息给用户，它就是Write方法。它与WriteLine不同的地方在于它输出时不换行。我使用这种方法以便用户可以在信息提示的同一行输入名字。 在用户输入他的名字后(并按回车键)，ReadLine 方法读入了一个字符串变量。名字字符串连接到常量字符串&quot;Hello&quot;，并用我们早已熟悉的WriteLine方法显示出来(见图3.2)。</p><p>图3.3 编译和运行定制的Hello 应用程序</p><p>你几乎已学完了NGWS框架必要的输入和输出功能。但是，你还需要为用户显示多个值。为用户写一个格式串。清单3.4展示一个例子。</p><p>清单 3.4 使用不同的输出方法</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">InputOutput</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;Please enter your name: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">string</span></span> strName <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Hello {0}&quot;</span><span class="token punctuation">,</span>strName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>第9行包含了使用格式串的<code>Console.WriteLine</code>语句。格式串例子如下：</p><p><code>&quot;Hello {0}&quot;</code></p><p><code>{0}</code>代替<code>WriteLine</code>方法的参数表中紧随格式串后的第一个变量。你可以用该技术格式化超过三个变量。</p><p><code>Console.WriteLine(&quot;Hello {0} {1}, from {2}&quot;,strFirstname, strLastname, strCity);</code></p><p>当然，并不仅限于只使用字符串变量。你可以使用任何类型，这些类型在后面的第四章 &quot;C#类型&quot;中有讨论。</p><h3 id="_3-4-添加注释" tabindex="-1"><a class="header-anchor" href="#_3-4-添加注释" aria-hidden="true">#</a> 3.4 添加注释</h3><p>当写代码时，你应为代码写注释条文，解释实现的内容、变更史等。尽管你注释中提供的信息(如果有的话)是给你写的，但是你还是必须遵守写C#注释的方法。清单3.5 显示采用的两种不同的方式。</p><p>清单3.5 给你的代码添加注释</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">HelloWorld</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 这是单行注释</span>
        <span class="token comment">/* 这种注释 
        跨越多行 */</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token comment">/*&quot;Hello World&quot;*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>&quot;//&quot; 符号用于单行注释。你可以用&quot;//&quot;注释当前所在行，或是跟在一个代码语句的后面：</p><p><code>int nMyVar = 10; // 胡说八道</code></p><p>所有在&quot;<code>//</code>&quot;后面的被认为是一条注释；所以，你可以同样用它们来注释一整行或一行源代码的部分。这种注释方式同C++中介绍的相似。</p><p>如果你的注释跨越多行，必须使用&quot;<code>/* */</code>&quot;的字符组合。这种方式在C中有效。除了单行注释外，这种方式在C++和C#中还同样有效。因C/C++和C#都使用这种多行注释方式，所以它们也使用相同的终结符。请看下列代码行：</p><p><code>/* Console.WriteLine(&quot;Hello World&quot;); */</code></p><p>我使用&quot;<code>/* */</code>&quot;简单地注释一整行。现在我假定这一行是很长代码的一部分，而且我决定要暂时禁用一个程序块：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token comment">/*
...
/* Console.WriteLine(&quot;Hello World&quot;); */</span>
<span class="token range operator">..</span><span class="token punctuation">.</span>
<span class="token operator">*</span><span class="token operator">/</span>
</code></pre></div><p>这个结构所存在的问题为： &quot;Hello World&quot;那一行后面的&quot;<code>*/</code>&quot;终止了始于第一行的&quot;<code>/*</code>&quot;的注释，余下的代码对编译器有效，你将看到一些有趣的出错信息。至少 最后的&quot;<code>*/</code>&quot;被标志为归属错误。我只不过想提醒一下，让你了解这种错误。</p><h3 id="_3-5-小结" tabindex="-1"><a class="header-anchor" href="#_3-5-小结" aria-hidden="true">#</a> 3.5 小结</h3><p>在这一章中，你创建、编译并执行了第一个C#应用程序：著名的&quot;Hello World&quot;程序。我用这个短短的应用程序给你介绍有关Main方法，它是一个应用程序的入口点，也是出口点。这个方法可以没有返回值或返回一个整数错误级别。如果你的应用程序用参数调用，你可以(但不必要)读出并使用它们。</p><p>在编译和测试应用程序后，你学到了更多的由Console对象提供的有关输入和输出的方法。对于学习C#而言，它们足以创建出有意义的控制台例子，但用户接口的大部分将是WFC、WinForms或者ASP+。</p><h2 id="第四章-c-类型" tabindex="-1"><a class="header-anchor" href="#第四章-c-类型" aria-hidden="true">#</a> <a id="csp_5">第四章 C#类型</a></h2><p>既然你知道了怎样创建一个简单的C#程序，我将会给你介绍C#的类型系统。在这一章中，你学到如何使用不同的值和引用类型，加框和消框机制能为你作些什么。尽管这一章的不侧重于例子，但你可以学到很多重要的信息，关于如何创建现成类型的程序。</p><h3 id="_4-1-值类型" tabindex="-1"><a class="header-anchor" href="#_4-1-值类型" aria-hidden="true">#</a> 4.1 值类型</h3><p>各种值类型总是含有相应该类型的一个值。C#迫使你初始化变量才能使用它们进行计算-变量没有初始化不会出问题，因为当你企图使用它们时，编译器会告诉你。</p><p>每当把一个值赋给一个值类型时，该值实际上被拷贝了。相比，对于引用类型，仅是引用被拷贝了，而实际的值仍然保留在相同的内存位置，但现在有两个对象指向了它（引用它）。C#的值类型可以归类如下：</p><ul><li>简单类型（Simple types ）</li><li>结构类型（struct types）</li><li>枚举类型（Enumeration types）</li></ul><h4 id="_4-1-1-简单类型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-简单类型" aria-hidden="true">#</a> 4.1.1 简单类型</h4><p>在C#中出现的简单类型共享一些特性。第一，它们都是.NET系统类型的别名。第二，由简单类型组成的常量表达式仅在编译时而不是运行时受检测。最后，简单类型可以按字面被初始化。以下为C#简单类型归类：</p><ul><li>整型</li><li>布尔型</li><li>字符型 (整型的一种特殊情况)</li><li>浮点型</li><li>小数型</li></ul><h5 id="_4-1-1-1-整型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-1-整型" aria-hidden="true">#</a> 4.1.1.1 整型</h5><p>C#中有9个整型。 <code>sbyte</code> 、<code>byte</code>、 <code>short</code>、 <code>ushort</code>、 <code>int</code>、 <code>uint</code>、 <code>long</code>、 <code>ulong</code> 和 <code>char</code>（单独一节讨论）。它们具有以下特性：</p><ul><li><code>sbyte</code>型为有符号8位整数，取值范围在128~127之间。</li><li><code>bytet</code>型为无符号16位整数，取值范围在0~255之间。</li><li><code>short</code>型为有符号16位整数，取值范围在-32,768~32,767之间。</li><li><code>ushort</code>型为无符号16位整数，取值范围在0~65,535之间。</li><li><code>int</code>型为有符号32位整数，取值范围在-2,147,483,648~ 2,147,483,647之间。</li><li><code>uint</code>型为无符号32位整数，取值范围在 0 ~ 4,294,967,295之间。</li><li><code>long</code>型为64位有符号整数，取值范围在9,223,372,036,854,775,808~ 9,223,372,036,854,775,807之间。</li><li><code>ulong</code>型为64位无符号整数，取值范围在0 ~ 18,446,744,073,709,551,615之间。</li></ul><p>VB和C程序员都可能会对<code>int</code>和<code>long</code>数据类型所代表的新范围感到惊讶。和其它的编程语言相比，在C#中，<code>int</code>不再取决于一个机器的字<code>（word)</code>的大小，而long被设成64位。</p><h5 id="_4-1-1-2-布尔型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-2-布尔型" aria-hidden="true">#</a> 4.1.1.2 布尔型</h5><p>布尔数据类型有<code>true</code>和<code>false</code>两个布尔值。可以赋于<code>true</code>或<code>false</code>值给一个布尔变量，或可以赋于一个表达式，其所求出的值等于两者之一：</p><p><code>bool bTest = (80 &gt; 90);</code></p><p>与C和C++相比，在C#中，<code>true</code>值不再为任何非零值。不要为了增加方便而把其它整型转换成布尔型。</p><h5 id="_4-1-1-3-字符型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-3-字符型" aria-hidden="true">#</a> 4.1.1.3 字符型</h5><p>字符型为一个单Unicode 字符。一个Unicode字符16位长，它可以用来表示世界上多种语言。可以按以下方法给一个字符变量赋值：</p><p><code>char chSomeChar = &#39;A&#39;;</code></p><p>除此之外，可以通过十六进制转义符（前缀\x）或Unicode表示法给变量赋值（前缀\u）：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">char</span></span> chSomeChar <span class="token operator">=</span> <span class="token char">&#39;\x0065&#39;</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">char</span></span> chSomeChar <span class="token operator">=</span> <span class="token char">&#39;\u0065&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>不存在把char转换成其它数据类型的隐式转换。这就意味着，在C#中把一个字符变量当作另外的整数数据类型看待是行不通的——这是C程序员必须改变习惯的另一个方面。但是，可以运用显式转换：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">char</span></span> chSomeChar <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token number">65</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> nSomeInt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token char">&#39;A&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>在C中仍然存在着转义符（字符含义）。要换换脑筋，请看表4.1。</p><p>Table 4.1 转义符（ Escape Sequences）</p><table><thead><tr><th>转义符</th><th>字符名</th></tr></thead><tbody><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\\</code></td><td>反斜杠</td></tr><tr><td><code>\0</code></td><td>空字符</td></tr><tr><td><code>\a</code></td><td>感叹号（Alert ）</td></tr><tr><td><code>\b</code></td><td>退格</td></tr><tr><td><code>\f</code></td><td>换页</td></tr><tr><td><code>\n</code></td><td>新行</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\t</code></td><td>水平 tab</td></tr><tr><td><code>\v</code></td><td>垂直tab</td></tr></tbody></table><h5 id="_4-1-1-4-浮点型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-4-浮点型" aria-hidden="true">#</a> 4.1.1.4 浮点型</h5><p>两种数据类型被当作浮点型：<code>float</code>和<code>double</code>。它们的差别在于取值范围和精度：</p><ul><li><code>float</code>: 取值范围在 1.5x10^-45~ 3.4x10^38之间， 精度为7位数。</li><li><code>double</code>: 取值范围在 5.0x10^-324 ~ 1.7x10^308之间， 精度为 15~16 位数。</li></ul><p>当用两种浮点型执行运算时，可以产生以下的值：</p><ul><li>正零和负零</li><li>正无穷和负无穷</li><li>非数字值（Not-a-Number，缩写NaN）</li><li>非零值的有限数集</li></ul><p>另一个运算规则为，当表达式中的一个值是浮点型时，所有其它的类型都要被转换成浮点型才能执行运算。</p><h5 id="_4-1-1-5-小数型-the-decimal-type" tabindex="-1"><a class="header-anchor" href="#_4-1-1-5-小数型-the-decimal-type" aria-hidden="true">#</a> 4.1.1.5 小数型（The decimal Type）</h5><p>小数型是一种高精度、128位数据类型，它打算用于金融和货币的计算。它所表示的范围从大约<code>1.0x10^-28</code> 到 <code>7.9x10^28</code>，具有28至29位有效数字。要注意，精度是以位数 (digits)而不是以小数位（decimal places）表示。运算准确到28个小数位的最大值。</p><p>正如你所看到的，它的取值范围比<code>double</code>的还窄，但它更精确。因此，没有<code>decimal</code>和<code>double</code>之间的隐式转换——往一个方向转换可能会溢出，往另外一个方向可能会丢失精度。你不得不运用显式转换。 当定义一个变量并赋值给它时，使用 m 后缀以表明它是一个小数型：</p><p><code>decimal decMyValue = 1.0m;</code></p><p>如果省略了<code>m</code>，在变量被赋值之前，它将被编译器认作<code>double</code>型。</p><h4 id="_4-1-2-结构类型" tabindex="-1"><a class="header-anchor" href="#_4-1-2-结构类型" aria-hidden="true">#</a> 4.1.2 结构类型</h4><p>一个结构类型可以声明构造函数、常数、字段、方法、属性、索引、操作符和嵌套类型。尽管列出来的功能看起来象一个成熟的类，但在C#中，结构和类的区别在于结构是一个值类型，而类是一个引用类型。与C++相比，这里可以用结构关键字定义一个类。</p><p>使用结构的主要思想是用于创建小型的对象，如Point和FileInfo等等。你可以节省内存，因为没有如类对象所需的那样有额外的引用产生。例如，当声明含有成千上万个对象的数组时，这会引起极大的差异。</p><p>清单4.1 包含一个命名为IP的简单结构，它表示一个使用byte类型的4个字段的IP地址。我不包括方法等，因为这些工作正如使用类一样，将在下一章有详细的描述。</p><p>清单4.1 定义一个简单的结构</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">IP</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">byte</span></span> b1<span class="token punctuation">,</span>b2<span class="token punctuation">,</span>b3<span class="token punctuation">,</span>b4<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">IP</span> myIP<span class="token punctuation">;</span>
        myIP<span class="token punctuation">.</span>b1 <span class="token operator">=</span> <span class="token number">192</span><span class="token punctuation">;</span>
        myIP<span class="token punctuation">.</span>b2 <span class="token operator">=</span> <span class="token number">168</span><span class="token punctuation">;</span>
        myIP<span class="token punctuation">.</span>b3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        myIP<span class="token punctuation">.</span>b4 <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;{0}.{1}.&quot;</span><span class="token punctuation">,</span>myIP<span class="token punctuation">.</span>b1<span class="token punctuation">,</span>myIP<span class="token punctuation">.</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;{0}.{1}&quot;</span><span class="token punctuation">,</span>myIP<span class="token punctuation">.</span>b3<span class="token punctuation">,</span>myIP<span class="token punctuation">.</span>b4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre></div><h4 id="_4-1-3-枚举类型" tabindex="-1"><a class="header-anchor" href="#_4-1-3-枚举类型" aria-hidden="true">#</a> 4.1.3 枚举类型</h4><p>当你想声明一个由一指定常量集合组成的独特类型时，枚举类型正是你要寻觅的。最简单的形式，它看起来可能象这样：</p><p><code>enum MonthNames { January, February, March, April };</code></p><p>因我惯用缺省设置，故枚举元素是<code>int</code>型，且第一个元素为0值。每一个连续的元素按1递增。如果你想给第一个元素直接赋值，可以如下把它设成1：</p><p><code>enum MonthNames { January=1, February, March, April };</code></p><p>如果你想赋任意值给每个元素——甚至相同的值——这也没有问题：</p><p><code>enum MonthNames { January=31, February=28, March=31, April=30 };</code></p><p>最后的选择是不同于<code>int</code>的数据类型。可以在一条语句中按如此赋值：</p><p><code>enum MonthNames : byte { January=31, February=28, March=31, April=30 };</code></p><p>你可以使用的类型仅限于<code>long</code>、<code>int</code>、<code>short</code>和<code>byte</code>。</p><h3 id="_4-2-引用类型" tabindex="-1"><a class="header-anchor" href="#_4-2-引用类型" aria-hidden="true">#</a> 4.2 引用类型</h3><p>和值类型相比，引用类型不存储它们所代表的实际数据，但它们存储实际数据的引用。在C#中提供以下引用类型给你使用：</p><ul><li>对象类型</li><li>类类 型</li><li>接口</li><li>代表元</li><li>字符串类型</li><li>数组</li></ul><h4 id="_4-2-1-对象类型" tabindex="-1"><a class="header-anchor" href="#_4-2-1-对象类型" aria-hidden="true">#</a> 4.2.1 对象类型</h4><p>对象类型是所有类型之母——它是其它类型最根本的基类。因为它是所有对象的基类，所以可把任何类型的值赋给它。例如，一个整型：</p><p><code>object theObj = 123;</code></p><p>给所有的C++程序员一个警告：<code>object</code>并不等价于你可能正在寻找的<code>void*</code>。无论如何，忘掉指针总是个好主意。</p><p>当一个值类型被加框（作为一个对象利用）时，对象类型就被使用了。这一章稍后会讨论到加框和消框</p><h4 id="_4-2-2-类类型" tabindex="-1"><a class="header-anchor" href="#_4-2-2-类类型" aria-hidden="true">#</a> 4.2.2 类类型</h4><p>一个类类型可以包含数据成员、函数成员和嵌套类型。数据成员是常量、字段和事件。函数成员包括方法、属性、索引、操作符、构造函数和析构函数。类和结构的功能是非常相似的，但正如前面所述，结构是值类型而类是引用类型。</p><p>和C++相比，仅允许单继承。（你不能拥有派生一个新对象的多重基类。） 但是，C#中的一个类可以派生自多重接口，该接口在下一节将得到描述。</p><p><a href="#csp_6">第五章</a> “类”专门讨论使用类编程。这一节仅打算给出C#类在哪里适合类型图的一个全貌。</p><h4 id="_4-2-3-接口" tabindex="-1"><a class="header-anchor" href="#_4-2-3-接口" aria-hidden="true">#</a> 4.2.3 接口</h4><p>一个接口声明一个只有抽象成员的引用类型。跟C++中相似的概念为：一个结构的成员，且方法等于0。如果你不知道那些概念的任何东西，这里就是在C#中一个接口实际所做的。仅仅只存在着方法标志，但根本就没有执行代码。这就暗示了不能实例化一个接口，只能实例化一个派生自该接口的对象。</p><p>可以在一个接口中定义方法、属性和索引。所以，对比一个类，接口有什么特殊性呢？当定义一个类时，可以派生自多重接口，而你只能可以从仅有的一个类派生。</p><p>你可能会问：&quot;OK，但我必须实现所有的接口成员，那么我能从这个途径得到什么呢?&quot; 我想举一个来自.NET的例子：很多类实现了<code>IDictionary</code> 接口。你可以使用简单的类型转换访问接口：</p><p><code>IDictionary myDict = (IDictionary)someobjectthatsupportsit;</code></p><p>现在你的代码可以访问字典了。可等等，我说很多类可以实现这个接口——所以，你可以在多个地方重用代码来访问<code>IDictionary</code> 接口！一旦学会，任何地方都可使用。</p><p>当你决定在类设计中使用接口时，学习更多关于面向对象的设计是个好主意。这本书不能教你这些概念，但你可以学习如何创建接口。以下的代码段定义接口<code>IFace</code>，它只有一个方法：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">interface</span> <span class="token class-name">IFace</span>
<span class="token punctuation">{</span>
    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ShowMyFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>正如我所提到的，不能从这个定义实例化一个对象，但可以从它派生一个类。因此，该类必须实现<code>ShowMyFace</code>抽象方法：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">class</span> <span class="token class-name">CFace</span><span class="token punctuation">:</span><span class="token type-list"><span class="token class-name">IFace</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ShowMyFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;implementation&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接口成员和类成员的区别在于，接口成员不能被实现。因此，我不想在下一章中再次提到这一点。</p><h4 id="_4-2-4-代表元-delegates" tabindex="-1"><a class="header-anchor" href="#_4-2-4-代表元-delegates" aria-hidden="true">#</a> 4.2.4 代表元 (Delegates)</h4><p>一个代表元封装了具有一些标志的一个方法。基本上，代表元是类型安全和函数指针的安全版本(回调功能)。可以同时在一个代表元实例中同时封装静态和实例方法。</p><p>尽管你可以用代表员当作具有方法，但它们的主要用途是拥有有一个类事件。再次，我想把你引到下一章，那里会详细地讨论类。</p><h4 id="_4-2-5-字符串类型" tabindex="-1"><a class="header-anchor" href="#_4-2-5-字符串类型" aria-hidden="true">#</a> 4.2.5 字符串类型</h4><p>C程序员可能会诧异，但当然，C#有一个用于操作字符串数据的基本字符串类型。字符串类直接派生自对象，且它是被密封的，这意味着再不能从它派生类。就象其它类型，字符串是预定义类System String的一个别名。</p><p>它的用法十分简单：</p><p><code>string myString = &quot;some text&quot;;</code></p><p>合并字符串同样简单：</p><p><code>string myString = &quot;some text&quot; + &quot; and a bit more&quot;;</code></p><p>而如果你想访问单个字符，所要做的就是访问下标：</p><p><code>char chFirst = myString[0];</code></p><p>当比较两个字符串是否相等时，简单地使用&quot;==&quot;比较操作符。</p><p><code>if (myString == yourString) ...</code></p><p>我只不过想提到，尽管字符串是一个引用类型，比较时是比较值，而不是比较引用(内存地址)。</p><p>字符串类型几乎用于这本书的每一个例子中，而且在这些例程中，我会介绍给你一些由字符串对象所显露的极其有趣的方法。</p><h4 id="_4-2-6-数组" tabindex="-1"><a class="header-anchor" href="#_4-2-6-数组" aria-hidden="true">#</a> 4.2.6 数组</h4><p>一个数组包含有通过计算下标访问的变量。所有包含于数组中且被当作元素的变量必须是同一类型。这种类型自然被称为&quot;数组类型&quot;。数组可以存储整数对象、字符串对象或者 你提出的任何对象。</p><p>数组的维数就是所谓的排(rank)，它决定了相关数组元素的下标数。最常用的数组是一维数组(第一排)。一个多维数组具有的排数大于1 。每个维的下标始于0，终于维的长度减1 。</p><p>应有足够的理论支持。让我们看一下用一个数组初始化器(array initializer)初始化的数组：</p><p><code>string[] arrLanguages = { &quot;C&quot;, &quot;C++&quot;, &quot;C#&quot; };</code></p><p>该简写效果等同以下：</p><p><code>arrLanguages[0]=&quot;C&quot;; arrLanguages[1]=&quot;C++&quot;; arrLanguages[2]=&quot;C#&quot;;</code></p><p>而编译器为你做了所有的工作。当然，它将同样为多维数组初始化器工作：</p><p><code>int[,] arr = {{0,1}, {2,3}, {4,5}};</code></p><p>它是以下的简写：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre></div><p>如果你不想事先初始化一个数组，但知道了它的大小，该声明就象这样：</p><p><code>int[,] myArr = new int[5,3];</code></p><p>如果数组的大小必须动态地被计算，用于数组创建的语句可以象这样写：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> nVar <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> arrToo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">int</span></span><span class="token punctuation">[</span>nVar<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>正如我在这一节开始所陈述的，你可以往数组里面塞任何东西，只要所有的元素类型都相同。因此，如果你想把任何东西放进一个数组，就声明它的类型为对象：</p><h3 id="_4-3-加框和消框-boxing-and-unboxing" tabindex="-1"><a class="header-anchor" href="#_4-3-加框和消框-boxing-and-unboxing" aria-hidden="true">#</a> 4.3 加框和消框(Boxing and Unboxing)</h3><p>这一章的课程中，我已经给出了各式各样的值类型和引用类型。由于速度的原因，你会使用值类型——它除了占据一定空间的内存块外，就没有什么了。但是，有时对象的方便性就象值类型一样好用。</p><p>这就是加框和消框登上了舞台的地方，加框和消框是C#类型系统的核心概念。通过允许一个值类型转换成类型对象或从类型对象转换成值类型，这种机制形成了值类型和引用类型之间的捆绑连接。任何东西终究是一个对象——但是，仅当需要它们是对象时。</p><h4 id="_4-3-1-加框转换" tabindex="-1"><a class="header-anchor" href="#_4-3-1-加框转换" aria-hidden="true">#</a> 4.3.1 加框转换</h4><p>给一个值加框指隐式地把任何值类型转换成类型对象。当一个值类型被加框时，一个对象实例就被分配，且值类型的值被拷贝给新的对象。</p><p>看以下例子：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> nFunny <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">object</span></span> oFunny <span class="token operator">=</span> nFunny<span class="token punctuation">;</span>
</code></pre></div><p>第二行的赋值暗示调用一个加框操作。<code>nFunny</code>整型变量的值被拷贝给<code>oFunny</code>对象。现在整型变量和对象变量都同时存在于栈中，但对象的值居留在堆中。</p><p>那么，它暗示着什么呢?它们的值互相独立——在它们之间没有连接。(<code>oFunny</code>没有引用<code>nFunny</code>的值。) 以下代码说明了结果：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> nFunny <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">object</span></span> oFunny <span class="token operator">=</span> nFunny<span class="token punctuation">;</span>
oFunny <span class="token operator">=</span> <span class="token number">2001</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;{0} {1}&quot;</span><span class="token punctuation">,</span> nFunny<span class="token punctuation">,</span> oFunny<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当代码改变<code>oFunny</code>的值时，<code>nFunny</code>的值并没有改变。只要你脑袋中有这个copy动作，就能够使用值类型的对象功能，发挥出你的巨大优势！</p><h4 id="_4-3-2-消框转换" tabindex="-1"><a class="header-anchor" href="#_4-3-2-消框转换" aria-hidden="true">#</a> 4.3.2 消框转换</h4><p>和加框相比，消框是显式操作——必须告诉编译器，你想从对象中抽取出哪一种值类型。当执行消框操作时，C#检测所请求的值类型实际上存储在对象实例中。经过成功的校验，该值被消框。</p><p>这就是消框如何执行：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> nFunny <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">object</span></span> oFunny <span class="token operator">=</span> nFunny<span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> nNotSoFunny <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>oFunny<span class="token punctuation">;</span>
</code></pre></div><p>如果错误地请求一个<code>double</code>值</p><p><code>double nNotSoFunny = (double)oFunny;</code></p><p>通用语言运行时(Common Language Runtime，简写CLR)将会引发一个<code>InvalidCastException</code>异常。你可以在<a href="#csp_8">第7章</a> &quot;异常处理&quot; 中学到更多有关异常处理的知识。</p><h3 id="_4-4-小结" tabindex="-1"><a class="header-anchor" href="#_4-4-小结" aria-hidden="true">#</a> 4.4 小结</h3><p>在这一章中，你学到了C#中用到的各种类型。简单的值类型包括整型、布尔型、浮点型和小数型。你会非常经常地用到一些类型，进行数学和金融的计算，还有逻辑表达。</p><p>在介绍引用类型之前，我显示了一个看起来象类的结构类型。它几乎如一个类般地运作，但它只是一个值类型，这使它更加适合需要有大量的小对象的场合。</p><p>引用类型起始于所有对象之母的<code>object</code>本身。object是C#中所有对象的基类，且它同样用于值类型的加框和消框。除此之外，我还让你领略了代表元、字符串和数组。</p><p>令C#程序员十分神气的类型就是类。它是C#面向对象编程的心脏，下一章整章专门让你迅速理解这个激动人心且功能强大的类型</p><h2 id="第五章-类" tabindex="-1"><a class="header-anchor" href="#第五章-类" aria-hidden="true">#</a> <a id="csp_6">第五章 类</a></h2><p>前一章讨论了数据类型和它们的用法。现在我们转移到C#中至关重要的结构——类。没有了类，就连简单的C#程序都不能编译。这一章假定你知道了一个类的基本组成部分：方法、属性、构造函数和析构函数。 C#在其中增加了索引和事件。</p><p>在这一章中，你学到下列有关类的话题。</p><ul><li>使用构造函数和析构函数</li><li>给类写方法</li><li>给一个类增加属性存取标志</li><li>实现索引</li><li>创建事件并通过代表元为事件关联客户</li><li>应用类、成员和存取修饰符。</li></ul><h3 id="_5-1-构造函数和析构函数" tabindex="-1"><a class="header-anchor" href="#_5-1-构造函数和析构函数" aria-hidden="true">#</a> 5.1 构造函数和析构函数</h3><p>在你可以访问一个类的方法、属性或任何其它东西之前， 第一条执行的语句是包含有相应类的构造函数。甚至你自己不写一个构造函数，也会有一个缺省的构造函数提供给你。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">class</span> <span class="token class-name">TestClass</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 由编译器提供</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个构造函数总是和它的类名相同，但是，它没有声明返回类型。总之，构造函数总是<code>public</code>的，你可以用它们来初始化变量。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 在这给变量</span>
    <span class="token comment">// 初始化代码等等。</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果类仅包含静态成员(能以类型调用，而不是以实例调用的成员)，你可以创建一个<code>private</code>的构造函数。</p><p><code>private TestClass() {}</code></p><p>尽管存取修饰符在这一章的后面将要大篇幅地讨论，但是private意味着从类的外面不可能访问该构造函数。所以，它不能被调用，且没有对象可以自该类定义被实例化。</p><p>并不仅限于无参数构造函数——你可以传递初始参数来初始化成员。</p><p><code>public TestClass(string strName, int nAge) { ... }</code></p><p>作为一个C/C++程序员，你可能习惯于给初始化写一个附加的方法，因为在构造函数中没有返回值。当然，尽管在C#中也没有返回值，但你可以引发一个自制的异常，以从构造函数获得返回值。更多有关异常处理的知识在<a href="#csp_8">第七章</a> &quot;异常处理&quot;中有讨论。</p><p>但是，当你保留引用给宝贵的资源，应该想到写一个方法来解决：一个可以被显式地调用来释放这些资源。问题是当你可以在析构函数(以类名的前面加&quot;~&quot;的方式命名)中做同样的事情时，为何还要写一个附加的方法.</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token operator">~</span><span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 清除</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你应该写一个附加方法的原因是垃圾收集器，它在变量超出范围后并不会立即被调用，而仅当间歇期间或内存条件满足时才被触发。当你锁住资源的时间长于你所计划的时间时，它就会发生。因此，提供一个显式的释放方式是一个好主意，它同样能从析构函数中调用。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 释放所有宝贵的资源</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token operator">~</span><span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>调用析构函数中的释放方法并不是必要的——总之，垃圾收集会留意释放对象。但没有忘记清除是一种良好的习惯。</p><h3 id="_5-2-方法" tabindex="-1"><a class="header-anchor" href="#_5-2-方法" aria-hidden="true">#</a> 5.2 方法</h3><p>既然对象能正确地初始化和结束，所剩下来的就是往类中增加功能。在大多数情况下，功能的主要部分在方法中能得到实现。你早已见过静态方法的使用，但是，这些是类型(类)的部分，不是实例(对象)。</p><p>为了让你迅速入门，我把这些方法的烦琐问题安排为三节：</p><ul><li>方法参数</li><li>改写方法</li><li>方法屏蔽</li></ul><h4 id="_5-2-1-方法参数" tabindex="-1"><a class="header-anchor" href="#_5-2-1-方法参数" aria-hidden="true">#</a> 5.2.1 方法参数</h4><p>因方法要处理更改数值，你多多少少要传递值给方法，并从方法获得返回值。以下三个部分涉及到由传递值和为调用者获取返回结果所引起的问题。</p><ul><li>输入参数</li><li>引用参数</li><li>输出参数</li></ul><h5 id="_5-2-1-1-输入参数" tabindex="-1"><a class="header-anchor" href="#_5-2-1-1-输入参数" aria-hidden="true">#</a> 5.2.1.1 输入参数</h5><p>你早已在例子中见过的一个参数就是输入参数。你用一个输入参数通过值传递一个变量给一个方法——方法的变量被调用者传递进来的值的一个拷贝初始化。清单5.1 示范输入参数的使用。</p><p>清单 5.1 通过值传递参数</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SquareSample</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">CalcSquare</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> nSideLength<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> nSideLength<span class="token operator">*</span>nSideLength<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">SquareApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">SquareSample</span> sq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SquareSample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>sq<span class="token punctuation">.</span><span class="token function">CalcSquare</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为我传递值而不是引用给一个变量，所以当调用方法时(见第16行)，可以使用一个常量表达式(25)。整型结果被传回给调用者作为返回值，它没有存到中间变量就被立即显示到屏幕上 。</p><p>输入参数按C/C++程序员早已习惯的工作方式工作。如果你来自VB，请注意没有能被编译器处理的隐式ByVal或ByRef——如果没有设定，参数总是用值传递。</p><p>这点似乎与我前面所陈述的有冲突：对于一些变量类型，用值传递实际上意味着用引用传递。迷惑吗? 一点背景知识也不需要：COM中的东西就是接口，每一个类可以拥有一个或多个接口。一个接口只不过是一组函数指针，它不包含数据。重复该数组会浪费很多内存资源；所以，仅开始地址被拷贝给方法，它作为调用者，仍然指向接口的相同指针。那就是为什么对象用值传递一个引用。</p><h5 id="_5-2-1-2-引用参数" tabindex="-1"><a class="header-anchor" href="#_5-2-1-2-引用参数" aria-hidden="true">#</a> 5.2.1.2 引用参数</h5><p>尽管可以利用输入参数和返回值建立很多方法，但你一想到要传递值并原地修改它(也就是在相同的内存位置)，就没有那么好运了。这里用引用参数就很方便。</p><p><code>void myMethod(ref int nInOut)</code></p><p>因为你传递了一个变量给该方法(不仅仅是它的值)，变量必须被初始化。否则，编译器会报警。</p><p>清单 5.2 显示如何用一个引用参数建立一个方法。</p><p>清单 5.2 通过引用传递参数</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token comment">// class SquareSample</span>
<span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SquareSample</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CalcSquare</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">int</span></span> nOne4All<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        nOne4All <span class="token operator">*=</span> nOne4All<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">SquareApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">SquareSample</span> sq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SquareSample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name"><span class="token keyword">int</span></span> nSquaredRef <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 一定要初始化</span>
        sq<span class="token punctuation">.</span><span class="token function">CalcSquare</span><span class="token punctuation">(</span><span class="token keyword">ref</span> nSquaredRef<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>nSquaredRef<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>正如所看到的，所有你要做的就是给定义和调用都加上<code>ref</code>限定符。因为变量通过引用传递，你可以用它来计算出结果并传回该结果。但是，在现实的应用程序中，我强烈建议要用两个变量，一个输入参数和一个引用参数。</p><h5 id="_5-2-1-3-输出参数" tabindex="-1"><a class="header-anchor" href="#_5-2-1-3-输出参数" aria-hidden="true">#</a> 5.2.1.3 输出参数</h5><p>传递参数的第三种选择就是把它设作一个输出参数。正如该名字所暗示，一个输出参数仅用于从方法传递回一个结果。它和引用参数的另一个区别在于：调用者不必先初始化变量才调用方法。这显示在清单5.3中。</p><p>清单 5.3 定义一个输出参数</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SquareSample</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CalcSquare</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> nSideLength<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name"><span class="token keyword">int</span></span> nSquared<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        nSquared <span class="token operator">=</span> nSideLength <span class="token operator">*</span> nSideLength<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">SquareApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">SquareSample</span> sq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SquareSample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">int</span></span> nSquared<span class="token punctuation">;</span> <span class="token comment">// 不必初始化</span>
        sq<span class="token punctuation">.</span><span class="token function">CalcSquare</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token keyword">out</span> nSquared<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>nSquared<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_5-2-2-改写方法" tabindex="-1"><a class="header-anchor" href="#_5-2-2-改写方法" aria-hidden="true">#</a> 5.2.2 改写方法</h4><p>面向对象设计的重要原则就是多态性。不要理会高深的理论，多态性意味着：当基类程序员已设计好用于改写的方法时，在派生类中，你就可以重定义(改写)基类的方法。基类程序员可以用<code>virtual</code> 关键字设计方法：</p><p><code>virtual void CanBOverridden()</code></p><p>当从基类派生时，所有你要做的就是在新方法中加入<code>override</code>关键字：</p><p><code>override void CanBOverridden()</code></p><p>当改写一个基类的方法时，你必须明白，不能改变方法的访问属性——在这章的后面，你会学到更多关于访问修饰符的知识。</p><p>除了改写基类方法的事实外，还有另一个甚至更重要的改写特性。当把派生类强制转换成基类类型并接着调用虚拟方法时，被调用的是派生类的方法而不是基类的方法。</p><p><code>((BaseClass)DerivedClassInstance).CanBOverridden();</code></p><p>为了演示虚拟方法的概念，清单 5.4 显示如何创建一个三角形基类，它拥有一个可以被改写的成员方法（<code>ComputeArea</code>）。</p><p>清单 5.4 改写一个基类的方法</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Triangle</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">ComputeArea</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> c<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Heronian formula</span>
        <span class="token class-name"><span class="token keyword">double</span></span> s <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">double</span></span> dArea <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>s <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> dArea<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">RightAngledTriangle</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Triangle</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">ComputeArea</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> c<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">double</span></span> dArea <span class="token operator">=</span> a <span class="token operator">*</span> b <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> dArea<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">TriangleTestApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">Triangle</span> tri <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Triangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>tri<span class="token punctuation">.</span><span class="token function">ComputeArea</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RightAngledTriangle</span> rat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">RightAngledTriangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>rat<span class="token punctuation">.</span><span class="token function">ComputeArea</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>基类<code>Triangle</code>定义了方法<code>ComputeArea</code>。它采用三个参数，返回一个<code>double</code>结果，且具有公共访问性。从<code>Triangle</code>类派生出的是<code>RightAngledTriangle</code>，它改写了<code>ComputeArea</code> 方法，并实现了自己的面积计算公式。两个类都被实例化，且在命名为<code>TriangleTestApp</code>的应用类的<code>Main()</code> 方法中得到验证。</p><p>我漏了解释第14行：</p><p><code>class RightAngledTriangle : Triangle</code></p><p>在类语句中冒号（<code>：</code>）表示<code>RightAngledTriangle</code>从类 <code>Triangle</code>派生。那就是你所必须要做的，以让C#知道你想把 <code>Triangle</code>当作<code>RightAngledTriangle</code>的基类。</p><p>当仔细观察直角三角形的<code>ComputeArea</code>方法时，你会发现第3个参数并没有用于计算。但是，利用该参数就可以验证是否是“直角”。如清单5.5所示。</p><p>清单 5.5 调用基类实现</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">class</span> <span class="token class-name">RightAngledTriangle</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Triangle</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">ComputeArea</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> c<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token class-name"><span class="token keyword">double</span></span> dEpsilon <span class="token operator">=</span> <span class="token number">0.0001</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">double</span></span> dArea <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">Abs</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">*</span> a <span class="token operator">+</span> b <span class="token operator">*</span> b <span class="token operator">-</span> c <span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> dEpsilon<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            dArea <span class="token operator">=</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">ComputeArea</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            dArea <span class="token operator">=</span> a <span class="token operator">*</span> b <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dArea<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该检测简单地利用了毕达哥拉斯公式，对于直角三角形，检测结果必须为0。如果结果不为0，类就调用它基类的 <code>ComputeArea</code>来实现。</p><p><code>dArea = base.ComputeArea(a,b,c);</code></p><p>例子的要点为：通过显式地利用基类的资格检查，你就能轻而易举地调用基类实现改写方法。当你需要实现其在基类中的功能，而不愿意在改写方法中重复它时，这就非常有帮助。</p><h4 id="_5-2-3-方法屏蔽" tabindex="-1"><a class="header-anchor" href="#_5-2-3-方法屏蔽" aria-hidden="true">#</a> 5.2.3 方法屏蔽</h4><p>重定义方法的一个不同手段就是要屏蔽基类的方法。当从别人提供的类派生类时，这个功能特别有价值。看清单 5.6，假设<code>BaseClass</code>由其他人所写，而你从它派生出 <code>DerivedClass</code> 。</p><p>清单 5.6 Derived Class 实现一个没有包含于 Base Class中的方法</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">BaseClass</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">DerivedClass</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">BaseClass</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;DerivedClass::TestMethod&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">TestApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">DerivedClass</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DerivedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        test<span class="token punctuation">.</span><span class="token function">TestMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个例子中，<code>DerivedClass</code> 通过<code>TestMethod()</code>实现了一个额外的功能。但是，如果基类的开发者认为把<code>TestMethod()</code>放在基类中是个好主意，并使用相同的名字实现它时，会出现什么问题呢？（见清单5.7）</p><p>清单 5.7 Base Class 实现和 Derived Class相同的方法</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">class</span> <span class="token class-name">BaseClass</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;BaseClass::TestMethod&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">DerivedClass</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">BaseClass</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;DerivedClass::TestMethod&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在优秀的编程语言中，你现在会遇到一个真正的大麻烦。但是，C#会给你提出警告：</p><p><code>hiding2.cs(13,14): warning CS0114: &#39;DerivedClass.TestMethod()&#39; hides inherited member &#39;BaseClass.TestMethod()&#39;. To make the current method override that implementation, add the override keyword. Otherwise add the new keyword.</code></p><p>（hiding2.cs(13,14):警告 CS0114:&#39;DerivedClass.TestMethod()&#39; 屏蔽了所继承的成员&#39;BaseClass.TestMethod()&#39;。要想使当前方法改写原来的实现，加上 override关键字。否则加上新的关键字。）</p><p>具有了修饰符<code>new</code>，你就可以告诉编译器，不必重写派生类或改变使用到派生类的代码，你的方法就能屏蔽新加入的基类方法。清单5.8 显示如何在例子中运用new修饰符。</p><p>清单 5.8 屏蔽基类方法</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">class</span> <span class="token class-name">BaseClass</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;BaseClass::TestMethod&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">DerivedClass</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">BaseClass</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;DerivedClass::TestMethod&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用了附加的<code>new</code>修饰符，编译器就知道你重定义了基类的方法，它应该屏蔽基类方法。但是，如果你按以下方式编写：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name">DerivedClass</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DerivedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span>BaseClass<span class="token punctuation">)</span>test<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">TestMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>基类方法的实现就被调用了。这种行为不同于改写方法，后者保证大部分派生方法获得调用。</p><h3 id="_5-3-类属性" tabindex="-1"><a class="header-anchor" href="#_5-3-类属性" aria-hidden="true">#</a> 5.3 类属性</h3><p>有两种途径揭示类的命名属性——通过域成员或者通过属性。前者是作为具有公共访问性的成员变量而被实现的；后者并不直接回应存储位置，只是通过 存取标志(accessors)被访问。</p><p>当你想读出或写入属性的值时，存取标志限定了被实现的语句。用于读出属性的值的存取标志记为关键字<code>get</code>，而要修改属性的值的读写符标志记为<code>set</code>。在你对该理论一知半解以前，请看一下清单5.9中的例子，属性<code>SquareFeet</code>被标上了<code>get</code>和<code>set</code>的存取标志。</p><p>清单 5.9 实现属性存取标志</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">House</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">int</span></span> m_nSqFeet<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> SquareFeet
    <span class="token punctuation">{</span>
        <span class="token keyword">get</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_nSqFeet<span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">set</span> <span class="token punctuation">{</span> m_nSqFeet <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">TestApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">House</span> myHouse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">House</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myHouse<span class="token punctuation">.</span>SquareFeet <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>myHouse<span class="token punctuation">.</span>SquareFeet<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>House</code>类有一个命名为<code>SquareFeet</code>的属性，它可以被读和写。实际的值存储在一个可以从类内部访问的变量中——如果你想当作一个域成员重写它，你所要做的就是忽略存取标志而把变量重新定义为：</p><p><code>public int SquareFeet;</code></p><p>对于一个如此简单的变量，这样不错。但是，如果你想要隐藏类内部存储结构的细节时，就应该采用存取标志。在这种情况下，set 存取标志给值参数中的属性传递新值。（可以改名，见第10行。）</p><p>除了能够隐藏实现细节外，你还可自由地限定各种操作：</p><ul><li>get和set：允许对属性进行读写访问。</li><li>get only：只允许读属性的值。</li><li>set only：只允许写属性的值。</li></ul><p>除此之外，你可以获得实现在set标志中有效代码的机会。例如，由于种种原因（或根本没有原因），你就能够拒绝一个新值。最好是没有人告诉你它是一个动态属性——当你第一次请求它后，它会保存下来，故要尽可能地推迟资源分配。</p><h3 id="_5-4-索引" tabindex="-1"><a class="header-anchor" href="#_5-4-索引" aria-hidden="true">#</a> 5.4 索引</h3><p>你想过象访问数组那样使用索引访问类吗 ？使用C#的索引功能，对它的期待便可了结。</p><p>语法基本上象这样：</p><p><code>属性 修饰符 声明 { 声明内容 }</code></p><p>具体的例子为</p><div class="language-CS" data-ext="CS"><pre class="language-CS"><code>public string this[int nIndex]
{
    get { ... }
    set { ... }
}
</code></pre></div><p>索引返回或按给出的<code>index</code>设置字符串。它没有属性，但使用了<code>public</code>修饰符。声明部分由类型<code>string</code>和<code>this</code> 组成用于表示类的索引。</p><p><code>get</code>和<code>set</code>的执行规则和属性的规则相同。（你不能取消其中一个。） 只存在一个差别，那就是：你几乎可以任意定义大括弧中的参数。限制为，必须至少规定一个参数，允许ref 和out 修饰符。</p><p><code>this</code>关键字确保一个解释。索引没有用户定义的名字，<code>this</code> 表示默认接口的索引。如果类实现了多个接口，你可以增加更多个由InterfaceName.this说明的索引。</p><p>为了演示一个索引的使用，我创建了一个小型的类，它能够解析一个主机名为IP地址——或一个IP地址列表(以http://www.microsoft.com为例 )。这个列表通过索引可以访问，你可以看一下清单5.10 的具体实现。</p><p>清单 5.10 通过一个索引获取一个IP地址</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Net</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">ResolveDNS</span>
<span class="token punctuation">{</span>
    <span class="token class-name">IPAddress<span class="token punctuation">[</span><span class="token punctuation">]</span></span> m_arrIPs<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Resolve</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> strHost<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">IPHostEntry</span> iphe <span class="token operator">=</span> DNS<span class="token punctuation">.</span><span class="token function">GetHostByName</span><span class="token punctuation">(</span>strHost<span class="token punctuation">)</span><span class="token punctuation">;</span>
        m_arrIPs <span class="token operator">=</span> iphe<span class="token punctuation">.</span>AddressList<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name">IPAddress</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token class-name"><span class="token keyword">int</span></span> nIndex<span class="token punctuation">]</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">get</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> m_arrIPs<span class="token punctuation">[</span>nIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> Count
    <span class="token punctuation">{</span>
        <span class="token keyword">get</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_arrIPs<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">DNSResolverApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">ResolveDNS</span> myDNSResolver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ResolveDNS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myDNSResolver<span class="token punctuation">.</span><span class="token function">Resolve</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.microsoft.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">int</span></span> nCount <span class="token operator">=</span> myDNSResolver<span class="token punctuation">.</span>Count<span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Found {0} IP&#39;s for hostname&quot;</span><span class="token punctuation">,</span> nCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>myDNSResolver<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了解析主机名，我用到了<code>DNS</code>类，它是<code>System.Net</code> 名字空间的一部分。但是，由于这个名字空间并不包含在核心库中，所以必须在编译命令行中引用该库：</p><p><code>csc /r:System.Net.dll /out:resolver.exe dnsresolve.cs</code></p><p>解析代码是向前解析的。在该<code>Resolve</code>方法中，代码调用DNS类的静态方法<code>GetHostByName</code>，它返回一个<code>IPHostEntry</code>对象。结果，该对象包含有我要找的数组——<code>AddressList</code>数组。在退出<code>Resolve</code>方法之前，在局部的对象实例成员<code>m_arrIPs</code>中，存储了一个<code>AddressList array</code>的拷贝(类型IPAddress 的对象存储在其中)。</p><p>具有现在生成的数组 ，通过使用在类ResolveDNS中求得的索引，应用程序代码就可以在第37至38行列举出IP地址。(在<a href="#csp_7">第6章</a> &quot;控制语句&quot;，有更多有关语句的信息。) 因为没有办法更改IP地址，所以仅给索引使用了get存取标志。为了简单其见，我忽略了数组的边界溢出检查。</p><h3 id="_5-4-事件" tabindex="-1"><a class="header-anchor" href="#_5-4-事件" aria-hidden="true">#</a> 5.4 事件</h3><p>当你写一个类时，有时有必要让类的客户知道一些已经发生的事件。如果你是一个具有多年编程经验的程序员，似乎有很多的解决办法，包括用于回调的函数指针和用于ActiveX控件的事件接收（event sinks）。现在你将要学到另外一种把客户代码关联到类通知的办法——使用事件。</p><p>事件既可以被声明为类域成员（成员变量），也可以被声明为属性。两者的共性为，事件的类型必定是代表元，而函数指针原形和C#的代表元具有相同的含义。</p><p>每一个事件都可以被0或更多的客户占用，且客户可以随时关联或取消事件。你可以以静态或者以实例方法定义代表元，而后者很受C++程序员的欢迎。</p><p>既然我已经提到了事件的所有功能及相应的代表元，请看清单5.11中的例子。它生动地体现了该理论。</p><p>清单5.11 在类中实现事件处理</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token comment">// 向前声明</span>
<span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EventHandler</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> strText<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">EventSource</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">EventHandler</span> TextOut<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TriggerEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> TextOut<span class="token punctuation">)</span> <span class="token function">TextOut</span><span class="token punctuation">(</span><span class="token string">&quot;Event triggered&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">TestApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">EventSource</span> evsrc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">EventSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        evsrc<span class="token punctuation">.</span>TextOut <span class="token operator">+=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">EventHandler</span><span class="token punctuation">(</span>CatchEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>
        evsrc<span class="token punctuation">.</span><span class="token function">TriggerEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        evsrc<span class="token punctuation">.</span>TextOut <span class="token operator">-=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">EventHandler</span><span class="token punctuation">(</span>CatchEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>
        evsrc<span class="token punctuation">.</span><span class="token function">TriggerEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">TestApp</span> theApp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TestApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        evsrc<span class="token punctuation">.</span>TextOut <span class="token operator">+=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">EventHandler</span><span class="token punctuation">(</span>theApp<span class="token punctuation">.</span>InstanceCatch<span class="token punctuation">)</span><span class="token punctuation">;</span>
        evsrc<span class="token punctuation">.</span><span class="token function">TriggerEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CatchEvent</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> strText<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>strText<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InstanceCatch</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> strText<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Instance &quot;</span> <span class="token operator">+</span> strText<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>第4行声明了代表元（事件方法原形），它用来给第8行中的EventSource类声明TextOut事件域成员。你可以观察到代表元作为一种新的类型声明，当声明事件时可以使用代表元。</p><p>该类仅有一个方法，它允许我们触发事件。请注意，你必须进行事件域成员不为null的检测，因为可能会出现没有客户对事件感兴趣这种情况。</p><p>TestApp类包含了Main方法，也包含了另外两个方法，它们都具备事件所必需的信号。其中一个方法是静态的，而另一个是实例方法。</p><p><code>EventSource</code> 被实例化，而静态方法CatchEvent被预关联上了TextOut事件：</p><p><code>evsrc.TextOut += new EventHandler(CatchEvent);</code></p><p>从现在起，当事件被触发时，该方法被调用。如果你对事件不再感兴趣，简单地取消关联：</p><p><code>evsrc.TextOut -= new EventHandler(CatchEvent);</code></p><p>注意，你不能随意取消关联的处理函数——在类代码中仅创建了这些处理函数。为了证明事件处理函数也和实例方法一起工作，余下的代码建立了TestApp 的实例，并钩住事件处理方法。</p><p>事件在哪方面对你特别有用？你将经常在ASP+中或使用到WFC (Windows Foundation Classes)时，涉及到事件和代表元。</p><h3 id="_5-5-应用修饰符" tabindex="-1"><a class="header-anchor" href="#_5-5-应用修饰符" aria-hidden="true">#</a> 5.5 应用修饰符</h3><p>在这一章的学习过程中，你已经见过了象<code>public</code>、<code>virtual</code>等修饰符。欲以一种易于理解的方法概括它们，我把它们划分为三节：</p><ul><li>类修饰符</li><li>成员修饰符</li><li>存取修饰符</li></ul><h4 id="_5-5-1-类修饰符" tabindex="-1"><a class="header-anchor" href="#_5-5-1-类修饰符" aria-hidden="true">#</a> 5.5.1 类修饰符</h4><p>到目前为止，我还没有涉及到类修饰符，而只涉及到了应用于类的存取修饰符。但是，有两个修饰符你可以用于类：</p><ul><li><code>abstract</code>——关于抽象类的重要一点就是它不能被实例化。只有不是抽象的派生类才能被实例化。派生类必须实现抽象基类的所有抽象成员。你不能给抽象类使用sealed修饰符。</li><li><code>sealed</code>——密封 类不能被继承。使用该修饰符防止意外的继承，在.NET框架中的类用到这个修饰符。</li></ul><p>要见到两个修饰符的运用，看看清单5.12 ，它创建了一个基于一个抽象类的密封类（肯定是一个十分极端的例子）。</p><p>清单 5.12 抽象类和密封类</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractClass</span>
<span class="token punctuation">{</span>
    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">DerivedClass</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">AbstractClass</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;sealed class&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">DerivedClass</span> dc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DerivedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dc<span class="token punctuation">.</span><span class="token function">MyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_5-5-2-成员修饰符" tabindex="-1"><a class="header-anchor" href="#_5-5-2-成员修饰符" aria-hidden="true">#</a> 5.5.2 成员修饰符</h4><p>与有用的成员修饰符的数量相比，类修饰符的数量很少。我已经提到了一些，这本书即将出现的例子描述了其它的成员修饰符。</p><p>以下是有用的成员修饰符：</p><ul><li><code>abstract</code>——说明一个方法或存取标志不能含有一个实现。它们都是隐式虚拟，且在继承类中，你必须提供 override关键字。</li><li><code>const</code>——这个修饰符应用于域成员或局部变量。在编译时常量表达式被求值，所以，它不能包含变量的引用。</li><li><code>event</code> ——定义一个域成员或属性作为类型事件。用于捆绑客户代码到类的事件。</li><li><code>extern</code>——告诉编译器方法实际上由外部实现。第10章 “和非受管代码互相操作” 将全面地涉及到外部代码。</li><li><code>override</code>——用于改写任何基类中被定义为virtual的方法和存取标志。要改写的名字和基类的方法必须一致。</li><li><code>readonly</code>——一个使用 readonly修饰符的域成员只能在它的声明或者在包含它的类的构造函数中被更改。</li><li><code>static</code>——被声明为static的成员属于类，而不属于类的实例。你可以用static 于域成员、方法、属性、操作符甚至构造函数。</li><li><code>virtual</code>——说明方法或存取标志可以被继承类改写。</li></ul><h4 id="_5-5-3-存取修饰符" tabindex="-1"><a class="header-anchor" href="#_5-5-3-存取修饰符" aria-hidden="true">#</a> 5.5.3 存取修饰符</h4><p>存取修饰符定义了某些代码对类成员（如方法和属性）的存取等级。你必须给每个成员加上所希望的存取修饰符，否则，默认的存取类型是隐含的。</p><p>你可以应用4个 存取修饰符之一：</p><ul><li><code>public</code>——任何地方都可以访问该成员，这是具有最少限制的存取修饰符。</li><li><code>protected</code>——在类及所有的派生类中可以访问该成员，不允许外部访问。</li><li><code>private</code>——仅仅在同一个类的内部才能访问该成员。甚至派生类都不能访问它。</li><li><code>internal</code>——允许相同组件（应用程序或库）的所有代码访问。在.NET组件级别，你可以把它视为public，而在外部则为private。</li></ul><p>为了演示存取修饰符的用法，我稍微修改了Triangle例子，使它包含了新增的域成员和一个新的派生类（见清单 5.13）。</p><p>清单 5.13 在类中使用存取修饰符</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Triangle</span>
<span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token class-name"><span class="token keyword">int</span></span> m_a<span class="token punctuation">,</span> m_b<span class="token punctuation">,</span> m_c<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">Triangle</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> c<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        m_a <span class="token operator">=</span> a<span class="token punctuation">;</span>
        m_b <span class="token operator">=</span> b<span class="token punctuation">;</span>
        m_c <span class="token operator">=</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Heronian formula</span>
        <span class="token class-name"><span class="token keyword">double</span></span> s <span class="token operator">=</span> <span class="token punctuation">(</span>m_a <span class="token operator">+</span> m_b <span class="token operator">+</span> m_c<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">double</span></span> dArea <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>s <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> m_a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> m_b<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> m_c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> dArea<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Prism</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Triangle</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">int</span></span> m_h<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">Prism</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> c<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> h<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        m_h <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">double</span></span> dArea <span class="token operator">=</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
        dArea <span class="token operator">+=</span> m_a <span class="token operator">*</span> m_h <span class="token operator">+</span> m_b <span class="token operator">*</span> m_h <span class="token operator">+</span> m_c <span class="token operator">*</span> m_h<span class="token punctuation">;</span>
        <span class="token keyword">return</span> dArea<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">PrismApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">Prism</span> prism <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Prism</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>prism<span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Triangle</code>类和 <code>Prism</code> 类现在被标为 <code>internal</code>。这意味着它们只能在当前组件中被访问。请记住“.NET组件”这个术语指的是包装（ packaging,），而不是你可能在COM+中用到的组件。<code>Triangle</code> 类有三个 <code>protected</code>成员，它们在构造函数中被初始化，并用于面积计算的方法中。由于这些成员是<code>protected</code> 成员，所以我可以在派生类<code>Prism</code>中访问它们，在那里执行不同的面积计算。<code>Prism</code>自己新增了一个成员<code>m_h</code>，它是私有的——甚至派生类也不能访问它。</p><p>花些时间为每个类成员甚至每个类计划一种保护层次，通常是个好主意。当需要引入修改时，全面的计划最终会帮助你，因为没有程序员会愿意使用“没有文档”的类功能。</p><h3 id="_5-6-小结" tabindex="-1"><a class="header-anchor" href="#_5-6-小结" aria-hidden="true">#</a> 5.6 小结</h3><p>这章显示了类的各种要素，它是运行实例（对象）的模板。在一个对象的生命期，首先被执行的代码是个构造函数。构造函数用来初始化变量，这些变量后来在方法中用于计算结果。</p><p>方法允许你传递值、引用给变量，或者只传送一个输出值。方法可以被改写以实现新的功能，或者你可以屏蔽基类成员，如果它实现了一个具有和派生类成员相同名字的方法。</p><p>命名属性可以被当作域成员（成员变量）或属性存取标志实现。后者是<code>get</code>和<code>set</code>存取标志，忽略一个或另外一个，你可以创建仅写或仅读属性。存取标志非常适合于确认赋给属性的值。</p><p>C#类的另外一个功能是索引，它使象数组语法一样访问类中值成为可能。还有，如果当类中的某些事情发生时，你想客户得到通知，要让它们与事件关联。</p><p>当垃圾收集器调用析构函数时，对象的生命就结束了。由于你不能准确地预测这种情况什么时候会发生，所以应该创建一个方法以释放这些宝贵的资源，当你停止使用它们时。</p><h2 id="第六章-控制语句" tabindex="-1"><a class="header-anchor" href="#第六章-控制语句" aria-hidden="true">#</a> <a id="csp_7">第六章 控制语句</a></h2><p>有一种语句，你在每种编程语言控制流程语句中都可以找到。在这一章中，我介绍了C#的控制语句，它们分为两个主要部分：</p><ul><li>选择语句</li><li>循环语句</li></ul><p>如果你是C或C++程序员，很多信息会让你感到似曾相似；但是，你必须知道它们还存在着一些差别。</p><h3 id="_6-1-选择语句" tabindex="-1"><a class="header-anchor" href="#_6-1-选择语句" aria-hidden="true">#</a> 6.1 选择语句</h3><p>当运用选择语句时，你定义了一个控制语句，它的值控制了哪个语句被执行。在C#中用到两个选择语句：</p><ul><li><code>if</code> 语句</li><li><code>switch</code> 语句</li></ul><h4 id="_6-1-1-if-语句" tabindex="-1"><a class="header-anchor" href="#_6-1-1-if-语句" aria-hidden="true">#</a> 6.1.1 <code>if</code> 语句</h4><p>最先且最常用到的语句是 <code>if</code> 语句。内含语句是否被执行取决于布尔表达式：</p><p><code>if (布尔表达式) 内含语句</code></p><p>当然，也可以有<code>else</code>分枝，当布尔表达式的值为假时，该分枝就被执行：</p><p><code>if (布尔表达式) 内含语句 else 内含语句</code></p><p>在执行某些语句之前就检查一个非零长字符串的例子：</p><p><code>if (0 != strTest.Length){ }</code></p><p>这是一个布尔表达式。（!=表示不等于。） 但是，如果你来自C或者C++，可能会习惯于编写象这样的代码：</p><p><code>if (strTest.Length){}</code></p><p>这在C#中不再工作，因为 <code>if</code> 语句仅允许布尔（bool） 数据类型的结果，而字符串的Length属性对象返回一个整形（integer）。编译器将出现以下错误信息：</p><p><code>error CS0029: Cannot implicitly convert type &#39;int&#39; to &#39;bool&#39;</code><br>（不能隐式地转换类型 &#39;int&#39; 为 &#39;bool&#39;。）</p><p>上边是你必须改变的习惯，而下边将不会再在 <code>if</code> 语句中出现赋值错误：</p><p><code>if (nMyValue = 5) ...</code></p><p>正确的代码应为</p><p><code>if (nMyValue == 5) ...</code></p><p>因为相等比较由<code>==</code>实行，就象在C和C++中一样。看以下有用的对比操作符（但并不是所有的数据类型都有效）：</p><ul><li><code>==</code> ——如果两个值相同，返回真。</li><li><code>!=</code> ——如果两个值不同，返回假。</li><li><code>&lt;</code>,<code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> —— 如果满足了关系（小于、小于或等于、大于、大于或等于），返回真。</li></ul><p>每个操作符是通过重载操作符被执行的，而且这种执行对数据类型有规定。如果你比较两个不同的类型，对于编译器，必须存在着一个隐式的转换，以便自动地创建必要的代码。但是，你可以执行一个显式的类型转换。</p><p>清单 6.1 中的代码演示了 <code>if</code> 语句的一些不同的使用场合，同时也演示了如何使用字符串数据类型。这个程序的主要思想是，确定传递给应用程序的第一个参数是否以大写字母、小写字母或者数字开始。</p><p>清单 6.1 确定字符的形态</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">NestedIfApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>Length <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Usage: one argument&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// error level</span>
        <span class="token punctuation">}</span>

        <span class="token class-name"><span class="token keyword">char</span></span> chLetter <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>chLetter <span class="token operator">&gt;=</span> <span class="token char">&#39;A&#39;</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>chLetter <span class="token operator">&lt;=</span> <span class="token char">&#39;Z&#39;</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;{0} is uppercase&quot;</span><span class="token punctuation">,</span> chLetter<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        
        chLetter <span class="token operator">=</span> Char<span class="token punctuation">.</span><span class="token function">FromString</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>chLetter <span class="token operator">&gt;=</span> <span class="token char">&#39;a&#39;</span> <span class="token operator">&amp;&amp;</span> chLetter <span class="token operator">&lt;=</span> <span class="token char">&#39;z&#39;</span><span class="token punctuation">)</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;{0} is lowercase&quot;</span><span class="token punctuation">,</span> chLetter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Char<span class="token punctuation">.</span><span class="token function">IsDigit</span><span class="token punctuation">(</span><span class="token punctuation">(</span>chLetter <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;{0} is a digit&quot;</span><span class="token punctuation">,</span> chLetter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>始于第7行的第一个 <code>if</code> 语段检测参数数组是否只有一个字符串。如果不满足条件，程序就在屏幕上显示用法信息，并终止运行。</p><p>可以采取多种方法从一个字符串中提取出单个字符——既可象第13行那样利用字符索引，也可以使用<code>Char</code>类的静态 <code>FromString</code> 方法，它返回字符串的第一个字符。</p><p>第16～20行的 <code>if</code> 语句块使用一个嵌套 的<code>if</code> 语句块检查大写字母。用逻辑“与”操作符（&amp;&amp;）可以胜任小写字母的检测，而最后通过使用<code>Char</code>类的静态函数<code>IsDigit</code>，就可以完成对数字的检测。</p><p>除了“&amp;&amp;”操作符之外，还有另一个条件逻辑操作符，它就是代表“或”的“||”。两个逻辑操作符都 是“短路”式的。对于“&amp;&amp;”操作符，意味着如果条件“与”表达式的第一个结果返回一个假值，余下的条件“与”表达式就不会再被求值了。相对应，“||”操作符当第一个真条件满足时，它就“短路”了。</p><p>我想让大家理解的是，要减少计算时间，你应该把最有可能使求值“短路”的表达式放在前面。同样你应该清楚，计算 <code>if</code> 语句中的某些值会存在着替在的危险。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">==</span> <span class="token punctuation">(</span>strLength<span class="token operator">=</span>str<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>strLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然，这是一个极其夸张的例子，但它说明了这样的观点：第一条语句求值为真，那么第二条语句就不会被执行，它使变量<code>strLength</code>维持原值。给大家一个忠告：决不要在具有条件逻辑操作符的 <code>if</code> 语句中赋值。</p><h4 id="_6-1-2-switch-语句" tabindex="-1"><a class="header-anchor" href="#_6-1-2-switch-语句" aria-hidden="true">#</a> 6.1.2 switch 语句</h4><p>和 if 语句相比，<code>switch</code>语句有一个控制表达式，而且内含语句按它们所关联的控制表达式的常量运行。</p><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>switch (控制表达式)
{
    case 常量表达式:
        内含语句
    default:
        内含语句
}
</code></pre></div><p>控制表达式所允许的数据类型 为： sbyte, byte, short, ushort, uint, long, ulong, char, string, 或者枚举类型。只要使其它不同数据类型能隐式转换成上述的任何类型，用它作为控制表达式也很不错。</p><p><code>switch</code> 语句接以下顺序执行：</p><ol><li>控制表达式求值</li><li>如果 case 标签后的常量表达式符合控制语句所求出的值，内含语句被执行。</li><li>如果没有常量表达式符合控制语句，在default 标签内的内含语句被执行。</li><li>如果没有一个符合case 标签，且没有default 标签，控制转向switch 语段的结束端。</li></ol><p>在继续更详细地探讨switch语句之前，请看清单 6.2 ，它演示用 switch语句来显示一个月的天数（忽略跨年度）</p><p>清单 6.2 使用switch语句显示一个月的天数</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">FallThrough</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>Length <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token class-name"><span class="token keyword">int</span></span> nMonth <span class="token operator">=</span> Int32<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nMonth <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> nMonth <span class="token operator">&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">int</span></span> nDays <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">switch</span> <span class="token punctuation">(</span>nMonth<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span> nDays <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>
            <span class="token keyword">case</span> <span class="token number">6</span><span class="token punctuation">:</span>
            <span class="token keyword">case</span> <span class="token number">9</span><span class="token punctuation">:</span>
            <span class="token keyword">case</span> <span class="token number">11</span><span class="token punctuation">:</span> nDays <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token punctuation">:</span> nDays <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;{0} days in this month&quot;</span><span class="token punctuation">,</span> nDays<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>switch</code> 语段包含于第13~21行。对于C程序员，这看起来非常相似，因为它不使用<code>break</code>语句。因此，存在着一个更具生命力的重要差别。你必须加上一个<code>break</code>语句（或一个不同的跳转语句），因为编译器会提醒，不允许直达下一部分。</p><p>何谓直达？在C（和C++）中，忽略<code>break</code>并且按以下编写代码是完全合法的：</p><div class="language-c" data-ext="c"><pre class="language-c"><code>nVar <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>nVar<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
        <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
        <span class="token function">DoMore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个例子中，在执行了第一个<code>case</code>语句的代码后，将直接执行到其它<code>case</code>标签的代码，直到一个<code>break</code>语句退出<code>switch</code>语段为止。尽管有时这是一个强大的功能，但它更经常地产生难于发现的缺陷。</p><p>可如果你想执行其它case标签的代码，那怎么办？ 有一种办法，它显示于清单6.3中。</p><p>清单 6.3　在swtich语句中使用 goto 标签　和 goto default</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">SwitchApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">Random</span> objRandom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">double</span></span> dRndNumber <span class="token operator">=</span> objRandom<span class="token punctuation">.</span><span class="token function">NextDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">int</span></span> nRndNumber <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>dRndNumber <span class="token operator">*</span> <span class="token number">10.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">switch</span> <span class="token punctuation">(</span>nRndNumber<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token comment">//什么也不做</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>
                <span class="token keyword">goto</span> <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Handler for 2 and 3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>
                <span class="token keyword">goto</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
            <span class="token comment">// everything beyond a goto will be warned as</span>
            <span class="token comment">// unreachable code</span>
            <span class="token keyword">default</span><span class="token punctuation">:</span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Random number {0}&quot;</span><span class="token punctuation">,</span> nRndNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个例子中，通过Random类产生用于控制表达式的值（第７～９行）。<code>switch</code>语段包含两个对<code>switch</code>语句有效的跳转语句。</p><ul><li><code>goto case</code> 　标签：跳转到所说明的标签</li><li><code>goto default:</code> 跳转到 default　标签</li></ul><p>有了这两个跳转语句，你可以创建同Ｃ一样的功能，但是，直达不再是自动的。你必须明确地请求它。</p><p>不再使用直达功能的更深的含义为：你可任意排列标签，如把default标签放在其它所有标签的前面。为了说明它，我创建了一个例子，故意不结束循环：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>nSomething<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>
        <span class="token keyword">goto</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我已经保留了其中一个<code>switch</code> 语句功能的讨论直至结束——事实上你可以使用字符串作为常量表达式。这对于VB程序员，可能听起来不象是什么大的新闻，但来自Ｃ或Ｃ++的程序员将会喜欢这个新功能。</p><p>现在，一个 <code>switch</code> 语句可以如以下所示检查字符串常量了。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">string</span></span> strTest <span class="token operator">=</span> <span class="token string">&quot;Chris&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>strTest<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&quot;Chris&quot;</span><span class="token punctuation">:</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Hello Chris!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_6-2-循环语句" tabindex="-1"><a class="header-anchor" href="#_6-2-循环语句" aria-hidden="true">#</a> 6.2 循环语句</h3><p>当你想重复执行某些语句或语段时，依据当前不同的任务，Ｃ＃提供４个不同的循环语句选择给你使用：</p><ul><li><code>for</code> 语句</li><li><code>foreach</code> 语句</li><li><code>while</code> 语句</li><li><code>do</code> 语句</li></ul><h4 id="_6-2-1-for-语句" tabindex="-1"><a class="header-anchor" href="#_6-2-1-for-语句" aria-hidden="true">#</a> 6.2.1 for 语句</h4><p>当你预先知道一个内含语句应要执行多少次时，<code>for</code> 语句特别有用。当条件为真时，常规语法允许重复地执行内含语句（和循环表达式）：</p><p><code>for (初始化;条件;循环) 内含语句</code></p><p>请注意，初始化、条件和循环都是可选的。如果忽略了条件，你就可以产生一个死循环，要用到跳转语句（break 或goto）才能退出。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 由于某些原因</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另外一个重点是，你可以同时加入多条由逗号隔开的语句到for循环的所有三个参数。例如，你可以初始化两个变量、拥有三个条件语句，并重复4个变量。</p><p>作为C或C++程序员，你必须了解仅有的一个变化：条件语句必须为布尔表达式，就象 if 语句一样。</p><p>清单6.4 包含使用 for 语句的一个例子。它显示了如何计算一个阶乘，比使用递归函数调用还要快。</p><p>清单 6.4 在for 循环里计算一个阶乘</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Factorial</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">long</span></span> nFactorial <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">long</span></span> nComputeTo <span class="token operator">=</span> Int64<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name"><span class="token keyword">long</span></span> nCurDig <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>nCurDig <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> nCurDig <span class="token operator">&lt;=</span> nComputeTo<span class="token punctuation">;</span> nCurDig<span class="token operator">++</span><span class="token punctuation">)</span>
            nFactorial <span class="token operator">*=</span> nCurDig<span class="token punctuation">;</span>

        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;{0}! is {1}&quot;</span><span class="token punctuation">,</span> nComputeTo<span class="token punctuation">,</span> nFactorial<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>尽管该例子过于拖沓，但它作为如何使用<code>for</code>语句的一个开端。首先，我本应在初始化内部声明变量<code>nCurDig</code>：</p><p><code>for (long nCurDig=1;nCurDig &lt;= nComputeTo; nCurDig++) nFactorial *= nCurDig;</code></p><p>另一种忽略初始化的选择如下行，因为第10行在<code>for</code>语句的外部初始化了变量。（记住C#需要初始化变量）：</p><p><code>for (;nCurDig &lt;= nComputeTo; nCurDig++) nFactorial *= nCurDig;</code></p><p>另一种改变是把<code>++</code>操作符移到内含语句中：</p><p><code>for ( ;nCurDig &lt;= nComputeTo; ) nFactorial *= nCurDig++;</code></p><p>如果我也想摆脱条件语句，全部要做的是增加一条<code>if</code>语句，用<code>break</code> 语句中止循环：</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nCurDig <span class="token operator">&gt;</span> nComputeTo<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    nFactorial <span class="token operator">*=</span> nCurDig<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除了用于退出for语句的break语句外，你还可以用continue 跳过当前循环，并继续下一次循环。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>nCurDig <span class="token operator">&lt;=</span> nComputeTo<span class="token punctuation">;</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">==</span> nCurDig<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 这行跳过了余下的代码</span>
    nFactorial <span class="token operator">*=</span> nCurDig<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_6-2-2-foreach-语句" tabindex="-1"><a class="header-anchor" href="#_6-2-2-foreach-语句" aria-hidden="true">#</a> 6.2.2 foreach 语句</h4><p>已经在Visual Basic 语言中存在了很久的一个功能是，通过使用For Each 语句收集枚举。C#通过foreach 语句，也有一个用来收集枚举的命令：</p><p><code>foreach(表达式中的类型标识符） 内含语句</code></p><p>循环变量由类型和标识符声明，且表达式与收集相对应。循环变量代表循环正在为之运行的收集元素。</p><p>你应该知道不能赋一个新值给循环变量，也不能把它当作<code>ref</code> 或<code>out</code> 参数。这样引用在内含语句中被执行的代码。</p><p>你如何说出某些类支持<code>foreach</code> 语句？ 简而言之，类必须支持具有 <code>GetEnumerator()</code>名字的方法，而且由其所返回的结构、类或者接口必须具有<code>public</code> 方法<code>MoveNext()</code> 和<code>public</code> 属性<code>Current</code>。如果你想知道更多，请阅读语言参考手册，它有很多关于这个话题的详细内容。</p><p>对于清单 6.5 中的例子，我恰好偶然选了一个类，实现了所有这些需要。我用它来列举被定义过的所有的环境变量。</p><p>清单 6.5 读所有的环境变量</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">EnvironmentDumpApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">IDictionary</span> envvars <span class="token operator">=</span> Environment<span class="token punctuation">.</span><span class="token function">GetEnvironmentVariables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;There are {0} environment variables declared&quot;</span><span class="token punctuation">,</span> envvars<span class="token punctuation">.</span>Keys<span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name">String</span> strKey <span class="token keyword">in</span> envvars<span class="token punctuation">.</span>Keys<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;{0} = {1}&quot;</span><span class="token punctuation">,</span> strKey<span class="token punctuation">,</span> envvars<span class="token punctuation">[</span>strKey<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对<code>GetEnvironmentVariables</code>的调用返回一个<code>IDictionary</code>类型接口，它是由.NET框架中的许多类实现了的字典接口。通过 <code>IDictionary</code> 接口，可以访问两个收集：<code>Keys</code> 和 <code>Values</code>。在这个例子里，我在foreach语句中使用Keys，接着查找基于当前key值的值（第12行）。</p><p>当使用foreach时，只要注意一个问题：当确定循环变量的类型时，应该格外小心。选择错误的类型并没有受到编译器的检测，但它会在运行时受检测，且会引发一个异常。</p><h4 id="_6-2-3-while-语句" tabindex="-1"><a class="header-anchor" href="#_6-2-3-while-语句" aria-hidden="true">#</a> 6.2.3 while 语句</h4><p>当你想执行一个内含语句0次或更多次时，while语句正是你所盼望的：</p><p><code>while (条件) 内含语句</code></p><p>条件语句——它也是一个布尔表达式 ——控制内含语句被执行的次数。你可以使用 break 和continue语句来控制while语句中的执行语句，它的运行方式同在for语句中的完全相同。</p><p>为了举例while的用法，清单 6.6 说明如何使用一个 StreamReader类输出C#源文件到屏幕。</p><p>清单 6.6 显示一个文件的内容</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">WhileDemoApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">StreamReader</span> sr <span class="token operator">=</span> File<span class="token punctuation">.</span><span class="token function">OpenText</span><span class="token punctuation">(</span><span class="token string">&quot;whilesample.cs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> strLine <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> <span class="token punctuation">(</span>strLine <span class="token operator">=</span> sr<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>strLine<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        sr<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>代码打开文件 <code>whilesample.cs</code>, 接着当<code>ReadLine</code> 方法返回一个不等于<code>null</code>的值时，就在屏幕上显示所读取的值。注意，我在while条件语句中用到一个赋值。如果有更多的用<code>&amp;&amp;</code>和<code>||</code>连接起来的条件语句，我不能保证它们是否会被执行，因为存在着“短路”的可能。</p><h4 id="_6-2-4-do-语句" tabindex="-1"><a class="header-anchor" href="#_6-2-4-do-语句" aria-hidden="true">#</a> 6.2.4 do 语句</h4><p>C#最后可利用的循环语句是do语句。它与while语句十分相似，仅当经过最初的循环之后，条件才被验证。</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">do</span>
<span class="token punctuation">{</span>
    内含语句
<span class="token punctuation">}</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>条件<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>do语句保证内含语句至少被执行过一次，而且只要条件求值等于真，它们继续被执行。通过使用break语句，你可以迫使运行退出 do 语块。如果你想跳过这一次循环，使用continue语句。</p><p>一个如何使用do语句的例子显示在清单 6.7中。它向用户请求一个或多个数字，并且当执行程序退出do循环后计算平均值。</p><p>清单 6.7 在do 循环中计算平均值</p><div class="language-csharp" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ComputeAverageApp</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">ComputeAverageApp</span> theApp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ComputeAverageApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        theApp<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">double</span></span> dValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">double</span></span> dSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">int</span></span> nNoOfValues <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">char</span></span> chContinue <span class="token operator">=</span> <span class="token char">&#39;y&#39;</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">string</span></span> strInput<span class="token punctuation">;</span>

        <span class="token keyword">do</span>
        <span class="token punctuation">{</span>
            Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;Enter a value: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            strInput <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            dValue <span class="token operator">=</span> Double<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>strInput<span class="token punctuation">)</span><span class="token punctuation">;</span>
            dSum <span class="token operator">+=</span> dValue<span class="token punctuation">;</span>
            nNoOfValues<span class="token operator">++</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;Read another value?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            strInput <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            chContinue <span class="token operator">=</span> Char<span class="token punctuation">.</span><span class="token function">FromString</span><span class="token punctuation">(</span>strInput<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token char">&#39;y&#39;</span> <span class="token operator">==</span> chContinue<span class="token punctuation">)</span><span class="token punctuation">;</span>

        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;The average is {0}&quot;</span><span class="token punctuation">,</span> dSum <span class="token operator">/</span> nNoOfValues<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个例子里，我在静态 Main函数中实例化 <code>ComputeAverageApp</code>类型的一个对象。它同样接着调用实例的Run方法，该方法包含了计算平均值所有必要的功能。</p><p>do 循环跨越第19~31行。条件是这样设定的：分别回答各个问题 “y”，以决定是否要增加另一个值。输入任何其它字符会引起程序退出 do语块，且平均值被计算。</p><p>正如你可以从提到的例子看出，do语句和while语句差别不太大——仅有的差别就是条件在什么时候被求值。</p><h3 id="_6-3-小结" tabindex="-1"><a class="header-anchor" href="#_6-3-小结" aria-hidden="true">#</a> 6.3 小结</h3><p>这章解释了如何使用C#中用到的各种选择和循环语句。 if 语句在应用程序中可能是最为常用的语句。当在布尔表达式中使用计算时，编译器会为你留意。但是，你一定要确保条件语句的短路不会阻止必要代码的运行。</p><p><code>switch</code> 语句——尽管同样与C语言的相应部分相似——但也被改善了。直达不再被支持，而且你可以使用字符串标签，对于C程序员，这是一种新的用法。</p><p>在这一章的最后部分，我说明如何使用<code>for</code>、<code>foreach</code>、<code>while</code>和<code>do</code>语句。语句完成各种需要，包括执行固定次数的循环、列举收集元素和执行基于某些条件的任意次数的语句。</p><h2 id="第七章-异常处理" tabindex="-1"><a class="header-anchor" href="#第七章-异常处理" aria-hidden="true">#</a> <a id="csp_8">第七章 异常处理</a></h2><h2 id="第八章-用c-写组件" tabindex="-1"><a class="header-anchor" href="#第八章-用c-写组件" aria-hidden="true">#</a> <a id="csp_9">第八章 用C#写组件</a></h2><h2 id="第九章-配置和调度" tabindex="-1"><a class="header-anchor" href="#第九章-配置和调度" aria-hidden="true">#</a> <a id="csp_10">第九章 配置和调度</a></h2><p>译者的话 前言 第1章 C＃概述 1.1 为什么需要C＃ 1.1.1 简单性 1.1.2 现代性 1.1.3 面向对象 1.1.4 类型安全性 1.1.5 版本处理技术 1.1.6 兼容性 1.1.7 灵活性 1.2 小结 第2章 理论基础——公用语言运行环境 2.1 公用语言运行环境 2.1.1 中间语言和元数据 2.1.2 即时编译器 2.2 虚拟对象系统 2.2.1 VOS类型系统 2.2.2 元数据 2.2.3 公用语言规范 2.2.4 虚拟运行系统 2.3 小结 第3章 第一个C＃应用程序 3.1 选择一个编辑器 3.2 Hello World代码 3.3 编译程序 3.4 输入和输出 3.5 添加注释 3.6 小结 第4章 C＃的数据类型 4.1 值类型 4.1.1 简单类型 4.1.2 结构类型 4.1.3 枚举类型 4.2 引用类型 4.2.1 对象类型 4.2.2 类（Class）类型 4.2.3 接口 4.2.4 代表（Delegate） 4.2.5 string类型 4.2.6 数组（Arrays） 4.3 装箱（Boxing）和拆箱（Unboxing） 4.3.1 装箱转换 4.3.2 拆箱转换 4.4 小结 第5章 类 5.1 构造器与析构器 5.2 方法 5.2.1 方法中的参数 5.2.2 方法的重载 5.2.3 方法的覆盖 5.3 类的属性 5.4 索引指示器 5.5 事件 5.6 修饰符的使用 5.6.1 类修饰符 5.6.2 成员变量修饰符 5.6.3 访问修饰符 5.7 小结 第6章 控制语句 6.1 选择语句 6.1.1 IF语句 6.1.2 switch语句 6.2 循环语句 6.2.1 fof语句 6.2.2 foreach语句 6.2.3 While语句 6.2.4 do语句 6.3 小结 第7章 异常处理 7.1 检测语句和不检测语句 7.1.1 在编译器设置面板中设置溢出检测 7.1.2 程序内的溢出检测 7.2 异常处理的语句 7.2.1 用try－catch进行捕捉 7.2.2 用try－finally进行清除 7.2.3 用try－catch－finally来处理所有异常 7.3 抛出异常 7.3.1 再次抛出异常 7.3.2 构建自己的异常事件类 7.4 异常处理中应注意事项 7.5 小结 第8章 在C＃中编写组件 8.1 第一个组件 8.1.1 创建组件 8.1.2 编译组件 8.1.3 创建一个简单的客户应用程序 8.2 使用名字空间 8.2.1 在名字空间中包装一个类 8.2.2 在客户端应用程序中使用名字空间 8.2.3 在名字空间中加入多个类 8.3 小结 第9章 配置和部署 9.1 条件编译 9.1.1 预处理器的使用 9.1.2 Conditional属性 9.2 XML中的文档注释 9.2.1 描述元素 9.2.2 添加备注和表单 9.2.3 提供示例 9.2.4 描述参数 9.2.5 描述属性 9.2.6 编译文档 9.3 为代码编写版本号 9.4 小结 第10章 用未操控的代码进行内部操作 10.1 COM互用性 10.1.1 向COM展示.NET对象 10.1.2 向.NET对象展示COM对象 10.2 平台请求服务 10.3 不安全代码 10.4 小结 第11章 调试C＃代码 11.1 调试任务 11.1.1 为应用程序创建一个调试版本 11.1.2 选择一个可执行的程序 11.1.3 设置中断点 11.1.4 逐句测试程序 11.1.5 添加到一个进程 11.1.6 检查并修改变量 11.1.7 管理异常事件处理 11.1.8 JIT调试 11.1.9 调试组件 11.2 中间语言分解器 11.3 小结 第12章 安全性 12.1 代码访问安全机制 12.1.1 类型安全的确认 12.1.2 许可 12.2 基于角色的安全机制 12.3 小结</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1508727061@qq.com">FHL</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/steven-blogs/assets/app-8e5157a8.js" defer></script>
  </body>
</html>
